(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],2:[function(require,module,exports){
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      var left = arguments[0].left;
      var top = arguments[0].top;

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          typeof left === 'number' ? left : this.scrollLeft,
          typeof top === 'number' ? top : this.scrollTop
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(
          this,
          arguments[0] === undefined ? true : arguments[0]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var toArray = exports.toArray = function toArray(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return arrayLike;
  }

  if (arrayLike instanceof Node) {
    return [arrayLike];
  }

  return Array.prototype.slice.call(arrayLike);
};

var $ = exports.$ = function $(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll.call(context, selector));
};

var selector = exports.selector = function selector(block, elem, modName, modVal) {
  return block + '__' + elem + (modName ? modVal ? '_' + modName + '_' + modVal : '_' + modName : '');
};

var buildClass = exports.buildClass = function buildClass() {
  return '.' + selector.apply(undefined, arguments);
};

var BEM = exports.BEM = function (_ref) {
  _inherits(BEM, _ref);

  function BEM(name, node) {
    _classCallCheck(this, BEM);

    var _this = _possibleConstructorReturn(this, (BEM.__proto__ || Object.getPrototypeOf(BEM)).call(this));

    _this.node = node;
    _this.name = name;
    return _this;
  }

  _createClass(BEM, [{
    key: 'elem',
    value: function elem(name, modName, modVal) {
      return this.node.querySelector(buildClass(this.name, name, modName, modVal));
    }
  }, {
    key: 'elems',
    value: function elems(name, modName, modVal) {
      return $(buildClass(this.name, name, modName, modVal), this.node);
    }
  }, {
    key: 'setMod',
    value: function setMod(elem, elemName, modName, modValue) {
      var _this2 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.add(selector(_this2.name, elemName, modName, modValue));
      });

      return this;
    }
  }, {
    key: 'delMod',
    value: function delMod(elem, elemName, modName) {
      var _this3 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.remove(selector(_this3.name, elemName, modName));
      });

      return this;
    }
  }]);

  return BEM;
}(null);

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feedback = function (_BEM) {
  _inherits(Feedback, _BEM);

  function Feedback(node) {
    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this, 'feedback', node));

    _this.$name = _this.elem('name');
    _this.$message = _this.elem('message');
    _this.$mailTo = _this.elem('mailto');

    node.onsubmit = function (e) {
      e.preventDefault();

      _this.$mailTo.href = 'mailto:info@nszu.gov.ua?subject=\u0417\u0432\u043E\u0440\u043E\u0442\u043D\u0456\u0439 \u0437\u0432\u2019\u044F\u0437\u043E\u043A \u0432\u0456\u0434 ' + _this.$name.value + '&body=' + _this.$message.value;
      _this.$mailTo.click();
      return false;
    };
    return _this;
  }

  return Feedback;
}(_dom.BEM);

exports.default = Feedback;
module.exports = exports['default'];

},{"./dom":3}],5:[function(require,module,exports){
'use strict';

var _promisePolyfill = require('promise-polyfill');

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _smoothscrollPolyfill = require('smoothscroll-polyfill');

var _smoothscrollPolyfill2 = _interopRequireDefault(_smoothscrollPolyfill);

var _dom = require('./dom');

var _utils = require('./utils');

var _nav = require('./nav');

var _nav2 = _interopRequireDefault(_nav);

var _tabs = require('./tabs');

var _tabs2 = _interopRequireDefault(_tabs);

var _slider = require('./slider');

var _slider2 = _interopRequireDefault(_slider);

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _statistic = require('./statistic');

var _statistic2 = _interopRequireDefault(_statistic);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.Promise) {
  window.Promise = _promisePolyfill2.default;
}

_smoothscrollPolyfill2.default.polyfill();

(0, _dom.$)('.nav').forEach(function (node) {
  return new _nav2.default(node);
});
(0, _dom.$)('.tabs').forEach(function (node) {
  return new _tabs2.default(node);
});
(0, _dom.$)('.slider').forEach(function (node) {
  return new _slider2.default(node);
});
(0, _dom.$)('.feedback').forEach(function (node) {
  return new _feedback2.default(node);
});

(0, _utils.fetchJSON)('data/stats.json').then(function (data) {
  (0, _dom.$)('.declarations').forEach(function (node) {
    return new _statistic2.default(node, data);
  });
});

(0, _utils.fetchJSON)('http://dev.ehealth.world/reports/stats/regions').then(function (data) {
  (0, _dom.$)('.map').forEach(function (node) {
    return new _map2.default(node, data.data);
  });
});

(0, _utils.fetchJSON)('http://dev.ehealth.world/reports/stats/').then(function (data) {
  var joined_items = (0, _dom.$)('.joined__item-count');
  joined_items[0].innerText = data.data.msps;
  joined_items[1].innerText = data.data.doctors;
  joined_items[2].innerText = data.data.declarations;
});

},{"./dom":3,"./feedback":4,"./map":6,"./nav":7,"./slider":8,"./statistic":9,"./tabs":10,"./utils":11,"promise-polyfill":1,"smoothscroll-polyfill":2}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require("./dom");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HOVER_DEBOUNCE_TIMEOUT = 200;

var REGION_POINT_MAP = {
  "М.КИЇВ": { left: 453, top: 175 },
  "КИЇВСЬКА": { left: 453, top: 140 },
  "ВОЛИНСЬКА": { left: 153, top: 100 },
  "ЛЬВІВСЬКА": { left: 83, top: 206 },
  "ЗАКАРПАТСЬКА": { left: 48, top: 312 },
  "ІВАНО-ФРАНКІВСЬКА": { left: 153, top: 312 },
  "ЧЕРНІВЕЦЬКА": { left: 207, top: 329 },
  "ТЕРНОПІЛЬСЬКА": { left: 188, top: 241 },
  "РІВНЕНСЬКА": { left: 241, top: 100 },
  "ХМЕЛЬНИЦЬКА": { left: 259, top: 206 },
  "ЖИТОМИРСЬКА": { left: 347, top: 153 },
  "ВІННИЦЬКА": { left: 365, top: 277 },
  "ЧЕРКАСЬКА": { left: 523, top: 241 },
  "КІРОВОГРАДСЬКА": { left: 541, top: 312 },
  "ПОЛТАВСЬКА": { left: 646, top: 188 },
  "ЧЕРНІГІВСЬКА": { left: 541, top: 65 },
  "СУМСЬКА": { left: 646, top: 100 },
  "ХАРКІВСЬКА": { left: 770, top: 205 },
  "ЛУГАНСЬКА": { left: 911, top: 259 },
  "ДНІПРОПЕТРОВСЬКА": { left: 682, top: 311 },
  "ДОНЕЦЬКА": { left: 840, top: 347 },
  "ЗАПОРІЗЬКА": { left: 752, top: 417 },
  "ХЕРСОНСЬКА": { left: 629, top: 452 },
  "МИКОЛАЇВСЬКА": { left: 523, top: 399 },
  "ОДЕСЬКА": { left: 453, top: 435 },
  "АВТОНОМНА РЕСПУБЛІКА КРИМ": { left: 664, top: 558 },
  "М.СЕВАСТОПОЛЬ": { left: 614, top: 588 }
};

var createPoint = function createPoint(_ref) {
  var left = _ref.left,
      top = _ref.top;

  var node = document.createElement('div');

  node.classList.add('map__point');
  node.style.left = left + "px";
  node.style.top = top + "px";

  return node;
};

var Map = function (_BEM) {
  _inherits(Map, _BEM);

  function Map(node, data) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, 'map', node));

    _this.data = [];
    _this.timeout = null;


    _this.data = data;
    _this.$tooltip = _this.elem('tooltip');

    var fragment = document.createDocumentFragment();

    data.forEach(function (item, index) {
      var point = createPoint(REGION_POINT_MAP[item.region.name]);
      point.dataset.index = index;

      point.addEventListener('mouseover', _this, false);
      point.addEventListener('mouseout', _this, false);

      fragment.appendChild(point);
    });

    _this.$tooltip.addEventListener('mouseover', _this, false);
    _this.$tooltip.addEventListener('mouseout', _this, false);

    _this.elem('main').appendChild(fragment);
    return _this;
  }

  _createClass(Map, [{
    key: "handleEvent",
    value: function handleEvent(_ref2) {
      var _this2 = this;

      var target = _ref2.target,
          type = _ref2.type;

      if (type === 'mouseover' && target.dataset.index) {
        this.$tooltip.style.top = target.style.top;
        this.$tooltip.style.left = target.style.left;
      }

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        switch (type) {
          case 'mouseout':
            _this2.delMod(_this2.$tooltip, 'tooltip', 'show');
            _this2.delMod(_this2.$active, 'point', 'active');
            break;
          case 'mouseover':
            var data = _this2.data[target.dataset.index];

            if (data) {
              var $tooltipData = _this2.$tooltip.querySelectorAll((0, _dom.buildClass)('map', 'tooltip-data') + " dt");

              _this2.$tooltip.style.top = target.style.top;
              _this2.$tooltip.style.left = target.style.left;

              _this2.$active && _this2.delMod(_this2.$active, 'point', 'active');
              _this2.setMod(_this2.$tooltip, 'tooltip', 'show');

              _this2.$tooltip.querySelector((0, _dom.buildClass)('map', 'tooltip-title')).textContent = data.region.name;
              _this2.$active = target;

              $tooltipData[0].textContent = data.stats.msps;
              $tooltipData[1].textContent = data.stats.doctors;
              $tooltipData[2].textContent = data.stats.declarations;

              _this2.setMod(_this2.$active, 'point', 'active');
            }

            _this2.setMod(_this2.$tooltip, 'tooltip', 'show');
            break;
        }
      }, HOVER_DEBOUNCE_TIMEOUT);
    }
  }]);

  return Map;
}(_dom.BEM);

exports.default = Map;
module.exports = exports["default"];

},{"./dom":3}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Nav = function Nav(node) {
  _classCallCheck(this, Nav);

  node.addEventListener('click', function (e) {
    e.preventDefault();

    if (e.target.href === undefined) {
      return;
    }

    var to = e.target.href.split('#')[1];

    var _document$getElementB = document.getElementById(to).getBoundingClientRect(),
        top = _document$getElementB.top;

    window.scroll({ top: top + window.scrollY - 50, left: 0, behavior: 'smooth' });
  });
};

exports.default = Nav;
module.exports = exports['default'];

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createMarker = function createMarker() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var node = document.createElement('li');

  node.classList.add((0, _dom.selector)('slider', 'marker'));
  active && node.classList.add((0, _dom.selector)('slider', 'marker', 'active'));

  return node;
};

var Slider = function (_BEM) {
  _inherits(Slider, _BEM);

  function Slider(node) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', node));

    _this.currentIndex = 0;

    _this.$slides = _this.elems('slide');

    _this.$markers = [];

    _this.$control = document.createElement('ul');
    _this.$control.classList.add((0, _dom.selector)(_this.name, 'markers'));

    _this.$slides.forEach(function (node, index) {
      var marker = createMarker(index === _this.currentIndex);
      _this.$control.appendChild(marker);
      _this.$markers.push(marker);
    });

    _this.$control.addEventListener('click', function (_ref) {
      var target = _ref.target;

      if (!target.closest((0, _dom.buildClass)(_this.name, 'marker'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('marker', 'active'), 'marker', 'active');
      _this.setMod(target, 'marker', 'active');

      _this.slide(toIndex);
    }, false);

    _this.node.appendChild(_this.$control);
    return _this;
  }

  _createClass(Slider, [{
    key: 'slide',
    value: function slide(index) {
      var isNext = this.currentIndex < index;

      this.$slides[this.currentIndex].animate([{ transform: 'translateX(0)' }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)' }], this.constructor.ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)' }, { transform: 'translateX(0)' }], this.constructor.ANIMATION_OPTIONS);

      this.currentIndex = index;
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$markers.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Slider;
}(_dom.BEM);

Slider.ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};
exports.default = Slider;
module.exports = exports['default'];

},{"./dom":3}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORS_MAP = ['#90c8e6', '#b097c6', '#dfb0d0', '#e3aab8', '#afd5e7', '#c7b2d5', '#e9c7df', '#ecc7cf', '#f1eec9', '#ced8e2', '#5da892', '#5296cd', '#a3d7f2', '#f3f1a0', '#bcdad5', '#71b7a8', '#5ca9dc', '#dc91a3', '#d8816f', '#e2a394', '#7566aa', '#cadfeb', '#ddd2df', '#f4d9b5', '#d381b2'];

var createListItemNode = function createListItemNode(title, value, color) {
  var $li = document.createElement('li');
  var $span = document.createElement('span');
  var $value = document.createElement('div');

  $li.classList.add((0, _dom.selector)('declarations', 'list-item'));
  $li.textContent = title;

  $span.style.backgroundColor = color;

  $value.classList.add((0, _dom.selector)('declarations', 'list-item-value'));
  $value.textContent = (0, _utils.numberFormatting)(value);

  $li.prepend($span);
  $li.append($value);

  return $li;
};

var Statistic = function (_BEM) {
  _inherits(Statistic, _BEM);

  function Statistic(node, data) {
    _classCallCheck(this, Statistic);

    var _this = _possibleConstructorReturn(this, (Statistic.__proto__ || Object.getPrototypeOf(Statistic)).call(this, 'declarations', node));

    var fragment = document.createDocumentFragment();

    _this.$canvas = _this.elem('graph-canvas');
    _this.context = _this.$canvas.getContext('2d');

    var total = data.reduce(function (target, _ref) {
      var declarations = _ref.declarations;
      return target + declarations;
    }, 0);

    data.sort(function (a, b) {
      return a.declarations < b.declarations ? 1 : -1;
    });

    var x = 490,
        y = 490,
        r = 480,
        s = 0;


    data.forEach(function (item, index) {
      var $item = createListItemNode(item.region_name, item.declarations, COLORS_MAP[index]);

      fragment.appendChild($item);

      var radians = item.declarations / data[0].declarations * 360 * (Math.PI / 360);

      _this.context.beginPath();
      _this.context.lineWidth = 6;
      _this.context.strokeStyle = COLORS_MAP[index];
      _this.context.arc(x, y, r - 20 * index, s, radians, false);
      _this.context.stroke();
    });

    _this.elem('list').appendChild(fragment);
    _this.elem('total-value').textContent = (0, _utils.numberFormatting)(total);
    return _this;
  }

  return Statistic;
}(_dom.BEM);

exports.default = Statistic;
module.exports = exports['default'];

},{"./dom":3,"./utils":11}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PANEL_ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};

var Tabs = function (_BEM) {
  _inherits(Tabs, _BEM);

  function Tabs(node) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoHeight = _ref.autoHeight,
        autoHeight = _ref$autoHeight === undefined ? false : _ref$autoHeight;

    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, 'tabs', node));

    _this.$controls = _this.elems('nav-item');
    _this.$slides = _this.elems('slide');

    _this.$marker = document.createElement('div');
    _this.$marker.classList.add((0, _dom.selector)(_this.name, 'marker'));
    _this.elem('header').appendChild(_this.$marker);

    if (autoHeight) {
      var maxHeight = _this.$slides.reduce(function (target, item) {
        if (item.clientHeight > target) {
          target = item.clientHeight;
        }

        return target;
      }, 0);

      _this.elem('main').style.height = maxHeight + 'px';
    }

    _this.currentIndex = _this.getIndexByElem(_this.elem('nav-item', 'active'));

    _this.elem('nav').addEventListener('click', function (e) {
      var $elem = e.target.closest((0, _dom.buildClass)(_this.name, 'nav-item'));

      if (!$elem) {
        return;
      }

      var toIndex = _this.getIndexByElem($elem);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('nav-item', 'active'), 'nav-item', 'active');
      _this.setMod($elem, 'nav-item', 'active');

      _this.animatePanels(toIndex);
      _this.animateMarker(toIndex);

      _this.currentIndex = toIndex;
    }, false);

    _this.setMod(_this.elem('nav-item', 'active'), 'nav-item', 'marker');
    return _this;
  }

  _createClass(Tabs, [{
    key: 'animatePanels',
    value: function animatePanels(index) {
      var current = this.currentIndex;
      var isNext = current < index;

      current !== undefined && this.$slides[current].animate([{ transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)', opacity: 0 }], PANEL_ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)', opacity: 0 }, { transform: 'translateX(0)', opacity: 1 }], PANEL_ANIMATION_OPTIONS);
    }
  }, {
    key: 'animateMarker',
    value: function animateMarker(index) {
      var _this2 = this;

      var current = {
        left: this.$controls[this.currentIndex].offsetLeft,
        width: this.$controls[this.currentIndex].clientWidth
      };

      var left = this.$controls[index].offsetLeft;
      var width = this.$controls[index].clientWidth;

      var player = this.$marker.animate([{
        transform: 'translateX(' + current.left + 'px)',
        width: current.width + 'px'
      }, {
        transform: 'translateX(' + left + 'px)',
        width: width + 'px'
      }], _extends({}, PANEL_ANIMATION_OPTIONS));

      player.onfinish = function () {
        _this2.setMod(_this2.$controls[index], 'nav-item', 'marker');
        requestAnimationFrame(function () {
          return player.cancel();
        });
      };

      this.delMod(this.$controls[this.currentIndex], 'nav-item', 'marker');
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$controls.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Tabs;
}(_dom.BEM);

exports.default = Tabs;
module.exports = exports['default'];

},{"./dom":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var objectToQuery = function objectToQuery(target) {
  return '?' + Object.keys(target).reduce(function (arr, key) {
    return arr.push(key + '=' + target[key]) && arr;
  }, []).join('&');
};

var numberFormatting = exports.numberFormatting = function numberFormatting(number) {
  return number.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1 ').split('.')[0];
};

var fetchJSON = exports.fetchJSON = function fetchJSON(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { method: 'GET' };
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();

    if (options.body && options.method === 'GET') {
      url += objectToQuery(options.body);
    }

    request.onreadystatechange = function () {
      if (request.readyState !== 4) {
        return;
      }

      resolve(JSON.parse(request.responseText));
    };

    request.onerror = reject;
    request.open(options.method || 'GET', url);
    request.send(options.body ? JSON.stringify(options.body) : null);
  });
};

},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcyIsInNyYy9zY3JpcHRzL2RvbS5qcyIsInNyYy9zY3JpcHRzL2ZlZWRiYWNrLmpzIiwic3JjL3NjcmlwdHMvbWFpbi5qcyIsInNyYy9zY3JpcHRzL21hcC5qcyIsInNyYy9zY3JpcHRzL25hdi5qcyIsInNyYy9zY3JpcHRzL3NsaWRlci5qcyIsInNyYy9zY3JpcHRzL3N0YXRpc3RpYy5qcyIsInNyYy9zY3JpcHRzL3RhYnMuanMiLCJzcmMvc2NyaXB0cy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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R0FGTixDQURjO0FBQUEsQ0FBdEI7O0FBTU8sSUFBTSw4Q0FBbUIsU0FBbkIsZ0JBQW1CO0FBQUEsU0FDOUIsT0FBTyxPQUFQLENBQWUsQ0FBZixFQUFrQixPQUFsQixDQUEwQixxQkFBMUIsRUFBaUQsS0FBakQsRUFBd0QsS0FBeEQsQ0FBOEQsR0FBOUQsRUFBbUUsQ0FBbkUsQ0FEOEI7QUFBQSxDQUF6Qjs7QUFJQSxJQUFNLGdDQUFZLFNBQVosU0FBWSxDQUFDLEdBQUQ7QUFBQSxNQUFNLE9BQU4sdUVBQWdCLEVBQUUsUUFBUSxLQUFWLEVBQWhCO0FBQUEsU0FBc0MsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUM5RixRQUFNLFVBQVUsSUFBSSxjQUFKLEVBQWhCOztBQUVBLFFBQUksUUFBUSxJQUFSLElBQWdCLFFBQVEsTUFBUixLQUFtQixLQUF2QyxFQUE4QztBQUM1QyxhQUFPLGNBQWMsUUFBUSxJQUF0QixDQUFQO0FBQ0Q7O0FBRUQsWUFBUSxrQkFBUixHQUE2QixZQUFNO0FBQ2pDLFVBQUksUUFBUSxVQUFSLEtBQXVCLENBQTNCLEVBQThCO0FBQzVCO0FBQ0Q7O0FBRUQsY0FBUSxLQUFLLEtBQUwsQ0FBVyxRQUFRLFlBQW5CLENBQVI7QUFDRCxLQU5EOztBQVFBLFlBQVEsT0FBUixHQUFrQixNQUFsQjtBQUNBLFlBQVEsSUFBUixDQUFhLFFBQVEsTUFBUixJQUFrQixLQUEvQixFQUFzQyxHQUF0QztBQUNBLFlBQVEsSUFBUixDQUFhLFFBQVEsSUFBUixHQUFlLEtBQUssU0FBTCxDQUFlLFFBQVEsSUFBdkIsQ0FBZixHQUE4QyxJQUEzRDtBQUNELEdBbEI4RCxDQUF0QztBQUFBLENBQWxCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocm9vdCkge1xuXG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBcbiAgLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICAgIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHNlbGYsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHNlbGYuX3N0YXRlID0gMjtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgIH1cbiAgICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gICAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICAgKlxuICAgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gICAqL1xuICBmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb20gPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKG5vb3ApO1xuXG4gICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgcmV0dXJuIHByb207XG4gIH07XG5cbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIHBvbHlmaWxsIGZvciBzZXRJbW1lZGlhdGUgZm9yIHBlcmZvcm1hbmNlIGdhaW5zXG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH0pIHx8XG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gICAgfTtcblxuICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBpbW1lZGlhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFja3NcbiAgICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0SW1tZWRpYXRlRm4gPSBmdW5jdGlvbiBfc2V0SW1tZWRpYXRlRm4oZm4pIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9IGZuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuKGZuKSB7XG4gICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmbjtcbiAgfTtcbiAgXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiAgfSBlbHNlIGlmICghcm9vdC5Qcm9taXNlKSB7XG4gICAgcm9vdC5Qcm9taXNlID0gUHJvbWlzZTtcbiAgfVxuXG59KSh0aGlzKTtcbiIsIi8qXG4gKiBzbW9vdGhzY3JvbGwgcG9seWZpbGwgLSB2MC4zLjVcbiAqIGh0dHBzOi8vaWFtZHVzdGFuLmdpdGh1Yi5pby9zbW9vdGhzY3JvbGxcbiAqIDIwMTYgKGMpIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbih3LCBkLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIGFsaWFzZXNcbiAgICogdzogd2luZG93IGdsb2JhbCBvYmplY3RcbiAgICogZDogZG9jdW1lbnRcbiAgICogdW5kZWZpbmVkOiB1bmRlZmluZWRcbiAgICovXG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gcmV0dXJuIHdoZW4gc2Nyb2xsQmVoYXZpb3IgaW50ZXJmYWNlIGlzIHN1cHBvcnRlZFxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBnbG9iYWxzXG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvKlxuICAgICAqIG9iamVjdCBnYXRoZXJpbmcgb3JpZ2luYWwgc2Nyb2xsIG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgb3JpZ2luYWwgPSB7XG4gICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeTogdy5zY3JvbGxCeSxcbiAgICAgIGVsU2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGRlZmluZSB0aW1pbmcgbWV0aG9kXG4gICAgICovXG4gICAgdmFyIG5vdyA9IHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgID8gdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3LnBlcmZvcm1hbmNlKSA6IERhdGUubm93O1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB4XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dCh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnXG4gICAgICAgICAgICB8fCB4ID09PSBudWxsXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdhdXRvJ1xuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gJ2luc3RhbnQnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZyBub3QgYW4gb2JqZWN0L251bGxcbiAgICAgICAgLy8gb3IgYmVoYXZpb3IgaXMgYXV0bywgaW5zdGFudCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHguYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiZWhhdmlvciBub3QgdmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgdmFyIGlzQm9keTtcbiAgICAgIHZhciBoYXNTY3JvbGxhYmxlU3BhY2U7XG4gICAgICB2YXIgaGFzVmlzaWJsZU92ZXJmbG93O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAvLyBzZXQgY29uZGl0aW9uIHZhcmlhYmxlc1xuICAgICAgICBpc0JvZHkgPSBlbCA9PT0gZC5ib2R5O1xuICAgICAgICBoYXNTY3JvbGxhYmxlU3BhY2UgPVxuICAgICAgICAgIGVsLmNsaWVudEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCB8fFxuICAgICAgICAgIGVsLmNsaWVudFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgIGhhc1Zpc2libGVPdmVyZmxvdyA9XG4gICAgICAgICAgdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5vdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgICAgfSB3aGlsZSAoIWlzQm9keSAmJiAhKGhhc1Njcm9sbGFibGVTcGFjZSAmJiAhaGFzVmlzaWJsZU92ZXJmbG93KSk7XG5cbiAgICAgIGlzQm9keSA9IGhhc1Njcm9sbGFibGVTcGFjZSA9IGhhc1Zpc2libGVPdmVyZmxvdyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IHdpdGggYSBzbW9vdGggYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHNtb290aFNjcm9sbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE9SSUdJTkFMIE1FVEhPRFMgT1ZFUlJJREVTXG4gICAgICovXG5cbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQsXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxTY3JvbGwuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzBdLmxlZnQ7XG4gICAgICB2YXIgdG9wID0gYXJndW1lbnRzWzBdLnRvcDtcblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJyA/IGxlZnQgOiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgdHlwZW9mIHRvcCA9PT0gJ251bWJlcicgPyB0b3AgOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZzAgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICAgIGxlZnQ6IGFyZzAubGVmdCArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFyZzAudG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgYmVoYXZpb3I6IGFyZzAuYmVoYXZpb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbChcbiAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgKyBhcmcwLFxuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wICsgYXJndW1lbnRzWzFdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsSW50b1ZpZXcuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG59KSh3aW5kb3csIGRvY3VtZW50KTtcbiIsImV4cG9ydCBjb25zdCB0b0FycmF5ID0gYXJyYXlMaWtlID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlMaWtlKSkge1xuICAgIHJldHVybiBhcnJheUxpa2U7XG4gIH1cblxuICBpZiAoYXJyYXlMaWtlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpO1xufTtcblxuZXhwb3J0IGNvbnN0ICQgPSAoc2VsZWN0b3IsIGNvbnRleHQgPSBkb2N1bWVudCkgPT4gKFxuICB0b0FycmF5KGNvbnRleHQucXVlcnlTZWxlY3RvckFsbC5jYWxsKGNvbnRleHQsIHNlbGVjdG9yKSlcbik7XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RvciA9IChibG9jaywgZWxlbSwgbW9kTmFtZSwgbW9kVmFsKSA9PiAoXG4gIGAke2Jsb2NrfV9fJHtlbGVtfSR7bW9kTmFtZSA/IChtb2RWYWwgPyBgXyR7bW9kTmFtZX1fJHttb2RWYWx9YCA6IGBfJHttb2ROYW1lfWApIDogJyd9YFxuKTtcblxuZXhwb3J0IGNvbnN0IGJ1aWxkQ2xhc3MgPSAoLi4uYXJncykgPT4gYC4ke3NlbGVjdG9yKC4uLmFyZ3MpfWA7XG5cbmV4cG9ydCBjbGFzcyBCRU0gZXh0ZW5kcyBudWxsIHtcbiAgY29uc3RydWN0b3IobmFtZSwgbm9kZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZWxlbShuYW1lLCBtb2ROYW1lLCBtb2RWYWwpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoYnVpbGRDbGFzcyh0aGlzLm5hbWUsIG5hbWUsIG1vZE5hbWUsIG1vZFZhbCkpO1xuICB9XG5cbiAgZWxlbXMobmFtZSwgbW9kTmFtZSwgbW9kVmFsKSB7XG4gICAgcmV0dXJuICQoYnVpbGRDbGFzcyh0aGlzLm5hbWUsIG5hbWUsIG1vZE5hbWUsIG1vZFZhbCksIHRoaXMubm9kZSk7XG4gIH1cblxuICBzZXRNb2QoZWxlbSwgZWxlbU5hbWUsIG1vZE5hbWUsIG1vZFZhbHVlKSB7XG4gICAgdG9BcnJheShlbGVtKS5mb3JFYWNoKG5vZGUgPT4gKFxuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKHRoaXMubmFtZSwgZWxlbU5hbWUsIG1vZE5hbWUsIG1vZFZhbHVlKSlcbiAgICApKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsTW9kKGVsZW0sIGVsZW1OYW1lLCBtb2ROYW1lKSB7XG4gICAgdG9BcnJheShlbGVtKS5mb3JFYWNoKG5vZGUgPT4gKFxuICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKHNlbGVjdG9yKHRoaXMubmFtZSwgZWxlbU5hbWUsIG1vZE5hbWUpKVxuICAgICkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0iLCJpbXBvcnQgeyBCRU0gfSBmcm9tICcuL2RvbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlZWRiYWNrIGV4dGVuZHMgQkVNIHtcbiAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgIHN1cGVyKCdmZWVkYmFjaycsIG5vZGUpO1xuXG4gICAgdGhpcy4kbmFtZSA9IHRoaXMuZWxlbSgnbmFtZScpO1xuICAgIHRoaXMuJG1lc3NhZ2UgPSB0aGlzLmVsZW0oJ21lc3NhZ2UnKTtcbiAgICB0aGlzLiRtYWlsVG8gPSB0aGlzLmVsZW0oJ21haWx0bycpO1xuXG4gICAgbm9kZS5vbnN1Ym1pdCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuJG1haWxUby5ocmVmID0gYG1haWx0bzppbmZvQG5zenUuZ292LnVhP3N1YmplY3Q90JfQstC+0YDQvtGC0L3RltC5INC30LLigJnRj9C30L7QuiDQstGW0LQgJHt0aGlzLiRuYW1lLnZhbHVlfSZib2R5PSR7dGhpcy4kbWVzc2FnZS52YWx1ZX1gO1xuICAgICAgdGhpcy4kbWFpbFRvLmNsaWNrKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59IiwiaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5pbXBvcnQgU21vb3RoU2Nyb2xsIGZyb20gJ3Ntb290aHNjcm9sbC1wb2x5ZmlsbCc7XG5cbmltcG9ydCB7ICQgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgeyBmZXRjaEpTT04gfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IE5hdiBmcm9tICcuL25hdic7XG5pbXBvcnQgVGFicyBmcm9tICcuL3RhYnMnO1xuaW1wb3J0IFNsaWRlciBmcm9tICcuL3NsaWRlcic7XG5pbXBvcnQgTWFwIGZyb20gJy4vbWFwJztcbmltcG9ydCBTdGF0aXN0aWMgZnJvbSAnLi9zdGF0aXN0aWMnO1xuaW1wb3J0IEZlZWRiYWNrIGZyb20gJy4vZmVlZGJhY2snO1xuXG5pZiAoIXdpbmRvdy5Qcm9taXNlKSB7XG4gIHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZTtcbn1cblxuU21vb3RoU2Nyb2xsLnBvbHlmaWxsKCk7XG5cbiQoJy5uYXYnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IE5hdihub2RlKSk7XG4kKCcudGFicycpLmZvckVhY2gobm9kZSA9PiBuZXcgVGFicyhub2RlKSk7XG4kKCcuc2xpZGVyJykuZm9yRWFjaChub2RlID0+IG5ldyBTbGlkZXIobm9kZSkpO1xuJCgnLmZlZWRiYWNrJykuZm9yRWFjaChub2RlID0+IG5ldyBGZWVkYmFjayhub2RlKSk7XG5cbmZldGNoSlNPTignZGF0YS9zdGF0cy5qc29uJykudGhlbihkYXRhID0+IHtcbiAgJCgnLmRlY2xhcmF0aW9ucycpLmZvckVhY2gobm9kZSA9PiBuZXcgU3RhdGlzdGljKG5vZGUsIGRhdGEpKTtcbn0pO1xuXG5mZXRjaEpTT04oJ2h0dHA6Ly9kZXYuZWhlYWx0aC53b3JsZC9yZXBvcnRzL3N0YXRzL3JlZ2lvbnMnKS50aGVuKGRhdGEgPT4ge1xuICAkKCcubWFwJykuZm9yRWFjaChub2RlID0+IG5ldyBNYXAobm9kZSwgZGF0YS5kYXRhKSk7XG59KTtcblxuZmV0Y2hKU09OKCdodHRwOi8vZGV2LmVoZWFsdGgud29ybGQvcmVwb3J0cy9zdGF0cy8nKS50aGVuKGRhdGEgPT4ge1xuICBjb25zdCBqb2luZWRfaXRlbXMgPSAkKCcuam9pbmVkX19pdGVtLWNvdW50Jyk7XG4gIGpvaW5lZF9pdGVtc1swXS5pbm5lclRleHQgPSBkYXRhLmRhdGEubXNwcztcbiAgam9pbmVkX2l0ZW1zWzFdLmlubmVyVGV4dCA9IGRhdGEuZGF0YS5kb2N0b3JzO1xuICBqb2luZWRfaXRlbXNbMl0uaW5uZXJUZXh0ID0gZGF0YS5kYXRhLmRlY2xhcmF0aW9ucztcbn0pO1xuIiwiaW1wb3J0IHsgQkVNLCBidWlsZENsYXNzIH0gZnJvbSAnLi9kb20nO1xuXG5jb25zdCBIT1ZFUl9ERUJPVU5DRV9USU1FT1VUID0gMjAwO1xuXG5jb25zdCBSRUdJT05fUE9JTlRfTUFQID0ge1xuICBcItCcLtCa0JjQh9CSXCI6IHsgbGVmdDogNDUzLCB0b3A6IDE3NSB9LFxuICBcItCa0JjQh9CS0KHQrNCa0JBcIjogeyBsZWZ0OiA0NTMsIHRvcDogMTQwIH0sXG4gIFwi0JLQntCb0JjQndCh0KzQmtCQXCI6IHsgbGVmdDogMTUzLCB0b3A6IDEwMCB9LFxuICBcItCb0KzQktCG0JLQodCs0JrQkFwiOiB7IGxlZnQ6IDgzLCB0b3A6IDIwNiB9LFxuICBcItCX0JDQmtCQ0KDQn9CQ0KLQodCs0JrQkFwiOiB7IGxlZnQ6IDQ4LCB0b3A6IDMxMiB9LFxuICBcItCG0JLQkNCd0J4t0KTQoNCQ0J3QmtCG0JLQodCs0JrQkFwiOiB7IGxlZnQ6IDE1MywgdG9wOiAzMTIgfSxcbiAgXCLQp9CV0KDQndCG0JLQldCm0KzQmtCQXCI6IHsgbGVmdDogMjA3LCB0b3A6IDMyOSB9LFxuICBcItCi0JXQoNCd0J7Qn9CG0JvQrNCh0KzQmtCQXCI6IHsgbGVmdDogMTg4LCB0b3A6IDI0MSB9LFxuICBcItCg0IbQktCd0JXQndCh0KzQmtCQXCI6IHsgbGVmdDogMjQxLCB0b3A6IDEwMCB9LFxuICBcItCl0JzQldCb0KzQndCY0KbQrNCa0JBcIjogeyBsZWZ0OiAyNTksIHRvcDogMjA2IH0sXG4gIFwi0JbQmNCi0J7QnNCY0KDQodCs0JrQkFwiOiB7IGxlZnQ6IDM0NywgdG9wOiAxNTMgfSxcbiAgXCLQktCG0J3QndCY0KbQrNCa0JBcIjogeyBsZWZ0OiAzNjUsIHRvcDogMjc3IH0sXG4gIFwi0KfQldCg0JrQkNCh0KzQmtCQXCI6IHsgbGVmdDogNTIzLCB0b3A6IDI0MSB9LFxuICBcItCa0IbQoNCe0JLQntCT0KDQkNCU0KHQrNCa0JBcIjogeyBsZWZ0OiA1NDEsIHRvcDogMzEyIH0sXG4gIFwi0J/QntCb0KLQkNCS0KHQrNCa0JBcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTg4IH0sXG4gIFwi0KfQldCg0J3QhtCT0IbQktCh0KzQmtCQXCI6IHsgbGVmdDogNTQxLCB0b3A6IDY1IH0sXG4gIFwi0KHQo9Cc0KHQrNCa0JBcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTAwIH0sXG4gIFwi0KXQkNCg0JrQhtCS0KHQrNCa0JBcIjogeyBsZWZ0OiA3NzAsIHRvcDogMjA1IH0sXG4gIFwi0JvQo9CT0JDQndCh0KzQmtCQXCI6IHsgbGVmdDogOTExLCB0b3A6IDI1OSB9LFxuICBcItCU0J3QhtCf0KDQntCf0JXQotCg0J7QktCh0KzQmtCQXCI6IHsgbGVmdDogNjgyLCB0b3A6IDMxMSB9LFxuICBcItCU0J7QndCV0KbQrNCa0JBcIjogeyBsZWZ0OiA4NDAsIHRvcDogMzQ3IH0sXG4gIFwi0JfQkNCf0J7QoNCG0JfQrNCa0JBcIjogeyBsZWZ0OiA3NTIsIHRvcDogNDE3IH0sXG4gIFwi0KXQldCg0KHQntCd0KHQrNCa0JBcIjogeyBsZWZ0OiA2MjksIHRvcDogNDUyIH0sXG4gIFwi0JzQmNCa0J7Qm9CQ0IfQktCh0KzQmtCQXCI6IHsgbGVmdDogNTIzLCB0b3A6IDM5OSB9LFxuICBcItCe0JTQldCh0KzQmtCQXCI6IHsgbGVmdDogNDUzLCB0b3A6IDQzNSB9LFxuICBcItCQ0JLQotCe0J3QntCc0J3QkCDQoNCV0KHQn9Cj0JHQm9CG0JrQkCDQmtCg0JjQnFwiOiB7IGxlZnQ6IDY2NCwgdG9wOiA1NTggfSxcbiAgXCLQnC7QodCV0JLQkNCh0KLQntCf0J7Qm9CsXCI6IHsgbGVmdDogNjE0LCB0b3A6IDU4OCB9XG59O1xuXG5jb25zdCBjcmVhdGVQb2ludCA9ICh7IGxlZnQsIHRvcCB9KSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ21hcF9fcG9pbnQnKTtcbiAgbm9kZS5zdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG4gIG5vZGUuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcCBleHRlbmRzIEJFTSB7XG4gIGRhdGEgPSBbXTtcbiAgdGltZW91dCA9IG51bGw7XG5cblxuICBjb25zdHJ1Y3Rvcihub2RlLCBkYXRhKSB7XG4gICAgc3VwZXIoJ21hcCcsIG5vZGUpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLiR0b29sdGlwID0gdGhpcy5lbGVtKCd0b29sdGlwJyk7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlUG9pbnQoUkVHSU9OX1BPSU5UX01BUFtpdGVtLnJlZ2lvbi5uYW1lXSk7XG4gICAgICBwb2ludC5kYXRhc2V0LmluZGV4ID0gaW5kZXg7XG5cbiAgICAgIHBvaW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMsIGZhbHNlKTtcbiAgICAgIHBvaW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcywgZmFsc2UpO1xuXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChwb2ludCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiR0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLiR0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcywgZmFsc2UpO1xuXG4gICAgdGhpcy5lbGVtKCdtYWluJykuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoeyB0YXJnZXQsIHR5cGUgfSkge1xuICAgIGlmICh0eXBlID09PSAnbW91c2VvdmVyJyAmJiB0YXJnZXQuZGF0YXNldC5pbmRleCkge1xuICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS50b3AgPSB0YXJnZXQuc3R5bGUudG9wO1xuICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS5sZWZ0ID0gdGFyZ2V0LnN0eWxlLmxlZnQ7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICAgIHRoaXMuZGVsTW9kKHRoaXMuJHRvb2x0aXAsICd0b29sdGlwJywgJ3Nob3cnKTtcbiAgICAgICAgICB0aGlzLmRlbE1vZCh0aGlzLiRhY3RpdmUsICdwb2ludCcsICdhY3RpdmUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhW3RhcmdldC5kYXRhc2V0LmluZGV4XTtcblxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCAkdG9vbHRpcERhdGEgPSB0aGlzLiR0b29sdGlwLnF1ZXJ5U2VsZWN0b3JBbGwoYCR7YnVpbGRDbGFzcygnbWFwJywgJ3Rvb2x0aXAtZGF0YScpfSBkdGApO1xuXG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLnRvcCA9IHRhcmdldC5zdHlsZS50b3A7XG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLmxlZnQgPSB0YXJnZXQuc3R5bGUubGVmdDtcblxuICAgICAgICAgICAgdGhpcy4kYWN0aXZlICYmIHRoaXMuZGVsTW9kKHRoaXMuJGFjdGl2ZSwgJ3BvaW50JywgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuXG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnF1ZXJ5U2VsZWN0b3IoYnVpbGRDbGFzcygnbWFwJywgJ3Rvb2x0aXAtdGl0bGUnKSkudGV4dENvbnRlbnQgPSBkYXRhLnJlZ2lvbi5uYW1lO1xuICAgICAgICAgICAgdGhpcy4kYWN0aXZlID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAkdG9vbHRpcERhdGFbMF0udGV4dENvbnRlbnQgPSBkYXRhLnN0YXRzLm1zcHM7XG4gICAgICAgICAgICAkdG9vbHRpcERhdGFbMV0udGV4dENvbnRlbnQgPSBkYXRhLnN0YXRzLmRvY3RvcnM7XG4gICAgICAgICAgICAkdG9vbHRpcERhdGFbMl0udGV4dENvbnRlbnQgPSBkYXRhLnN0YXRzLmRlY2xhcmF0aW9ucztcblxuICAgICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kYWN0aXZlLCAncG9pbnQnLCAnYWN0aXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIEhPVkVSX0RFQk9VTkNFX1RJTUVPVVQpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2IHtcbiAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGUudGFyZ2V0LmhyZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvID0gZS50YXJnZXQuaHJlZi5zcGxpdCgnIycpWzFdO1xuICAgICAgY29uc3QgeyB0b3AgfSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRvKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgd2luZG93LnNjcm9sbCh7IHRvcDogKHRvcCArIHdpbmRvdy5zY3JvbGxZKSAtIDUwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfSlcbiAgfVxufSIsImltcG9ydCB7IEJFTSwgYnVpbGRDbGFzcywgc2VsZWN0b3IgfSBmcm9tICcuL2RvbSc7XG5cbmNvbnN0IGNyZWF0ZU1hcmtlciA9IChhY3RpdmUgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ3NsaWRlcicsICdtYXJrZXInKSk7XG4gIGFjdGl2ZSAmJiBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ3NsaWRlcicsICdtYXJrZXInLCAnYWN0aXZlJykpO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgQkVNIHtcbiAgY3VycmVudEluZGV4ID0gMDtcblxuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgc3VwZXIoJ3NsaWRlcicsIG5vZGUpO1xuICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuZWxlbXMoJ3NsaWRlJyk7XG5cbiAgICB0aGlzLiRtYXJrZXJzID0gW107XG5cbiAgICB0aGlzLiRjb250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICB0aGlzLiRjb250cm9sLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IodGhpcy5uYW1lLCAnbWFya2VycycpKTtcblxuICAgIHRoaXMuJHNsaWRlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbWFya2VyID0gY3JlYXRlTWFya2VyKGluZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLiRjb250cm9sLmFwcGVuZENoaWxkKG1hcmtlcik7XG4gICAgICB0aGlzLiRtYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgaWYgKCF0YXJnZXQuY2xvc2VzdChidWlsZENsYXNzKHRoaXMubmFtZSwgJ21hcmtlcicpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvSW5kZXggPSB0aGlzLmdldEluZGV4QnlFbGVtKHRhcmdldCk7XG5cbiAgICAgIGlmICh0b0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsTW9kKHRoaXMuZWxlbSgnbWFya2VyJywgJ2FjdGl2ZScpLCAnbWFya2VyJywgJ2FjdGl2ZScpO1xuICAgICAgdGhpcy5zZXRNb2QodGFyZ2V0LCAnbWFya2VyJywgJ2FjdGl2ZScpO1xuXG4gICAgICB0aGlzLnNsaWRlKHRvSW5kZXgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLiRjb250cm9sKTtcbiAgfVxuXG4gIHNsaWRlKGluZGV4KSB7XG4gICAgY29uc3QgaXNOZXh0ID0gdGhpcy5jdXJyZW50SW5kZXggPCBpbmRleDtcblxuICAgIHRoaXMuJHNsaWRlc1t0aGlzLmN1cnJlbnRJbmRleF0uYW5pbWF0ZShbXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH0sXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtpc05leHQgPyAnLScgOiAnJ30xMDAlKWAgfVxuICAgIF0sIHRoaXMuY29uc3RydWN0b3IuQU5JTUFUSU9OX09QVElPTlMpO1xuXG4gICAgdGhpcy4kc2xpZGVzW2luZGV4XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICcnIDogJy0nfTEwMCUpYCB9LFxuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJyB9XG4gICAgXSwgdGhpcy5jb25zdHJ1Y3Rvci5BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgZ2V0SW5kZXhCeUVsZW0oZWxlbSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgdGhpcy4kbWFya2Vycy5zb21lKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgc3RhdGljIEFOSU1BVElPTl9PUFRJT05TID0ge1xuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgZmlsbDogJ2ZvcndhcmRzJyxcbiAgICBlYXNpbmc6ICdlYXNlLWluLW91dCdcbiAgfVxufSIsImltcG9ydCB7IEJFTSwgc2VsZWN0b3IgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgeyBudW1iZXJGb3JtYXR0aW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IENPTE9SU19NQVAgPSBbXG4gICcjOTBjOGU2JywgJyNiMDk3YzYnLCAnI2RmYjBkMCcsXG4gICcjZTNhYWI4JywgJyNhZmQ1ZTcnLCAnI2M3YjJkNScsXG4gICcjZTljN2RmJywgJyNlY2M3Y2YnLCAnI2YxZWVjOScsXG4gICcjY2VkOGUyJywgJyM1ZGE4OTInLCAnIzUyOTZjZCcsXG4gICcjYTNkN2YyJywgJyNmM2YxYTAnLCAnI2JjZGFkNScsXG4gICcjNzFiN2E4JywgJyM1Y2E5ZGMnLCAnI2RjOTFhMycsXG4gICcjZDg4MTZmJywgJyNlMmEzOTQnLCAnIzc1NjZhYScsXG4gICcjY2FkZmViJywgJyNkZGQyZGYnLCAnI2Y0ZDliNScsXG4gICcjZDM4MWIyJ1xuXTtcblxuY29uc3QgY3JlYXRlTGlzdEl0ZW1Ob2RlID0gKHRpdGxlLCB2YWx1ZSwgY29sb3IpID0+IHtcbiAgY29uc3QgJGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgY29uc3QgJHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGNvbnN0ICR2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICRsaS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKCdkZWNsYXJhdGlvbnMnLCAnbGlzdC1pdGVtJykpO1xuICAkbGkudGV4dENvbnRlbnQgPSB0aXRsZTtcblxuICAkc3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblxuICAkdmFsdWUuY2xhc3NMaXN0LmFkZChzZWxlY3RvcignZGVjbGFyYXRpb25zJywgJ2xpc3QtaXRlbS12YWx1ZScpKTtcbiAgJHZhbHVlLnRleHRDb250ZW50ID0gbnVtYmVyRm9ybWF0dGluZyh2YWx1ZSk7XG5cbiAgJGxpLnByZXBlbmQoJHNwYW4pO1xuICAkbGkuYXBwZW5kKCR2YWx1ZSk7XG5cbiAgcmV0dXJuICRsaTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpc3RpYyBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGRhdGEpIHtcbiAgICBzdXBlcignZGVjbGFyYXRpb25zJywgbm9kZSk7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIHRoaXMuJGNhbnZhcyA9IHRoaXMuZWxlbSgnZ3JhcGgtY2FudmFzJyk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy4kY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjb25zdCB0b3RhbCA9IGRhdGEucmVkdWNlKCh0YXJnZXQsIHsgZGVjbGFyYXRpb25zIH0pID0+IHRhcmdldCArIGRlY2xhcmF0aW9ucywgMCk7XG5cbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IGEuZGVjbGFyYXRpb25zIDwgYi5kZWNsYXJhdGlvbnMgPyAxIDogLTEpO1xuXG4gICAgbGV0IFt4LCB5LCByLCBzXSA9IFs0OTAsIDQ5MCwgNDgwLCAwXTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0ICRpdGVtID0gY3JlYXRlTGlzdEl0ZW1Ob2RlKFxuICAgICAgICBpdGVtLnJlZ2lvbl9uYW1lLFxuICAgICAgICBpdGVtLmRlY2xhcmF0aW9ucyxcbiAgICAgICAgQ09MT1JTX01BUFtpbmRleF1cbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCRpdGVtKTtcblxuICAgICAgbGV0IHJhZGlhbnMgPSAoKGl0ZW0uZGVjbGFyYXRpb25zIC8gZGF0YVswXS5kZWNsYXJhdGlvbnMpICogMzYwKSAqIChNYXRoLlBJIC8gMzYwKTtcblxuICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDY7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBDT0xPUlNfTUFQW2luZGV4XTtcbiAgICAgIHRoaXMuY29udGV4dC5hcmMoeCwgeSwgciAtICgyMCAqIGluZGV4KSwgcywgcmFkaWFucywgZmFsc2UpO1xuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbGVtKCdsaXN0JykuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIHRoaXMuZWxlbSgndG90YWwtdmFsdWUnKS50ZXh0Q29udGVudCA9IG51bWJlckZvcm1hdHRpbmcodG90YWwpO1xuICB9XG59IiwiaW1wb3J0IHsgJCwgQkVNLCBidWlsZENsYXNzLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgUEFORUxfQU5JTUFUSU9OX09QVElPTlMgPSB7XG4gIGR1cmF0aW9uOiAzMDAsXG4gIGZpbGw6ICdmb3J3YXJkcycsXG4gIGVhc2luZzogJ2Vhc2UtaW4tb3V0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIHsgYXV0b0hlaWdodCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKCd0YWJzJywgbm9kZSk7XG5cbiAgICB0aGlzLiRjb250cm9scyA9IHRoaXMuZWxlbXMoJ25hdi1pdGVtJyk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy5lbGVtcygnc2xpZGUnKTtcblxuICAgIHRoaXMuJG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuJG1hcmtlci5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKHRoaXMubmFtZSwgJ21hcmtlcicpKTtcbiAgICB0aGlzLmVsZW0oJ2hlYWRlcicpLmFwcGVuZENoaWxkKHRoaXMuJG1hcmtlcik7XG5cbiAgICBpZiAoYXV0b0hlaWdodCkge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy4kc2xpZGVzLnJlZHVjZSgodGFyZ2V0LCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmNsaWVudEhlaWdodCA+IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGl0ZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0sIDApO1xuXG4gICAgICB0aGlzLmVsZW0oJ21haW4nKS5zdHlsZS5oZWlnaHQgPSBgJHttYXhIZWlnaHR9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSh0aGlzLmVsZW0oJ25hdi1pdGVtJywgJ2FjdGl2ZScpKTtcblxuICAgIHRoaXMuZWxlbSgnbmF2JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3QgJGVsZW0gPSBlLnRhcmdldC5jbG9zZXN0KGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCAnbmF2LWl0ZW0nKSk7XG5cbiAgICAgIGlmICghJGVsZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b0luZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSgkZWxlbSk7XG5cbiAgICAgIGlmICh0b0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsTW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdhY3RpdmUnKTtcbiAgICAgIHRoaXMuc2V0TW9kKCRlbGVtLCAnbmF2LWl0ZW0nLCAnYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuYW5pbWF0ZVBhbmVscyh0b0luZGV4KTtcbiAgICAgIHRoaXMuYW5pbWF0ZU1hcmtlcih0b0luZGV4KTtcblxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB0b0luZGV4O1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuc2V0TW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdtYXJrZXInKTtcbiAgfVxuXG4gIGFuaW1hdGVQYW5lbHMoaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgY29uc3QgaXNOZXh0ID0gY3VycmVudCA8IGluZGV4O1xuXG4gICAgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkgJiYgdGhpcy4kc2xpZGVzW2N1cnJlbnRdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJy0nIDogJyd9MTAwJSlgLCBvcGFjaXR5OiAwIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLiRzbGlkZXNbaW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJycgOiAnLSd9MTAwJSlgLCBvcGFjaXR5OiAwIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvcGFjaXR5OiAxIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG4gIH1cblxuICBhbmltYXRlTWFya2VyKGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5vZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5jbGllbnRXaWR0aFxuICAgIH07XG5cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy4kY29udHJvbHNbaW5kZXhdLm9mZnNldExlZnQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLiRjb250cm9sc1tpbmRleF0uY2xpZW50V2lkdGg7XG5cbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLiRtYXJrZXIuYW5pbWF0ZShbXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtjdXJyZW50LmxlZnR9cHgpYCxcbiAgICAgICAgd2lkdGg6IGAke2N1cnJlbnQud2lkdGh9cHhgXG4gICAgICB9LCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KWAsXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGBcbiAgICAgIH1cbiAgICBdLCB7Li4uUEFORUxfQU5JTUFUSU9OX09QVElPTlMgfSk7XG5cbiAgICBwbGF5ZXIub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldE1vZCh0aGlzLiRjb250cm9sc1tpbmRleF0sICduYXYtaXRlbScsICdtYXJrZXInKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBwbGF5ZXIuY2FuY2VsKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLmRlbE1vZCh0aGlzLiRjb250cm9sc1t0aGlzLmN1cnJlbnRJbmRleF0sICduYXYtaXRlbScsICdtYXJrZXInKVxuICB9XG5cbiAgZ2V0SW5kZXhCeUVsZW0oZWxlbSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgdGhpcy4kY29udHJvbHMuc29tZSgobm9kZSwgaSkgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxufSIsImNvbnN0IG9iamVjdFRvUXVlcnkgPSAodGFyZ2V0KSA9PiAoXG4gICc/JyArIE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKChhcnIsIGtleSkgPT4gKFxuICAgIGFyci5wdXNoKGAke2tleX09JHt0YXJnZXRba2V5XX1gKSAmJiBhcnJcbiAgKSwgW10pLmpvaW4oJyYnKVxuKTtcblxuZXhwb3J0IGNvbnN0IG51bWJlckZvcm1hdHRpbmcgPSBudW1iZXIgPT4gKFxuICBudW1iZXIudG9GaXhlZCgyKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pK1xcLikvZywgJyQxICcpLnNwbGl0KCcuJylbMF1cbik7XG5cbmV4cG9ydCBjb25zdCBmZXRjaEpTT04gPSAodXJsLCBvcHRpb25zID0geyBtZXRob2Q6ICdHRVQnIH0pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGlmIChvcHRpb25zLmJvZHkgJiYgb3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgdXJsICs9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5ib2R5KTtcbiAgfVxuXG4gIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlKEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgfTtcblxuICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XG4gIHJlcXVlc3Qub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKTtcbiAgcmVxdWVzdC5zZW5kKG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSkgOiBudWxsKTtcbn0pOyJdfQ==
