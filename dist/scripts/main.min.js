(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @namespace Chart
 */
var Chart = require('./core/core.js')();

require('./core/core.helpers')(Chart);
require('./platforms/platform.js')(Chart);
require('./core/core.canvasHelpers')(Chart);
require('./core/core.element')(Chart);
require('./core/core.plugin.js')(Chart);
require('./core/core.animation')(Chart);
require('./core/core.controller')(Chart);
require('./core/core.datasetController')(Chart);
require('./core/core.layoutService')(Chart);
require('./core/core.scaleService')(Chart);
require('./core/core.ticks.js')(Chart);
require('./core/core.scale')(Chart);
require('./core/core.interaction')(Chart);
require('./core/core.tooltip')(Chart);

require('./elements/element.arc')(Chart);
require('./elements/element.line')(Chart);
require('./elements/element.point')(Chart);
require('./elements/element.rectangle')(Chart);

require('./scales/scale.linearbase.js')(Chart);
require('./scales/scale.category')(Chart);
require('./scales/scale.linear')(Chart);
require('./scales/scale.logarithmic')(Chart);
require('./scales/scale.radialLinear')(Chart);
require('./scales/scale.time')(Chart);

// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
require('./controllers/controller.bar')(Chart);
require('./controllers/controller.bubble')(Chart);
require('./controllers/controller.doughnut')(Chart);
require('./controllers/controller.line')(Chart);
require('./controllers/controller.polarArea')(Chart);
require('./controllers/controller.radar')(Chart);

require('./charts/Chart.Bar')(Chart);
require('./charts/Chart.Bubble')(Chart);
require('./charts/Chart.Doughnut')(Chart);
require('./charts/Chart.Line')(Chart);
require('./charts/Chart.PolarArea')(Chart);
require('./charts/Chart.Radar')(Chart);
require('./charts/Chart.Scatter')(Chart);

// Loading built-it plugins
var plugins = [];

plugins.push(
    require('./plugins/plugin.filler.js')(Chart),
    require('./plugins/plugin.legend.js')(Chart),
    require('./plugins/plugin.title.js')(Chart)
);

Chart.plugins.register(plugins);

module.exports = Chart;
if (typeof window !== 'undefined') {
	window.Chart = Chart;
}

},{"./charts/Chart.Bar":2,"./charts/Chart.Bubble":3,"./charts/Chart.Doughnut":4,"./charts/Chart.Line":5,"./charts/Chart.PolarArea":6,"./charts/Chart.Radar":7,"./charts/Chart.Scatter":8,"./controllers/controller.bar":9,"./controllers/controller.bubble":10,"./controllers/controller.doughnut":11,"./controllers/controller.line":12,"./controllers/controller.polarArea":13,"./controllers/controller.radar":14,"./core/core.animation":15,"./core/core.canvasHelpers":16,"./core/core.controller":17,"./core/core.datasetController":18,"./core/core.element":19,"./core/core.helpers":20,"./core/core.interaction":21,"./core/core.js":22,"./core/core.layoutService":23,"./core/core.plugin.js":24,"./core/core.scale":25,"./core/core.scaleService":26,"./core/core.ticks.js":27,"./core/core.tooltip":28,"./elements/element.arc":29,"./elements/element.line":30,"./elements/element.point":31,"./elements/element.rectangle":32,"./platforms/platform.js":34,"./plugins/plugin.filler.js":35,"./plugins/plugin.legend.js":36,"./plugins/plugin.title.js":37,"./scales/scale.category":38,"./scales/scale.linear":39,"./scales/scale.linearbase.js":40,"./scales/scale.logarithmic":41,"./scales/scale.radialLinear":42,"./scales/scale.time":43}],2:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.Bar = function(context, config) {
		config.type = 'bar';

		return new Chart(context, config);
	};

};

},{}],3:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.Bubble = function(context, config) {
		config.type = 'bubble';
		return new Chart(context, config);
	};

};

},{}],4:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.Doughnut = function(context, config) {
		config.type = 'doughnut';

		return new Chart(context, config);
	};

};

},{}],5:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.Line = function(context, config) {
		config.type = 'line';

		return new Chart(context, config);
	};

};

},{}],6:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.PolarArea = function(context, config) {
		config.type = 'polarArea';

		return new Chart(context, config);
	};

};

},{}],7:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	Chart.Radar = function(context, config) {
		config.type = 'radar';

		return new Chart(context, config);
	};

};

},{}],8:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var defaultConfig = {
		hover: {
			mode: 'single'
		},

		scales: {
			xAxes: [{
				type: 'linear', // scatter should not use a category axis
				position: 'bottom',
				id: 'x-axis-1' // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: 'linear',
				position: 'left',
				id: 'y-axis-1'
			}]
		},

		tooltips: {
			callbacks: {
				title: function() {
					// Title doesn't make sense for scatter since we format the data as a point
					return '';
				},
				label: function(tooltipItem) {
					return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';
				}
			}
		}
	};

	// Register the default config for this type
	Chart.defaults.scatter = defaultConfig;

	// Scatter charts use line controllers
	Chart.controllers.scatter = Chart.controllers.line;

	Chart.Scatter = function(context, config) {
		config.type = 'scatter';
		return new Chart(context, config);
	};

};

},{}],9:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.bar = {
		hover: {
			mode: 'label'
		},

		scales: {
			xAxes: [{
				type: 'category',

				// Specific to Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}],
			yAxes: [{
				type: 'linear'
			}]
		}
	};

	Chart.controllers.bar = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Rectangle,

		initialize: function() {
			var me = this;
			var meta;

			Chart.DatasetController.prototype.initialize.apply(me, arguments);

			meta = me.getMeta();
			meta.stack = me.getDataset().stack;
			meta.bar = true;
		},

		update: function(reset) {
			var me = this;
			var elements = me.getMeta().data;
			var i, ilen;

			me._ruler = me.getRuler();

			for (i = 0, ilen = elements.length; i < ilen; ++i) {
				me.updateElement(elements[i], i, reset);
			}
		},

		updateElement: function(rectangle, index, reset) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var dataset = me.getDataset();
			var custom = rectangle.custom || {};
			var rectangleOptions = chart.options.elements.rectangle;

			rectangle._xScale = me.getScaleForId(meta.xAxisID);
			rectangle._yScale = me.getScaleForId(meta.yAxisID);
			rectangle._datasetIndex = me.index;
			rectangle._index = index;

			rectangle._model = {
				datasetLabel: dataset.label,
				label: chart.data.labels[index],
				borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
				backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
				borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
				borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
			};

			me.updateElementGeometry(rectangle, index, reset);

			rectangle.pivot();
		},

		/**
		 * @private
		 */
		updateElementGeometry: function(rectangle, index, reset) {
			var me = this;
			var model = rectangle._model;
			var vscale = me.getValueScale();
			var base = vscale.getBasePixel();
			var horizontal = vscale.isHorizontal();
			var ruler = me._ruler || me.getRuler();
			var vpixels = me.calculateBarValuePixels(me.index, index);
			var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

			model.horizontal = horizontal;
			model.base = reset? base : vpixels.base;
			model.x = horizontal? reset? base : vpixels.head : ipixels.center;
			model.y = horizontal? ipixels.center : reset? base : vpixels.head;
			model.height = horizontal? ipixels.size : undefined;
			model.width = horizontal? undefined : ipixels.size;
		},

		/**
		 * @private
		 */
		getValueScaleId: function() {
			return this.getMeta().yAxisID;
		},

		/**
		 * @private
		 */
		getIndexScaleId: function() {
			return this.getMeta().xAxisID;
		},

		/**
		 * @private
		 */
		getValueScale: function() {
			return this.getScaleForId(this.getValueScaleId());
		},

		/**
		 * @private
		 */
		getIndexScale: function() {
			return this.getScaleForId(this.getIndexScaleId());
		},

		/**
		 * Returns the effective number of stacks based on groups and bar visibility.
		 * @private
		 */
		getStackCount: function(last) {
			var me = this;
			var chart = me.chart;
			var scale = me.getIndexScale();
			var stacked = scale.options.stacked;
			var ilen = last === undefined? chart.data.datasets.length : last + 1;
			var stacks = [];
			var i, meta;

			for (i = 0; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				if (meta.bar && chart.isDatasetVisible(i) &&
					(stacked === false ||
					(stacked === true && stacks.indexOf(meta.stack) === -1) ||
					(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
					stacks.push(meta.stack);
				}
			}

			return stacks.length;
		},

		/**
		 * Returns the stack index for the given dataset based on groups and bar visibility.
		 * @private
		 */
		getStackIndex: function(datasetIndex) {
			return this.getStackCount(datasetIndex) - 1;
		},

		/**
		 * @private
		 */
		getRuler: function() {
			var me = this;
			var scale = me.getIndexScale();
			var options = scale.options;
			var stackCount = me.getStackCount();
			var fullSize = scale.isHorizontal()? scale.width : scale.height;
			var tickSize = fullSize / scale.ticks.length;
			var categorySize = tickSize * options.categoryPercentage;
			var fullBarSize = categorySize / stackCount;
			var barSize = fullBarSize * options.barPercentage;

			barSize = Math.min(
				helpers.getValueOrDefault(options.barThickness, barSize),
				helpers.getValueOrDefault(options.maxBarThickness, Infinity));

			return {
				stackCount: stackCount,
				tickSize: tickSize,
				categorySize: categorySize,
				categorySpacing: tickSize - categorySize,
				fullBarSize: fullBarSize,
				barSize: barSize,
				barSpacing: fullBarSize - barSize,
				scale: scale
			};
		},

		/**
		 * Note: pixel values are not clamped to the scale area.
		 * @private
		 */
		calculateBarValuePixels: function(datasetIndex, index) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var scale = me.getValueScale();
			var datasets = chart.data.datasets;
			var value = Number(datasets[datasetIndex].data[index]);
			var stacked = scale.options.stacked;
			var stack = meta.stack;
			var start = 0;
			var i, imeta, ivalue, base, head, size;

			if (stacked || (stacked === undefined && stack !== undefined)) {
				for (i = 0; i < datasetIndex; ++i) {
					imeta = chart.getDatasetMeta(i);

					if (imeta.bar &&
						imeta.stack === stack &&
						imeta.controller.getValueScaleId() === scale.id &&
						chart.isDatasetVisible(i)) {

						ivalue = Number(datasets[i].data[index]);
						if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
							start += ivalue;
						}
					}
				}
			}

			base = scale.getPixelForValue(start);
			head = scale.getPixelForValue(start + value);
			size = (head - base) / 2;

			return {
				size: size,
				base: base,
				head: head,
				center: head + size / 2
			};
		},

		/**
		 * @private
		 */
		calculateBarIndexPixels: function(datasetIndex, index, ruler) {
			var me = this;
			var scale = ruler.scale;
			var isCombo = me.chart.isCombo;
			var stackIndex = me.getStackIndex(datasetIndex);
			var base = scale.getPixelForValue(null, index, datasetIndex, isCombo);
			var size = ruler.barSize;

			base -= isCombo? ruler.tickSize / 2 : 0;
			base += ruler.fullBarSize * stackIndex;
			base += ruler.categorySpacing / 2;
			base += ruler.barSpacing / 2;

			return {
				size: size,
				base: base,
				head: base + size,
				center: base + size / 2
			};
		},

		draw: function() {
			var me = this;
			var chart = me.chart;
			var elements = me.getMeta().data;
			var dataset = me.getDataset();
			var ilen = elements.length;
			var i = 0;
			var d;

			helpers.canvas.clipArea(chart.ctx, chart.chartArea);

			for (; i<ilen; ++i) {
				d = dataset.data[i];
				if (d !== null && d !== undefined && !isNaN(d)) {
					elements[i].draw();
				}
			}

			helpers.canvas.unclipArea(chart.ctx);
		},

		setHoverStyle: function(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
			var custom = rectangle.custom || {};
			var model = rectangle._model;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
			var custom = rectangle.custom || {};
			var model = rectangle._model;
			var rectangleElementOptions = this.chart.options.elements.rectangle;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
		}
	});


	// including horizontalBar in the bar file, instead of a file of its own
	// it extends bar (like pie extends doughnut)
	Chart.defaults.horizontalBar = {
		hover: {
			mode: 'label'
		},

		scales: {
			xAxes: [{
				type: 'linear',
				position: 'bottom'
			}],
			yAxes: [{
				position: 'left',
				type: 'category',

				// Specific to Horizontal Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}]
		},
		elements: {
			rectangle: {
				borderSkipped: 'left'
			}
		},
		tooltips: {
			callbacks: {
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title = '';

					if (tooltipItems.length > 0) {
						if (tooltipItems[0].yLabel) {
							title = tooltipItems[0].yLabel;
						} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {
							title = data.labels[tooltipItems[0].index];
						}
					}

					return title;
				},
				label: function(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
					return datasetLabel + ': ' + tooltipItem.xLabel;
				}
			}
		}
	};

	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
		/**
		 * @private
		 */
		getValueScaleId: function() {
			return this.getMeta().xAxisID;
		},

		/**
		 * @private
		 */
		getIndexScaleId: function() {
			return this.getMeta().yAxisID;
		}
	});
};

},{}],10:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.bubble = {
		hover: {
			mode: 'single'
		},

		scales: {
			xAxes: [{
				type: 'linear', // bubble should probably use a linear scale by default
				position: 'bottom',
				id: 'x-axis-0' // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: 'linear',
				position: 'left',
				id: 'y-axis-0'
			}]
		},

		tooltips: {
			callbacks: {
				title: function() {
					// Title doesn't make sense for scatter since we format the data as a point
					return '';
				},
				label: function(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
					var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
					return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';
				}
			}
		}
	};

	Chart.controllers.bubble = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Point,

		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data;

			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			});
		},

		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);

			var custom = point.custom || {};
			var dataset = me.getDataset();
			var data = dataset.data[index];
			var pointElementOptions = me.chart.options.elements.point;
			var dsIndex = me.index;

			helpers.extend(point, {
				// Utility
				_xScale: xScale,
				_yScale: yScale,
				_datasetIndex: dsIndex,
				_index: index,

				// Desired view properties
				_model: {
					x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),
					y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
					// Appearance
					radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),

					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
				}
			});

			// Trick to reset the styles of the point
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);

			var model = point._model;
			model.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));

			point.pivot();
		},

		getRadius: function(value) {
			return value.r || this.chart.options.elements.point.radius;
		},

		setHoverStyle: function(point) {
			var me = this;
			Chart.DatasetController.prototype.setHoverStyle.call(me, point);

			// Radius
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;
			model.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);
		},

		removeHoverStyle: function(point) {
			var me = this;
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);

			var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
			var custom = point.custom || {};
			var model = point._model;

			model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);
		}
	});
};

},{}],11:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers,
		defaults = Chart.defaults;

	defaults.doughnut = {
		animation: {
			// Boolean - Whether we animate the rotation of the Doughnut
			animateRotate: true,
			// Boolean - Whether we animate scaling the Doughnut from the centre
			animateScale: false
		},
		aspectRatio: 1,
		hover: {
			mode: 'single'
		},
		legendCallback: function(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i < datasets[0].data.length; ++i) {
					text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</li>');
				}
			}

			text.push('</ul>');
			return text.join('');
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length && data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc && arc.custom || {};
							var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					// toggle visibility of index if exists
					if (meta.data[index]) {
						meta.data[index].hidden = !meta.data[index].hidden;
					}
				}

				chart.update();
			}
		},

		// The percentage of the chart that we cut out of the middle.
		cutoutPercentage: 50,

		// The rotation of the chart, where the first data arc begins.
		rotation: Math.PI * -0.5,

		// The total circumference of the chart.
		circumference: Math.PI * 2.0,

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return '';
				},
				label: function(tooltipItem, data) {
					var dataLabel = data.labels[tooltipItem.index];
					var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

					if (helpers.isArray(dataLabel)) {
						// show value on first line of multiline label
						// need to clone because we are changing the value
						dataLabel = dataLabel.slice();
						dataLabel[0] += value;
					} else {
						dataLabel += value;
					}

					return dataLabel;
				}
			}
		}
	};

	defaults.pie = helpers.clone(defaults.doughnut);
	helpers.extend(defaults.pie, {
		cutoutPercentage: 0
	});


	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Arc,

		linkScales: helpers.noop,

		// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
		getRingIndex: function(datasetIndex) {
			var ringIndex = 0;

			for (var j = 0; j < datasetIndex; ++j) {
				if (this.chart.isDatasetVisible(j)) {
					++ringIndex;
				}
			}

			return ringIndex;
		},

		update: function(reset) {
			var me = this;
			var chart = me.chart,
				chartArea = chart.chartArea,
				opts = chart.options,
				arcOpts = opts.elements.arc,
				availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,
				availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,
				minSize = Math.min(availableWidth, availableHeight),
				offset = {
					x: 0,
					y: 0
				},
				meta = me.getMeta(),
				cutoutPercentage = opts.cutoutPercentage,
				circumference = opts.circumference;

			// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
			if (circumference < Math.PI * 2.0) {
				var startAngle = opts.rotation % (Math.PI * 2.0);
				startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
				var endAngle = startAngle + circumference;
				var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
				var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
				var contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
				var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
				var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
				var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
				var cutout = cutoutPercentage / 100.0;
				var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
				var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
				var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
				minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
				offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
			}

			chart.borderWidth = me.getMaxBorderWidth(meta.data);
			chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
			chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
			chart.offsetX = offset.x * chart.outerRadius;
			chart.offsetY = offset.y * chart.outerRadius;

			meta.total = me.calculateTotal();

			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
			me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart,
				chartArea = chart.chartArea,
				opts = chart.options,
				animationOpts = opts.animation,
				centerX = (chartArea.left + chartArea.right) / 2,
				centerY = (chartArea.top + chartArea.bottom) / 2,
				startAngle = opts.rotation, // non reset case handled later
				endAngle = opts.rotation, // non reset case handled later
				dataset = me.getDataset(),
				circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
				innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,
				outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,
				valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,

				// Desired view properties
				_model: {
					x: centerX + chart.offsetX,
					y: centerY + chart.offsetY,
					startAngle: startAngle,
					endAngle: endAngle,
					circumference: circumference,
					outerRadius: outerRadius,
					innerRadius: innerRadius,
					label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
				}
			});

			var model = arc._model;
			// Resets the visual styles
			this.removeHoverStyle(arc);

			// Set correct angles if not resetting
			if (!reset || !animationOpts.animateRotate) {
				if (index === 0) {
					model.startAngle = opts.rotation;
				} else {
					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
				}

				model.endAngle = model.startAngle + model.circumference;
			}

			arc.pivot();
		},

		removeHoverStyle: function(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		calculateTotal: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var total = 0;
			var value;

			helpers.each(meta.data, function(element, index) {
				value = dataset.data[index];
				if (!isNaN(value) && !element.hidden) {
					total += Math.abs(value);
				}
			});

			/* if (total === 0) {
				total = NaN;
			}*/

			return total;
		},

		calculateCircumference: function(value) {
			var total = this.getMeta().total;
			if (total > 0 && !isNaN(value)) {
				return (Math.PI * 2.0) * (value / total);
			}
			return 0;
		},

		// gets the max border or hover width to properly scale pie charts
		getMaxBorderWidth: function(elements) {
			var max = 0,
				index = this.index,
				length = elements.length,
				borderWidth,
				hoverWidth;

			for (var i = 0; i < length; i++) {
				borderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;
				hoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

				max = borderWidth > max ? borderWidth : max;
				max = hoverWidth > max ? hoverWidth : max;
			}
			return max;
		}
	});
};

},{}],12:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.line = {
		showLines: true,
		spanGaps: false,

		hover: {
			mode: 'label'
		},

		scales: {
			xAxes: [{
				type: 'category',
				id: 'x-axis-0'
			}],
			yAxes: [{
				type: 'linear',
				id: 'y-axis-0'
			}]
		}
	};

	function lineEnabled(dataset, options) {
		return helpers.getValueOrDefault(dataset.showLine, options.showLines);
	}

	Chart.controllers.line = Chart.DatasetController.extend({

		datasetElementType: Chart.elements.Line,

		dataElementType: Chart.elements.Point,

		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data || [];
			var options = me.chart.options;
			var lineElementOptions = options.elements.line;
			var scale = me.getScaleForId(meta.yAxisID);
			var i, ilen, custom;
			var dataset = me.getDataset();
			var showLine = lineEnabled(dataset, options);

			// Update Line
			if (showLine) {
				custom = line.custom || {};

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}

				// Utility
				line._scale = scale;
				line._datasetIndex = me.index;
				// Data
				line._children = points;
				// Model
				line._model = {
					// Appearance
					// The default behavior of lines is to break at null values, according
					// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
					// This option gives lines the ability to span gaps
					spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
					cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
				};

				line.pivot();
			}

			// Update Points
			for (i=0, ilen=points.length; i<ilen; ++i) {
				me.updateElement(points[i], i, reset);
			}

			if (showLine && line._model.tension !== 0) {
				me.updateBezierControlPoints();
			}

			// Now pivot the point for animation
			for (i=0, ilen=points.length; i<ilen; ++i) {
				points[i].pivot();
			}
		},

		getPointBackgroundColor: function(point, index) {
			var backgroundColor = this.chart.options.elements.point.backgroundColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.backgroundColor) {
				backgroundColor = custom.backgroundColor;
			} else if (dataset.pointBackgroundColor) {
				backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
			} else if (dataset.backgroundColor) {
				backgroundColor = dataset.backgroundColor;
			}

			return backgroundColor;
		},

		getPointBorderColor: function(point, index) {
			var borderColor = this.chart.options.elements.point.borderColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.borderColor) {
				borderColor = custom.borderColor;
			} else if (dataset.pointBorderColor) {
				borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
			} else if (dataset.borderColor) {
				borderColor = dataset.borderColor;
			}

			return borderColor;
		},

		getPointBorderWidth: function(point, index) {
			var borderWidth = this.chart.options.elements.point.borderWidth;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (!isNaN(custom.borderWidth)) {
				borderWidth = custom.borderWidth;
			} else if (!isNaN(dataset.pointBorderWidth)) {
				borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
			} else if (!isNaN(dataset.borderWidth)) {
				borderWidth = dataset.borderWidth;
			}

			return borderWidth;
		},

		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var datasetIndex = me.index;
			var value = dataset.data[index];
			var yScale = me.getScaleForId(meta.yAxisID);
			var xScale = me.getScaleForId(meta.xAxisID);
			var pointOptions = me.chart.options.elements.point;
			var x, y;
			var labels = me.chart.data.labels || [];
			var includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);
			y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

			// Utility
			point._xScale = xScale;
			point._yScale = yScale;
			point._datasetIndex = datasetIndex;
			point._index = index;

			// Desired view properties
			point._model = {
				x: x,
				y: y,
				skip: custom.skip || isNaN(x) || isNaN(y),
				// Appearance
				radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
				pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
				backgroundColor: me.getPointBackgroundColor(point, index),
				borderColor: me.getPointBorderColor(point, index),
				borderWidth: me.getPointBorderWidth(point, index),
				tension: meta.dataset._model ? meta.dataset._model.tension : 0,
				steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
				// Tooltip
				hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
			};
		},

		calculatePointY: function(value, index, datasetIndex) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var sumPos = 0;
			var sumNeg = 0;
			var i, ds, dsMeta;

			if (yScale.options.stacked) {
				for (i = 0; i < datasetIndex; i++) {
					ds = chart.data.datasets[i];
					dsMeta = chart.getDatasetMeta(i);
					if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
						var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
						if (stackedRightValue < 0) {
							sumNeg += stackedRightValue || 0;
						} else {
							sumPos += stackedRightValue || 0;
						}
					}
				}

				var rightValue = Number(yScale.getRightValue(value));
				if (rightValue < 0) {
					return yScale.getPixelForValue(sumNeg + rightValue);
				}
				return yScale.getPixelForValue(sumPos + rightValue);
			}

			return yScale.getPixelForValue(value);
		},

		updateBezierControlPoints: function() {
			var me = this;
			var meta = me.getMeta();
			var area = me.chart.chartArea;
			var points = (meta.data || []);
			var i, ilen, point, model, controlPoints;

			// Only consider points that are drawn in case the spanGaps option is used
			if (meta.dataset._model.spanGaps) {
				points = points.filter(function(pt) {
					return !pt._model.skip;
				});
			}

			function capControlPoint(pt, min, max) {
				return Math.max(Math.min(pt, max), min);
			}

			if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
				helpers.splineCurveMonotone(points);
			} else {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					point = points[i];
					model = point._model;
					controlPoints = helpers.splineCurve(
						helpers.previousItem(points, i)._model,
						model,
						helpers.nextItem(points, i)._model,
						meta.dataset._model.tension
					);
					model.controlPointPreviousX = controlPoints.previous.x;
					model.controlPointPreviousY = controlPoints.previous.y;
					model.controlPointNextX = controlPoints.next.x;
					model.controlPointNextY = controlPoints.next.y;
				}
			}

			if (me.chart.options.elements.line.capBezierPoints) {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					model = points[i]._model;
					model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
					model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
					model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
					model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
				}
			}
		},

		draw: function() {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var points = meta.data || [];
			var area = chart.chartArea;
			var ilen = points.length;
			var i = 0;

			Chart.canvasHelpers.clipArea(chart.ctx, area);

			if (lineEnabled(me.getDataset(), chart.options)) {
				meta.dataset.draw();
			}

			Chart.canvasHelpers.unclipArea(chart.ctx);

			// Draw the points
			for (; i<ilen; ++i) {
				points[i].draw(area);
			}
		},

		setHoverStyle: function(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;

			model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function(point) {
			var me = this;
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}

			model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
			model.backgroundColor = me.getPointBackgroundColor(point, index);
			model.borderColor = me.getPointBorderColor(point, index);
			model.borderWidth = me.getPointBorderWidth(point, index);
		}
	});
};

},{}],13:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.polarArea = {

		scale: {
			type: 'radialLinear',
			angleLines: {
				display: false
			},
			gridLines: {
				circular: true
			},
			pointLabels: {
				display: false
			},
			ticks: {
				beginAtZero: true
			}
		},

		// Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},

		startAngle: -0.5 * Math.PI,
		aspectRatio: 1,
		legendCallback: function(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i < datasets[0].data.length; ++i) {
					text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</li>');
				}
			}

			text.push('</ul>');
			return text.join('');
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length && data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}

				chart.update();
			}
		},

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return '';
				},
				label: function(tooltipItem, data) {
					return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;
				}
			}
		}
	};

	Chart.controllers.polarArea = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Arc,

		linkScales: helpers.noop,

		update: function(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var meta = me.getMeta();
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
			me.innerRadius = me.outerRadius - chart.radiusLength;

			meta.count = me.countVisibleElements();

			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var dataset = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var scale = chart.scale;
			var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
			var labels = chart.data.labels;

			var circumference = me.calculateCircumference(dataset.data[index]);
			var centerX = scale.xCenter;
			var centerY = scale.yCenter;

			// If there is NaN data before us, we need to calculate the starting angle correctly.
			// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
			var visibleCount = 0;
			var meta = me.getMeta();
			for (var i = 0; i < index; ++i) {
				if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
					++visibleCount;
				}
			}

			// var negHalfPI = -0.5 * Math.PI;
			var datasetStartAngle = opts.startAngle;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			var startAngle = datasetStartAngle + (circumference * visibleCount);
			var endAngle = startAngle + (arc.hidden ? 0 : circumference);

			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: centerX,
					y: centerY,
					innerRadius: 0,
					outerRadius: reset ? resetRadius : distance,
					startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
					endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
					label: getValueAtIndexOrDefault(labels, index, labels[index])
				}
			});

			// Apply border and fill style
			me.removeHoverStyle(arc);

			arc.pivot();
		},

		removeHoverStyle: function(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		countVisibleElements: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var count = 0;

			helpers.each(meta.data, function(element, index) {
				if (!isNaN(dataset.data[index]) && !element.hidden) {
					count++;
				}
			});

			return count;
		},

		calculateCircumference: function(value) {
			var count = this.getMeta().count;
			if (count > 0 && !isNaN(value)) {
				return (2 * Math.PI) / count;
			}
			return 0;
		}
	});
};

},{}],14:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.radar = {
		aspectRatio: 1,
		scale: {
			type: 'radialLinear'
		},
		elements: {
			line: {
				tension: 0 // no bezier in radar
			}
		}
	};

	Chart.controllers.radar = Chart.DatasetController.extend({

		datasetElementType: Chart.elements.Line,

		dataElementType: Chart.elements.Point,

		linkScales: helpers.noop,

		update: function(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data;
			var custom = line.custom || {};
			var dataset = me.getDataset();
			var lineElementOptions = me.chart.options.elements.line;
			var scale = me.chart.scale;

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
				dataset.lineTension = dataset.tension;
			}

			helpers.extend(meta.dataset, {
				// Utility
				_datasetIndex: me.index,
				_scale: scale,
				// Data
				_children: points,
				_loop: true,
				// Model
				_model: {
					// Appearance
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
				}
			});

			meta.dataset.pivot();

			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			}, me);

			// Update bezier control points
			me.updateBezierControlPoints();
		},
		updateElement: function(point, index, reset) {
			var me = this;
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var scale = me.chart.scale;
			var pointElementOptions = me.chart.options.elements.point;
			var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
			if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			helpers.extend(point, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
					y: reset ? scale.yCenter : pointPosition.y,

					// Appearance
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
					radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
				}
			});

			point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
		},
		updateBezierControlPoints: function() {
			var chartArea = this.chart.chartArea;
			var meta = this.getMeta();

			helpers.each(meta.data, function(point, index) {
				var model = point._model;
				var controlPoints = helpers.splineCurve(
					helpers.previousItem(meta.data, index, true)._model,
					model,
					helpers.nextItem(meta.data, index, true)._model,
					model.tension
				);

				// Prevent the bezier going outside of the bounds of the graph
				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

				// Now pivot the point for animation
				point.pivot();
			});
		},

		setHoverStyle: function(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;

			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function(point) {
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;
			var pointElementOptions = this.chart.options.elements.point;

			model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
		}
	});
};

},{}],15:[function(require,module,exports){
/* global window: false */
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.global.animation = {
		duration: 1000,
		easing: 'easeOutQuart',
		onProgress: helpers.noop,
		onComplete: helpers.noop
	};

	Chart.Animation = Chart.Element.extend({
		chart: null, // the animation associated chart instance
		currentStep: 0, // the current animation step
		numSteps: 60, // default number of steps
		easing: '', // the easing to use for this animation
		render: null, // render function used by the animation service

		onAnimationProgress: null, // user specified callback to fire on each step of the animation
		onAnimationComplete: null, // user specified callback to fire when the animation finishes
	});

	Chart.animationService = {
		frameDuration: 17,
		animations: [],
		dropFrames: 0,
		request: null,

		/**
		 * @param {Chart} chart - The chart to animate.
		 * @param {Chart.Animation} animation - The animation that we will animate.
		 * @param {Number} duration - The animation duration in ms.
		 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
		 */
		addAnimation: function(chart, animation, duration, lazy) {
			var animations = this.animations;
			var i, ilen;

			animation.chart = chart;

			if (!lazy) {
				chart.animating = true;
			}

			for (i=0, ilen=animations.length; i < ilen; ++i) {
				if (animations[i].chart === chart) {
					animations[i] = animation;
					return;
				}
			}

			animations.push(animation);

			// If there are no animations queued, manually kickstart a digest, for lack of a better word
			if (animations.length === 1) {
				this.requestAnimationFrame();
			}
		},

		cancelAnimation: function(chart) {
			var index = helpers.findIndex(this.animations, function(animation) {
				return animation.chart === chart;
			});

			if (index !== -1) {
				this.animations.splice(index, 1);
				chart.animating = false;
			}
		},

		requestAnimationFrame: function() {
			var me = this;
			if (me.request === null) {
				// Skip animation frame requests until the active one is executed.
				// This can happen when processing mouse events, e.g. 'mousemove'
				// and 'mouseout' events will trigger multiple renders.
				me.request = helpers.requestAnimFrame.call(window, function() {
					me.request = null;
					me.startDigest();
				});
			}
		},

		/**
		 * @private
		 */
		startDigest: function() {
			var me = this;
			var startTime = Date.now();
			var framesToDrop = 0;

			if (me.dropFrames > 1) {
				framesToDrop = Math.floor(me.dropFrames);
				me.dropFrames = me.dropFrames % 1;
			}

			me.advance(1 + framesToDrop);

			var endTime = Date.now();

			me.dropFrames += (endTime - startTime) / me.frameDuration;

			// Do we have more stuff to animate?
			if (me.animations.length > 0) {
				me.requestAnimationFrame();
			}
		},

		/**
		 * @private
		 */
		advance: function(count) {
			var animations = this.animations;
			var animation, chart;
			var i = 0;

			while (i < animations.length) {
				animation = animations[i];
				chart = animation.chart;

				animation.currentStep = (animation.currentStep || 0) + count;
				animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

				helpers.callback(animation.render, [chart, animation], chart);
				helpers.callback(animation.onAnimationProgress, [animation], chart);

				if (animation.currentStep >= animation.numSteps) {
					helpers.callback(animation.onAnimationComplete, [animation], chart);
					chart.animating = false;
					animations.splice(i, 1);
				} else {
					++i;
				}
			}
		}
	};

	/**
	 * Provided for backward compatibility, use Chart.Animation instead
	 * @prop Chart.Animation#animationObject
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 */
	Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
		get: function() {
			return this;
		}
	});

	/**
	 * Provided for backward compatibility, use Chart.Animation#chart instead
	 * @prop Chart.Animation#chartInstance
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 */
	Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
		get: function() {
			return this.chart;
		},
		set: function(value) {
			this.chart = value;
		}
	});

};

},{}],16:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {
	// Global Chart canvas helpers object for drawing items to canvas
	var helpers = Chart.canvasHelpers = {};

	helpers.drawPoint = function(ctx, pointStyle, radius, x, y) {
		var type, edgeLength, xOffset, yOffset, height, size;

		if (typeof pointStyle === 'object') {
			type = pointStyle.toString();
			if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
				ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2, pointStyle.width, pointStyle.height);
				return;
			}
		}

		if (isNaN(radius) || radius <= 0) {
			return;
		}

		switch (pointStyle) {
		// Default includes circle
		default:
			ctx.beginPath();
			ctx.arc(x, y, radius, 0, Math.PI * 2);
			ctx.closePath();
			ctx.fill();
			break;
		case 'triangle':
			ctx.beginPath();
			edgeLength = 3 * radius / Math.sqrt(3);
			height = edgeLength * Math.sqrt(3) / 2;
			ctx.moveTo(x - edgeLength / 2, y + height / 3);
			ctx.lineTo(x + edgeLength / 2, y + height / 3);
			ctx.lineTo(x, y - 2 * height / 3);
			ctx.closePath();
			ctx.fill();
			break;
		case 'rect':
			size = 1 / Math.SQRT2 * radius;
			ctx.beginPath();
			ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
			ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
			break;
		case 'rectRounded':
			var offset = radius / Math.SQRT2;
			var leftX = x - offset;
			var topY = y - offset;
			var sideSize = Math.SQRT2 * radius;
			Chart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);
			ctx.fill();
			break;
		case 'rectRot':
			size = 1 / Math.SQRT2 * radius;
			ctx.beginPath();
			ctx.moveTo(x - size, y);
			ctx.lineTo(x, y + size);
			ctx.lineTo(x + size, y);
			ctx.lineTo(x, y - size);
			ctx.closePath();
			ctx.fill();
			break;
		case 'cross':
			ctx.beginPath();
			ctx.moveTo(x, y + radius);
			ctx.lineTo(x, y - radius);
			ctx.moveTo(x - radius, y);
			ctx.lineTo(x + radius, y);
			ctx.closePath();
			break;
		case 'crossRot':
			ctx.beginPath();
			xOffset = Math.cos(Math.PI / 4) * radius;
			yOffset = Math.sin(Math.PI / 4) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x - xOffset, y + yOffset);
			ctx.lineTo(x + xOffset, y - yOffset);
			ctx.closePath();
			break;
		case 'star':
			ctx.beginPath();
			ctx.moveTo(x, y + radius);
			ctx.lineTo(x, y - radius);
			ctx.moveTo(x - radius, y);
			ctx.lineTo(x + radius, y);
			xOffset = Math.cos(Math.PI / 4) * radius;
			yOffset = Math.sin(Math.PI / 4) * radius;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x - xOffset, y + yOffset);
			ctx.lineTo(x + xOffset, y - yOffset);
			ctx.closePath();
			break;
		case 'line':
			ctx.beginPath();
			ctx.moveTo(x - radius, y);
			ctx.lineTo(x + radius, y);
			ctx.closePath();
			break;
		case 'dash':
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x + radius, y);
			ctx.closePath();
			break;
		}

		ctx.stroke();
	};

	helpers.clipArea = function(ctx, clipArea) {
		ctx.save();
		ctx.beginPath();
		ctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);
		ctx.clip();
	};

	helpers.unclipArea = function(ctx) {
		ctx.restore();
	};

	helpers.lineTo = function(ctx, previous, target, flip) {
		if (target.steppedLine) {
			if (target.steppedLine === 'after') {
				ctx.lineTo(previous.x, target.y);
			} else {
				ctx.lineTo(target.x, previous.y);
			}
			ctx.lineTo(target.x, target.y);
			return;
		}

		if (!target.tension) {
			ctx.lineTo(target.x, target.y);
			return;
		}

		ctx.bezierCurveTo(
			flip? previous.controlPointPreviousX : previous.controlPointNextX,
			flip? previous.controlPointPreviousY : previous.controlPointNextY,
			flip? target.controlPointNextX : target.controlPointPreviousX,
			flip? target.controlPointNextY : target.controlPointPreviousY,
			target.x,
			target.y);
	};

	Chart.helpers.canvas = helpers;
};

},{}],17:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var plugins = Chart.plugins;
	var platform = Chart.platform;

	// Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};

	// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	// Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};

	// Controllers available for dataset visualization eg. bar, line, slice, etc.
	Chart.controllers = {};

	/**
	 * Initializes the given config with global and chart default values.
	 */
	function initConfig(config) {
		config = config || {};

		// Do NOT use configMerge() for the data object because this method merges arrays
		// and so would change references to labels and datasets, preventing data updates.
		var data = config.data = config.data || {};
		data.datasets = data.datasets || [];
		data.labels = data.labels || [];

		config.options = helpers.configMerge(
			Chart.defaults.global,
			Chart.defaults[config.type],
			config.options || {});

		return config;
	}

	/**
	 * Updates the config of the chart
	 * @param chart {Chart} chart to update the options for
	 */
	function updateConfig(chart) {
		var newOptions = chart.options;

		// Update Scale(s) with options
		if (newOptions.scale) {
			chart.scale.options = newOptions.scale;
		} else if (newOptions.scales) {
			newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {
				chart.scales[scaleOptions.id].options = scaleOptions;
			});
		}

		// Tooltip
		chart.tooltip._options = newOptions.tooltips;
	}

	function positionIsHorizontal(position) {
		return position === 'top' || position === 'bottom';
	}

	helpers.extend(Chart.prototype, /** @lends Chart */ {
		/**
		 * @private
		 */
		construct: function(item, config) {
			var me = this;

			config = initConfig(config);

			var context = platform.acquireContext(item, config);
			var canvas = context && context.canvas;
			var height = canvas && canvas.height;
			var width = canvas && canvas.width;

			me.id = helpers.uid();
			me.ctx = context;
			me.canvas = canvas;
			me.config = config;
			me.width = width;
			me.height = height;
			me.aspectRatio = height? width / height : null;
			me.options = config.options;
			me._bufferedRender = false;

			/**
			 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
			 * the "instance" still need to be defined since it might be called from plugins.
			 * @prop Chart#chart
			 * @deprecated since version 2.6.0
			 * @todo remove at version 3
			 * @private
			 */
			me.chart = me;
			me.controller = me;  // chart.chart.controller #inception

			// Add the chart instance to the global namespace
			Chart.instances[me.id] = me;

			// Define alias to the config data: `chart.data === chart.config.data`
			Object.defineProperty(me, 'data', {
				get: function() {
					return me.config.data;
				},
				set: function(value) {
					me.config.data = value;
				}
			});

			if (!context || !canvas) {
				// The given item is not a compatible context2d element, let's return before finalizing
				// the chart initialization but after setting basic chart / controller properties that
				// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
				// https://github.com/chartjs/Chart.js/issues/2807
				console.error("Failed to create chart: can't acquire context from the given item");
				return;
			}

			me.initialize();
			me.update();
		},

		/**
		 * @private
		 */
		initialize: function() {
			var me = this;

			// Before init plugin notification
			plugins.notify(me, 'beforeInit');

			helpers.retinaScale(me);

			me.bindEvents();

			if (me.options.responsive) {
				// Initial resize before chart draws (must be silent to preserve initial animations).
				me.resize(true);
			}

			// Make sure scales have IDs and are built before we build any controllers.
			me.ensureScalesHaveIDs();
			me.buildScales();
			me.initToolTip();

			// After init plugin notification
			plugins.notify(me, 'afterInit');

			return me;
		},

		clear: function() {
			helpers.clear(this);
			return this;
		},

		stop: function() {
			// Stops any current animation loop occurring
			Chart.animationService.cancelAnimation(this);
			return this;
		},

		resize: function(silent) {
			var me = this;
			var options = me.options;
			var canvas = me.canvas;
			var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

			// the canvas render width and height will be casted to integers so make sure that
			// the canvas display style uses the same integer values to avoid blurring effect.
			var newWidth = Math.floor(helpers.getMaximumWidth(canvas));
			var newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));

			if (me.width === newWidth && me.height === newHeight) {
				return;
			}

			canvas.width = me.width = newWidth;
			canvas.height = me.height = newHeight;
			canvas.style.width = newWidth + 'px';
			canvas.style.height = newHeight + 'px';

			helpers.retinaScale(me);

			if (!silent) {
				// Notify any plugins about the resize
				var newSize = {width: newWidth, height: newHeight};
				plugins.notify(me, 'resize', [newSize]);

				// Notify of resize
				if (me.options.onResize) {
					me.options.onResize(me, newSize);
				}

				me.stop();
				me.update(me.options.responsiveAnimationDuration);
			}
		},

		ensureScalesHaveIDs: function() {
			var options = this.options;
			var scalesOptions = options.scales || {};
			var scaleOptions = options.scale;

			helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
				xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
			});

			helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
				yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
			});

			if (scaleOptions) {
				scaleOptions.id = scaleOptions.id || 'scale';
			}
		},

		/**
		 * Builds a map of scale ID to scale object for future lookup.
		 */
		buildScales: function() {
			var me = this;
			var options = me.options;
			var scales = me.scales = {};
			var items = [];

			if (options.scales) {
				items = items.concat(
					(options.scales.xAxes || []).map(function(xAxisOptions) {
						return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
					}),
					(options.scales.yAxes || []).map(function(yAxisOptions) {
						return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
					})
				);
			}

			if (options.scale) {
				items.push({
					options: options.scale,
					dtype: 'radialLinear',
					isDefault: true,
					dposition: 'chartArea'
				});
			}

			helpers.each(items, function(item) {
				var scaleOptions = item.options;
				var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);
				var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
				if (!scaleClass) {
					return;
				}

				if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
					scaleOptions.position = item.dposition;
				}

				var scale = new scaleClass({
					id: scaleOptions.id,
					options: scaleOptions,
					ctx: me.ctx,
					chart: me
				});

				scales[scale.id] = scale;

				// TODO(SB): I think we should be able to remove this custom case (options.scale)
				// and consider it as a regular scale part of the "scales"" map only! This would
				// make the logic easier and remove some useless? custom code.
				if (item.isDefault) {
					me.scale = scale;
				}
			});

			Chart.scaleService.addScalesToLayout(this);
		},

		buildOrUpdateControllers: function() {
			var me = this;
			var types = [];
			var newControllers = [];

			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				var meta = me.getDatasetMeta(datasetIndex);
				if (!meta.type) {
					meta.type = dataset.type || me.config.type;
				}

				types.push(meta.type);

				if (meta.controller) {
					meta.controller.updateIndex(datasetIndex);
				} else {
					var ControllerClass = Chart.controllers[meta.type];
					if (ControllerClass === undefined) {
						throw new Error('"' + meta.type + '" is not a chart type.');
					}

					meta.controller = new ControllerClass(me, datasetIndex);
					newControllers.push(meta.controller);
				}
			}, me);

			if (types.length > 1) {
				for (var i = 1; i < types.length; i++) {
					if (types[i] !== types[i - 1]) {
						me.isCombo = true;
						break;
					}
				}
			}

			return newControllers;
		},

		/**
		 * Reset the elements of all datasets
		 * @private
		 */
		resetElements: function() {
			var me = this;
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.reset();
			}, me);
		},

		/**
		* Resets the chart back to it's state before the initial animation
		*/
		reset: function() {
			this.resetElements();
			this.tooltip.initialize();
		},

		update: function(animationDuration, lazy) {
			var me = this;

			updateConfig(me);

			if (plugins.notify(me, 'beforeUpdate') === false) {
				return;
			}

			// In case the entire data object changed
			me.tooltip._data = me.data;

			// Make sure dataset controllers are updated and new controllers are reset
			var newControllers = me.buildOrUpdateControllers();

			// Make sure all dataset controllers have correct meta data counts
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
			}, me);

			me.updateLayout();

			// Can only reset the new controllers after the scales have been updated
			helpers.each(newControllers, function(controller) {
				controller.reset();
			});

			me.updateDatasets();

			// Do this before render so that any plugins that need final scale updates can use it
			plugins.notify(me, 'afterUpdate');

			if (me._bufferedRender) {
				me._bufferedRequest = {
					lazy: lazy,
					duration: animationDuration
				};
			} else {
				me.render(animationDuration, lazy);
			}
		},

		/**
		 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
		 * hook, in which case, plugins will not be called on `afterLayout`.
		 * @private
		 */
		updateLayout: function() {
			var me = this;

			if (plugins.notify(me, 'beforeLayout') === false) {
				return;
			}

			Chart.layoutService.update(this, this.width, this.height);

			/**
			 * Provided for backward compatibility, use `afterLayout` instead.
			 * @method IPlugin#afterScaleUpdate
			 * @deprecated since version 2.5.0
			 * @todo remove at version 3
			 * @private
			 */
			plugins.notify(me, 'afterScaleUpdate');
			plugins.notify(me, 'afterLayout');
		},

		/**
		 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
		 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
		 * @private
		 */
		updateDatasets: function() {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
				return;
			}

			for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				me.updateDataset(i);
			}

			plugins.notify(me, 'afterDatasetsUpdate');
		},

		/**
		 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
		 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
		 * @private
		 */
		updateDataset: function(index) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index
			};

			if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
				return;
			}

			meta.controller.update();

			plugins.notify(me, 'afterDatasetUpdate', [args]);
		},

		render: function(duration, lazy) {
			var me = this;

			if (plugins.notify(me, 'beforeRender') === false) {
				return;
			}

			var animationOptions = me.options.animation;
			var onComplete = function(animation) {
				plugins.notify(me, 'afterRender');
				helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
			};

			if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
				var animation = new Chart.Animation({
					numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
					easing: animationOptions.easing,

					render: function(chart, animationObject) {
						var easingFunction = helpers.easingEffects[animationObject.easing];
						var currentStep = animationObject.currentStep;
						var stepDecimal = currentStep / animationObject.numSteps;

						chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
					},

					onAnimationProgress: animationOptions.onProgress,
					onAnimationComplete: onComplete
				});

				Chart.animationService.addAnimation(me, animation, duration, lazy);
			} else {
				me.draw();

				// See https://github.com/chartjs/Chart.js/issues/3781
				onComplete(new Chart.Animation({numSteps: 0, chart: me}));
			}

			return me;
		},

		draw: function(easingValue) {
			var me = this;

			me.clear();

			if (easingValue === undefined || easingValue === null) {
				easingValue = 1;
			}

			me.transition(easingValue);

			if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
				return;
			}

			// Draw all the scales
			helpers.each(me.boxes, function(box) {
				box.draw(me.chartArea);
			}, me);

			if (me.scale) {
				me.scale.draw();
			}

			me.drawDatasets(easingValue);

			// Finally draw the tooltip
			me.tooltip.draw();

			plugins.notify(me, 'afterDraw', [easingValue]);
		},

		/**
		 * @private
		 */
		transition: function(easingValue) {
			var me = this;

			for (var i=0, ilen=(me.data.datasets || []).length; i<ilen; ++i) {
				if (me.isDatasetVisible(i)) {
					me.getDatasetMeta(i).controller.transition(easingValue);
				}
			}

			me.tooltip.transition(easingValue);
		},

		/**
		 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
		 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
		 * @private
		 */
		drawDatasets: function(easingValue) {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
				return;
			}

			// Draw datasets reversed to support proper line stacking
			for (var i=(me.data.datasets || []).length - 1; i >= 0; --i) {
				if (me.isDatasetVisible(i)) {
					me.drawDataset(i, easingValue);
				}
			}

			plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
		},

		/**
		 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
		 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
		 * @private
		 */
		drawDataset: function(index, easingValue) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index,
				easingValue: easingValue
			};

			if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
				return;
			}

			meta.controller.draw(easingValue);

			plugins.notify(me, 'afterDatasetDraw', [args]);
		},

		// Get the single element that was clicked on
		// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
		getElementAtEvent: function(e) {
			return Chart.Interaction.modes.single(this, e);
		},

		getElementsAtEvent: function(e) {
			return Chart.Interaction.modes.label(this, e, {intersect: true});
		},

		getElementsAtXAxis: function(e) {
			return Chart.Interaction.modes['x-axis'](this, e, {intersect: true});
		},

		getElementsAtEventForMode: function(e, mode, options) {
			var method = Chart.Interaction.modes[mode];
			if (typeof method === 'function') {
				return method(this, e, options);
			}

			return [];
		},

		getDatasetAtEvent: function(e) {
			return Chart.Interaction.modes.dataset(this, e, {intersect: true});
		},

		getDatasetMeta: function(datasetIndex) {
			var me = this;
			var dataset = me.data.datasets[datasetIndex];
			if (!dataset._meta) {
				dataset._meta = {};
			}

			var meta = dataset._meta[me.id];
			if (!meta) {
				meta = dataset._meta[me.id] = {
					type: null,
					data: [],
					dataset: null,
					controller: null,
					hidden: null,			// See isDatasetVisible() comment
					xAxisID: null,
					yAxisID: null
				};
			}

			return meta;
		},

		getVisibleDatasetCount: function() {
			var count = 0;
			for (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {
				if (this.isDatasetVisible(i)) {
					count++;
				}
			}
			return count;
		},

		isDatasetVisible: function(datasetIndex) {
			var meta = this.getDatasetMeta(datasetIndex);

			// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
			// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
			return typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
		},

		generateLegend: function() {
			return this.options.legendCallback(this);
		},

		destroy: function() {
			var me = this;
			var canvas = me.canvas;
			var meta, i, ilen;

			me.stop();

			// dataset controllers need to cleanup associated data
			for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				meta = me.getDatasetMeta(i);
				if (meta.controller) {
					meta.controller.destroy();
					meta.controller = null;
				}
			}

			if (canvas) {
				me.unbindEvents();
				helpers.clear(me);
				platform.releaseContext(me.ctx);
				me.canvas = null;
				me.ctx = null;
			}

			plugins.notify(me, 'destroy');

			delete Chart.instances[me.id];
		},

		toBase64Image: function() {
			return this.canvas.toDataURL.apply(this.canvas, arguments);
		},

		initToolTip: function() {
			var me = this;
			me.tooltip = new Chart.Tooltip({
				_chart: me,
				_chartInstance: me,            // deprecated, backward compatibility
				_data: me.data,
				_options: me.options.tooltips
			}, me);
			me.tooltip.initialize();
		},

		/**
		 * @private
		 */
		bindEvents: function() {
			var me = this;
			var listeners = me._listeners = {};
			var listener = function() {
				me.eventHandler.apply(me, arguments);
			};

			helpers.each(me.options.events, function(type) {
				platform.addEventListener(me, type, listener);
				listeners[type] = listener;
			});

			// Responsiveness is currently based on the use of an iframe, however this method causes
			// performance issues and could be troublesome when used with ad blockers. So make sure
			// that the user is still able to create a chart without iframe when responsive is false.
			// See https://github.com/chartjs/Chart.js/issues/2210
			if (me.options.responsive) {
				listener = function() {
					me.resize();
				};

				platform.addEventListener(me, 'resize', listener);
				listeners.resize = listener;
			}
		},

		/**
		 * @private
		 */
		unbindEvents: function() {
			var me = this;
			var listeners = me._listeners;
			if (!listeners) {
				return;
			}

			delete me._listeners;
			helpers.each(listeners, function(listener, type) {
				platform.removeEventListener(me, type, listener);
			});
		},

		updateHoverStyle: function(elements, mode, enabled) {
			var method = enabled? 'setHoverStyle' : 'removeHoverStyle';
			var element, i, ilen;

			for (i=0, ilen=elements.length; i<ilen; ++i) {
				element = elements[i];
				if (element) {
					this.getDatasetMeta(element._datasetIndex).controller[method](element);
				}
			}
		},

		/**
		 * @private
		 */
		eventHandler: function(e) {
			var me = this;
			var tooltip = me.tooltip;

			if (plugins.notify(me, 'beforeEvent', [e]) === false) {
				return;
			}

			// Buffer any update calls so that renders do not occur
			me._bufferedRender = true;
			me._bufferedRequest = null;

			var changed = me.handleEvent(e);
			changed |= tooltip && tooltip.handleEvent(e);

			plugins.notify(me, 'afterEvent', [e]);

			var bufferedRequest = me._bufferedRequest;
			if (bufferedRequest) {
				// If we have an update that was triggered, we need to do a normal render
				me.render(bufferedRequest.duration, bufferedRequest.lazy);
			} else if (changed && !me.animating) {
				// If entering, leaving, or changing elements, animate the change via pivot
				me.stop();

				// We only need to render at this point. Updating will cause scales to be
				// recomputed generating flicker & using more memory than necessary.
				me.render(me.options.hover.animationDuration, true);
			}

			me._bufferedRender = false;
			me._bufferedRequest = null;

			return me;
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event the event to handle
		 * @return {Boolean} true if the chart needs to re-render
		 */
		handleEvent: function(e) {
			var me = this;
			var options = me.options || {};
			var hoverOptions = options.hover;
			var changed = false;

			me.lastActive = me.lastActive || [];

			// Find Active Elements for hover and tooltips
			if (e.type === 'mouseout') {
				me.active = [];
			} else {
				me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
			}

			// On Hover hook
			if (hoverOptions.onHover) {
				// Need to call with native event here to not break backwards compatibility
				hoverOptions.onHover.call(me, e.native, me.active);
			}

			if (e.type === 'mouseup' || e.type === 'click') {
				if (options.onClick) {
					// Use e.native here for backwards compatibility
					options.onClick.call(me, e.native, me.active);
				}
			}

			// Remove styling for last active (even if it may still be active)
			if (me.lastActive.length) {
				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
			}

			// Built in hover styling
			if (me.active.length && hoverOptions.mode) {
				me.updateHoverStyle(me.active, hoverOptions.mode, true);
			}

			changed = !helpers.arrayEquals(me.active, me.lastActive);

			// Remember Last Actives
			me.lastActive = me.active;

			return changed;
		}
	});

	/**
	 * Provided for backward compatibility, use Chart instead.
	 * @class Chart.Controller
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.Controller = Chart;
};

},{}],18:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

	/**
	 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
	 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
	 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
	 */
	function listenArrayEvents(array, listener) {
		if (array._chartjs) {
			array._chartjs.listeners.push(listener);
			return;
		}

		Object.defineProperty(array, '_chartjs', {
			configurable: true,
			enumerable: false,
			value: {
				listeners: [listener]
			}
		});

		arrayEvents.forEach(function(key) {
			var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
			var base = array[key];

			Object.defineProperty(array, key, {
				configurable: true,
				enumerable: false,
				value: function() {
					var args = Array.prototype.slice.call(arguments);
					var res = base.apply(this, args);

					helpers.each(array._chartjs.listeners, function(object) {
						if (typeof object[method] === 'function') {
							object[method].apply(object, args);
						}
					});

					return res;
				}
			});
		});
	}

	/**
	 * Removes the given array event listener and cleanup extra attached properties (such as
	 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
	 */
	function unlistenArrayEvents(array, listener) {
		var stub = array._chartjs;
		if (!stub) {
			return;
		}

		var listeners = stub.listeners;
		var index = listeners.indexOf(listener);
		if (index !== -1) {
			listeners.splice(index, 1);
		}

		if (listeners.length > 0) {
			return;
		}

		arrayEvents.forEach(function(key) {
			delete array[key];
		});

		delete array._chartjs;
	}

	// Base class for all dataset controllers (line, bar, etc)
	Chart.DatasetController = function(chart, datasetIndex) {
		this.initialize(chart, datasetIndex);
	};

	helpers.extend(Chart.DatasetController.prototype, {

		/**
		 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
		 * @type {Chart.core.element}
		 */
		datasetElementType: null,

		/**
		 * Element type used to generate a meta data (e.g. Chart.element.Point).
		 * @type {Chart.core.element}
		 */
		dataElementType: null,

		initialize: function(chart, datasetIndex) {
			var me = this;
			me.chart = chart;
			me.index = datasetIndex;
			me.linkScales();
			me.addElements();
		},

		updateIndex: function(datasetIndex) {
			this.index = datasetIndex;
		},

		linkScales: function() {
			var me = this;
			var meta = me.getMeta();
			var dataset = me.getDataset();

			if (meta.xAxisID === null) {
				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
			}
			if (meta.yAxisID === null) {
				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
			}
		},

		getDataset: function() {
			return this.chart.data.datasets[this.index];
		},

		getMeta: function() {
			return this.chart.getDatasetMeta(this.index);
		},

		getScaleForId: function(scaleID) {
			return this.chart.scales[scaleID];
		},

		reset: function() {
			this.update(true);
		},

		/**
		 * @private
		 */
		destroy: function() {
			if (this._data) {
				unlistenArrayEvents(this._data, this);
			}
		},

		createMetaDataset: function() {
			var me = this;
			var type = me.datasetElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index
			});
		},

		createMetaData: function(index) {
			var me = this;
			var type = me.dataElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index,
				_index: index
			});
		},

		addElements: function() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data || [];
			var metaData = meta.data;
			var i, ilen;

			for (i=0, ilen=data.length; i<ilen; ++i) {
				metaData[i] = metaData[i] || me.createMetaData(i);
			}

			meta.dataset = meta.dataset || me.createMetaDataset();
		},

		addElementAndReset: function(index) {
			var element = this.createMetaData(index);
			this.getMeta().data.splice(index, 0, element);
			this.updateElement(element, index, true);
		},

		buildOrUpdateElements: function() {
			var me = this;
			var dataset = me.getDataset();
			var data = dataset.data || (dataset.data = []);

			// In order to correctly handle data addition/deletion animation (an thus simulate
			// real-time charts), we need to monitor these data modifications and synchronize
			// the internal meta data accordingly.
			if (me._data !== data) {
				if (me._data) {
					// This case happens when the user replaced the data array instance.
					unlistenArrayEvents(me._data, me);
				}

				listenArrayEvents(data, me);
				me._data = data;
			}

			// Re-sync meta data in case the user replaced the data array or if we missed
			// any updates and so make sure that we handle number of datapoints changing.
			me.resyncElements();
		},

		update: helpers.noop,

		transition: function(easingValue) {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			for (; i<ilen; ++i) {
				elements[i].transition(easingValue);
			}

			if (meta.dataset) {
				meta.dataset.transition(easingValue);
			}
		},

		draw: function() {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			if (meta.dataset) {
				meta.dataset.draw();
			}

			for (; i<ilen; ++i) {
				elements[i].draw();
			}
		},

		removeHoverStyle: function(element, elementOpts) {
			var dataset = this.chart.data.datasets[element._datasetIndex],
				index = element._index,
				custom = element.custom || {},
				valueOrDefault = helpers.getValueAtIndexOrDefault,
				model = element._model;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
		},

		setHoverStyle: function(element) {
			var dataset = this.chart.data.datasets[element._datasetIndex],
				index = element._index,
				custom = element.custom || {},
				valueOrDefault = helpers.getValueAtIndexOrDefault,
				getHoverColor = helpers.getHoverColor,
				model = element._model;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		/**
		 * @private
		 */
		resyncElements: function() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data;
			var numMeta = meta.data.length;
			var numData = data.length;

			if (numData < numMeta) {
				meta.data.splice(numData, numMeta - numData);
			} else if (numData > numMeta) {
				me.insertElements(numMeta, numData - numMeta);
			}
		},

		/**
		 * @private
		 */
		insertElements: function(start, count) {
			for (var i=0; i<count; ++i) {
				this.addElementAndReset(start + i);
			}
		},

		/**
		 * @private
		 */
		onDataPush: function() {
			this.insertElements(this.getDataset().data.length-1, arguments.length);
		},

		/**
		 * @private
		 */
		onDataPop: function() {
			this.getMeta().data.pop();
		},

		/**
		 * @private
		 */
		onDataShift: function() {
			this.getMeta().data.shift();
		},

		/**
		 * @private
		 */
		onDataSplice: function(start, count) {
			this.getMeta().data.splice(start, count);
			this.insertElements(start, arguments.length - 2);
		},

		/**
		 * @private
		 */
		onDataUnshift: function() {
			this.insertElements(0, arguments.length);
		}
	});

	Chart.DatasetController.extend = helpers.inherits;
};

},{}],19:[function(require,module,exports){
'use strict';

var color = require('chartjs-color');

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	function interpolate(start, view, model, ease) {
		var keys = Object.keys(model);
		var i, ilen, key, actual, origin, target, type, c0, c1;

		for (i=0, ilen=keys.length; i<ilen; ++i) {
			key = keys[i];

			target = model[key];

			// if a value is added to the model after pivot() has been called, the view
			// doesn't contain it, so let's initialize the view to the target value.
			if (!view.hasOwnProperty(key)) {
				view[key] = target;
			}

			actual = view[key];

			if (actual === target || key[0] === '_') {
				continue;
			}

			if (!start.hasOwnProperty(key)) {
				start[key] = actual;
			}

			origin = start[key];

			type = typeof(target);

			if (type === typeof(origin)) {
				if (type === 'string') {
					c0 = color(origin);
					if (c0.valid) {
						c1 = color(target);
						if (c1.valid) {
							view[key] = c1.mix(c0, ease).rgbString();
							continue;
						}
					}
				} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
					view[key] = origin + (target - origin) * ease;
					continue;
				}
			}

			view[key] = target;
		}
	}

	Chart.elements = {};

	Chart.Element = function(configuration) {
		helpers.extend(this, configuration);
		this.initialize.apply(this, arguments);
	};

	helpers.extend(Chart.Element.prototype, {

		initialize: function() {
			this.hidden = false;
		},

		pivot: function() {
			var me = this;
			if (!me._view) {
				me._view = helpers.clone(me._model);
			}
			me._start = {};
			return me;
		},

		transition: function(ease) {
			var me = this;
			var model = me._model;
			var start = me._start;
			var view = me._view;

			// No animation -> No Transition
			if (!model || ease === 1) {
				me._view = model;
				me._start = null;
				return me;
			}

			if (!view) {
				view = me._view = {};
			}

			if (!start) {
				start = me._start = {};
			}

			interpolate(start, view, model, ease);

			return me;
		},

		tooltipPosition: function() {
			return {
				x: this._model.x,
				y: this._model.y
			};
		},

		hasValue: function() {
			return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
		}
	});

	Chart.Element.extend = helpers.inherits;
};

},{"chartjs-color":45}],20:[function(require,module,exports){
/* global window: false */
/* global document: false */
'use strict';

var color = require('chartjs-color');

module.exports = function(Chart) {
	// Global Chart helpers object for utility methods and classes
	var helpers = Chart.helpers = {};

	// -- Basic js utility methods
	helpers.each = function(loopable, callback, self, reverse) {
		// Check to see if null or undefined firstly.
		var i, len;
		if (helpers.isArray(loopable)) {
			len = loopable.length;
			if (reverse) {
				for (i = len - 1; i >= 0; i--) {
					callback.call(self, loopable[i], i);
				}
			} else {
				for (i = 0; i < len; i++) {
					callback.call(self, loopable[i], i);
				}
			}
		} else if (typeof loopable === 'object') {
			var keys = Object.keys(loopable);
			len = keys.length;
			for (i = 0; i < len; i++) {
				callback.call(self, loopable[keys[i]], keys[i]);
			}
		}
	};
	helpers.clone = function(obj) {
		var objClone = {};
		helpers.each(obj, function(value, key) {
			if (helpers.isArray(value)) {
				objClone[key] = value.slice(0);
			} else if (typeof value === 'object' && value !== null) {
				objClone[key] = helpers.clone(value);
			} else {
				objClone[key] = value;
			}
		});
		return objClone;
	};
	helpers.extend = function(base) {
		var setFn = function(value, key) {
			base[key] = value;
		};
		for (var i = 1, ilen = arguments.length; i < ilen; i++) {
			helpers.each(arguments[i], setFn);
		}
		return base;
	};
	// Need a special merge function to chart configs since they are now grouped
	helpers.configMerge = function(_base) {
		var base = helpers.clone(_base);
		helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {
			helpers.each(extension, function(value, key) {
				var baseHasProperty = base.hasOwnProperty(key);
				var baseVal = baseHasProperty ? base[key] : {};

				if (key === 'scales') {
					// Scale config merging is complex. Add our own function here for that
					base[key] = helpers.scaleMerge(baseVal, value);
				} else if (key === 'scale') {
					// Used in polar area & radar charts since there is only one scale
					base[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);
				} else if (baseHasProperty
						&& typeof baseVal === 'object'
						&& !helpers.isArray(baseVal)
						&& baseVal !== null
						&& typeof value === 'object'
						&& !helpers.isArray(value)) {
					// If we are overwriting an object with an object, do a merge of the properties.
					base[key] = helpers.configMerge(baseVal, value);
				} else {
					// can just overwrite the value in this case
					base[key] = value;
				}
			});
		});

		return base;
	};
	helpers.scaleMerge = function(_base, extension) {
		var base = helpers.clone(_base);

		helpers.each(extension, function(value, key) {
			if (key === 'xAxes' || key === 'yAxes') {
				// These properties are arrays of items
				if (base.hasOwnProperty(key)) {
					helpers.each(value, function(valueObj, index) {
						var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
						var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);
						if (index >= base[key].length || !base[key][index].type) {
							base[key].push(helpers.configMerge(axisDefaults, valueObj));
						} else if (valueObj.type && valueObj.type !== base[key][index].type) {
							// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults
							base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);
						} else {
							// Type is the same
							base[key][index] = helpers.configMerge(base[key][index], valueObj);
						}
					});
				} else {
					base[key] = [];
					helpers.each(value, function(valueObj) {
						var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
						base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));
					});
				}
			} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {
				// If we are overwriting an object with an object, do a merge of the properties.
				base[key] = helpers.configMerge(base[key], value);

			} else {
				// can just overwrite the value in this case
				base[key] = value;
			}
		});

		return base;
	};
	helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {
		if (value === undefined || value === null) {
			return defaultValue;
		}

		if (helpers.isArray(value)) {
			return index < value.length ? value[index] : defaultValue;
		}

		return value;
	};
	helpers.getValueOrDefault = function(value, defaultValue) {
		return value === undefined ? defaultValue : value;
	};
	helpers.indexOf = Array.prototype.indexOf?
		function(array, item) {
			return array.indexOf(item);
		}:
		function(array, item) {
			for (var i = 0, ilen = array.length; i < ilen; ++i) {
				if (array[i] === item) {
					return i;
				}
			}
			return -1;
		};
	helpers.where = function(collection, filterCallback) {
		if (helpers.isArray(collection) && Array.prototype.filter) {
			return collection.filter(filterCallback);
		}
		var filtered = [];

		helpers.each(collection, function(item) {
			if (filterCallback(item)) {
				filtered.push(item);
			}
		});

		return filtered;
	};
	helpers.findIndex = Array.prototype.findIndex?
		function(array, callback, scope) {
			return array.findIndex(callback, scope);
		} :
		function(array, callback, scope) {
			scope = scope === undefined? array : scope;
			for (var i = 0, ilen = array.length; i < ilen; ++i) {
				if (callback.call(scope, array[i], i, array)) {
					return i;
				}
			}
			return -1;
		};
	helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to start of the array
		if (startIndex === undefined || startIndex === null) {
			startIndex = -1;
		}
		for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to end of the array
		if (startIndex === undefined || startIndex === null) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; i >= 0; i--) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.inherits = function(extensions) {
		// Basic javascript inheritance based on the model created in Backbone.js
		var me = this;
		var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
			return me.apply(this, arguments);
		};

		var Surrogate = function() {
			this.constructor = ChartElement;
		};
		Surrogate.prototype = me.prototype;
		ChartElement.prototype = new Surrogate();

		ChartElement.extend = helpers.inherits;

		if (extensions) {
			helpers.extend(ChartElement.prototype, extensions);
		}

		ChartElement.__super__ = me.prototype;

		return ChartElement;
	};
	helpers.noop = function() {};
	helpers.uid = (function() {
		var id = 0;
		return function() {
			return id++;
		};
	}());
	// -- Math methods
	helpers.isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};
	helpers.almostEquals = function(x, y, epsilon) {
		return Math.abs(x - y) < epsilon;
	};
	helpers.almostWhole = function(x, epsilon) {
		var rounded = Math.round(x);
		return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
	};
	helpers.max = function(array) {
		return array.reduce(function(max, value) {
			if (!isNaN(value)) {
				return Math.max(max, value);
			}
			return max;
		}, Number.NEGATIVE_INFINITY);
	};
	helpers.min = function(array) {
		return array.reduce(function(min, value) {
			if (!isNaN(value)) {
				return Math.min(min, value);
			}
			return min;
		}, Number.POSITIVE_INFINITY);
	};
	helpers.sign = Math.sign?
		function(x) {
			return Math.sign(x);
		} :
		function(x) {
			x = +x; // convert to a number
			if (x === 0 || isNaN(x)) {
				return x;
			}
			return x > 0 ? 1 : -1;
		};
	helpers.log10 = Math.log10?
		function(x) {
			return Math.log10(x);
		} :
		function(x) {
			return Math.log(x) / Math.LN10;
		};
	helpers.toRadians = function(degrees) {
		return degrees * (Math.PI / 180);
	};
	helpers.toDegrees = function(radians) {
		return radians * (180 / Math.PI);
	};
	// Gets the angle from vertical upright to the point about a centre.
	helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x,
			distanceFromYCenter = anglePoint.y - centrePoint.y,
			radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

		if (angle < (-0.5 * Math.PI)) {
			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
		}

		return {
			angle: angle,
			distance: radialDistanceFromCenter
		};
	};
	helpers.distanceBetweenPoints = function(pt1, pt2) {
		return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	};
	helpers.aliasPixel = function(pixelWidth) {
		return (pixelWidth % 2 === 0) ? 0 : 0.5;
	};
	helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
		// Props to Rob Spencer at scaled innovation for his post on splining between points
		// http://scaledinnovation.com/analytics/splines/aboutSplines.html

		// This function must also respect "skipped" points

		var previous = firstPoint.skip ? middlePoint : firstPoint,
			current = middlePoint,
			next = afterPoint.skip ? middlePoint : afterPoint;

		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

		var s01 = d01 / (d01 + d12);
		var s12 = d12 / (d01 + d12);

		// If all points are the same, s01 & s02 will be inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;

		var fa = t * s01; // scaling factor for triangle Ta
		var fb = t * s12;

		return {
			previous: {
				x: current.x - fa * (next.x - previous.x),
				y: current.y - fa * (next.y - previous.y)
			},
			next: {
				x: current.x + fb * (next.x - previous.x),
				y: current.y + fb * (next.y - previous.y)
			}
		};
	};
	helpers.EPSILON = Number.EPSILON || 1e-14;
	helpers.splineCurveMonotone = function(points) {
		// This function calculates Bézier control points in a similar way than |splineCurve|,
		// but preserves monotonicity of the provided data and ensures no local extremums are added
		// between the dataset discrete points due to the interpolation.
		// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

		var pointsWithTangents = (points || []).map(function(point) {
			return {
				model: point._model,
				deltaK: 0,
				mK: 0
			};
		});

		// Calculate slopes (deltaK) and initialize tangents (mK)
		var pointsLen = pointsWithTangents.length;
		var i, pointBefore, pointCurrent, pointAfter;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointAfter && !pointAfter.model.skip) {
				var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

				// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
				pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
			}

			if (!pointBefore || pointBefore.model.skip) {
				pointCurrent.mK = pointCurrent.deltaK;
			} else if (!pointAfter || pointAfter.model.skip) {
				pointCurrent.mK = pointBefore.deltaK;
			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
				pointCurrent.mK = 0;
			} else {
				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
			}
		}

		// Adjust tangents to ensure monotonic properties
		var alphaK, betaK, tauK, squaredMagnitude;
		for (i = 0; i < pointsLen - 1; ++i) {
			pointCurrent = pointsWithTangents[i];
			pointAfter = pointsWithTangents[i + 1];
			if (pointCurrent.model.skip || pointAfter.model.skip) {
				continue;
			}

			if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
				pointCurrent.mK = pointAfter.mK = 0;
				continue;
			}

			alphaK = pointCurrent.mK / pointCurrent.deltaK;
			betaK = pointAfter.mK / pointCurrent.deltaK;
			squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
			if (squaredMagnitude <= 9) {
				continue;
			}

			tauK = 3 / Math.sqrt(squaredMagnitude);
			pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
		}

		// Compute control points
		var deltaX;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointBefore && !pointBefore.model.skip) {
				deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
			}
			if (pointAfter && !pointAfter.model.skip) {
				deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
			}
		}
	};
	helpers.nextItem = function(collection, index, loop) {
		if (loop) {
			return index >= collection.length - 1 ? collection[0] : collection[index + 1];
		}
		return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
	};
	helpers.previousItem = function(collection, index, loop) {
		if (loop) {
			return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
		}
		return index <= 0 ? collection[0] : collection[index - 1];
	};
	// Implementation of the nice number algorithm used in determining where axis labels will go
	helpers.niceNum = function(range, round) {
		var exponent = Math.floor(helpers.log10(range));
		var fraction = range / Math.pow(10, exponent);
		var niceFraction;

		if (round) {
			if (fraction < 1.5) {
				niceFraction = 1;
			} else if (fraction < 3) {
				niceFraction = 2;
			} else if (fraction < 7) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		} else if (fraction <= 1.0) {
			niceFraction = 1;
		} else if (fraction <= 2) {
			niceFraction = 2;
		} else if (fraction <= 5) {
			niceFraction = 5;
		} else {
			niceFraction = 10;
		}

		return niceFraction * Math.pow(10, exponent);
	};
	// Easing functions adapted from Robert Penner's easing equations
	// http://www.robertpenner.com/easing/
	var easingEffects = helpers.easingEffects = {
		linear: function(t) {
			return t;
		},
		easeInQuad: function(t) {
			return t * t;
		},
		easeOutQuad: function(t) {
			return -1 * t * (t - 2);
		},
		easeInOutQuad: function(t) {
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * t * t;
			}
			return -1 / 2 * ((--t) * (t - 2) - 1);
		},
		easeInCubic: function(t) {
			return t * t * t;
		},
		easeOutCubic: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t + 1);
		},
		easeInOutCubic: function(t) {
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * t * t * t;
			}
			return 1 / 2 * ((t -= 2) * t * t + 2);
		},
		easeInQuart: function(t) {
			return t * t * t * t;
		},
		easeOutQuart: function(t) {
			return -1 * ((t = t / 1 - 1) * t * t * t - 1);
		},
		easeInOutQuart: function(t) {
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * t * t * t * t;
			}
			return -1 / 2 * ((t -= 2) * t * t * t - 2);
		},
		easeInQuint: function(t) {
			return 1 * (t /= 1) * t * t * t * t;
		},
		easeOutQuint: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
		},
		easeInOutQuint: function(t) {
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * t * t * t * t * t;
			}
			return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
		},
		easeInSine: function(t) {
			return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
		},
		easeOutSine: function(t) {
			return 1 * Math.sin(t / 1 * (Math.PI / 2));
		},
		easeInOutSine: function(t) {
			return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
		},
		easeInExpo: function(t) {
			return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
		},
		easeOutExpo: function(t) {
			return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
		},
		easeInOutExpo: function(t) {
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * Math.pow(2, 10 * (t - 1));
			}
			return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
		},
		easeInCirc: function(t) {
			if (t >= 1) {
				return t;
			}
			return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
		},
		easeOutCirc: function(t) {
			return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
		},
		easeInOutCirc: function(t) {
			if ((t /= 1 / 2) < 1) {
				return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
			}
			return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
		},
		easeInElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1) === 1) {
				return 1;
			}
			if (!p) {
				p = 1 * 0.3;
			}
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
		},
		easeOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1) === 1) {
				return 1;
			}
			if (!p) {
				p = 1 * 0.3;
			}
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
		},
		easeInOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1 / 2) === 2) {
				return 1;
			}
			if (!p) {
				p = 1 * (0.3 * 1.5);
			}
			if (a < Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			if (t < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
		},
		easeInBack: function(t) {
			var s = 1.70158;
			return 1 * (t /= 1) * t * ((s + 1) * t - s);
		},
		easeOutBack: function(t) {
			var s = 1.70158;
			return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
		},
		easeInOutBack: function(t) {
			var s = 1.70158;
			if ((t /= 1 / 2) < 1) {
				return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
			}
			return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
		},
		easeInBounce: function(t) {
			return 1 - easingEffects.easeOutBounce(1 - t);
		},
		easeOutBounce: function(t) {
			if ((t /= 1) < (1 / 2.75)) {
				return 1 * (7.5625 * t * t);
			} else if (t < (2 / 2.75)) {
				return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
			} else if (t < (2.5 / 2.75)) {
				return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
			}
			return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
		},
		easeInOutBounce: function(t) {
			if (t < 1 / 2) {
				return easingEffects.easeInBounce(t * 2) * 0.5;
			}
			return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
		}
	};
	// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	helpers.requestAnimFrame = (function() {
		if (typeof window === 'undefined') {
			return function(callback) {
				callback();
			};
		}
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			};
	}());
	// -- DOM methods
	helpers.getRelativePosition = function(evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || evt,
			canvas = evt.currentTarget || evt.srcElement,
			boundingRect = canvas.getBoundingClientRect();

		var touches = e.touches;
		if (touches && touches.length > 0) {
			mouseX = touches[0].clientX;
			mouseY = touches[0].clientY;

		} else {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		// Scale mouse coordinates into canvas coordinates
		// by following the pattern laid out by 'jerryj' in the comments of
		// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

		return {
			x: mouseX,
			y: mouseY
		};

	};
	helpers.addEvent = function(node, eventType, method) {
		if (node.addEventListener) {
			node.addEventListener(eventType, method);
		} else if (node.attachEvent) {
			node.attachEvent('on' + eventType, method);
		} else {
			node['on' + eventType] = method;
		}
	};
	helpers.removeEvent = function(node, eventType, handler) {
		if (node.removeEventListener) {
			node.removeEventListener(eventType, handler, false);
		} else if (node.detachEvent) {
			node.detachEvent('on' + eventType, handler);
		} else {
			node['on' + eventType] = helpers.noop;
		}
	};

	// Private helper function to convert max-width/max-height values that may be percentages into a number
	function parseMaxStyle(styleValue, node, parentProperty) {
		var valueInPixels;
		if (typeof(styleValue) === 'string') {
			valueInPixels = parseInt(styleValue, 10);

			if (styleValue.indexOf('%') !== -1) {
				// percentage * size in dimension
				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
			}
		} else {
			valueInPixels = styleValue;
		}

		return valueInPixels;
	}

	/**
	 * Returns if the given value contains an effective constraint.
	 * @private
	 */
	function isConstrainedValue(value) {
		return value !== undefined && value !== null && value !== 'none';
	}

	// Private helper to get a constraint dimension
	// @param domNode : the node to check the constraint on
	// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
	// @param percentageProperty : property of parent to use when calculating width as a percentage
	// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		var parentNode = domNode.parentNode;
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		var hasCNode = isConstrainedValue(constrainedNode);
		var hasCContainer = isConstrainedValue(constrainedContainer);
		var infinity = Number.POSITIVE_INFINITY;

		if (hasCNode || hasCContainer) {
			return Math.min(
				hasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
				hasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
		}

		return 'none';
	}
	// returns Number or undefined if no constraint
	helpers.getConstraintWidth = function(domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// returns Number or undefined if no constraint
	helpers.getConstraintHeight = function(domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	helpers.getMaximumWidth = function(domNode) {
		var container = domNode.parentNode;
		var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
		var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
		var w = container.clientWidth - paddingLeft - paddingRight;
		var cw = helpers.getConstraintWidth(domNode);
		return isNaN(cw)? w : Math.min(w, cw);
	};
	helpers.getMaximumHeight = function(domNode) {
		var container = domNode.parentNode;
		var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
		var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
		var h = container.clientHeight - paddingTop - paddingBottom;
		var ch = helpers.getConstraintHeight(domNode);
		return isNaN(ch)? h : Math.min(h, ch);
	};
	helpers.getStyle = function(el, property) {
		return el.currentStyle ?
			el.currentStyle[property] :
			document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
	};
	helpers.retinaScale = function(chart) {
		var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;
		if (pixelRatio === 1) {
			return;
		}

		var canvas = chart.canvas;
		var height = chart.height;
		var width = chart.width;

		canvas.height = height * pixelRatio;
		canvas.width = width * pixelRatio;
		chart.ctx.scale(pixelRatio, pixelRatio);

		// If no style has been set on the canvas, the render size is used as display size,
		// making the chart visually bigger, so let's enforce it to the "correct" values.
		// See https://github.com/chartjs/Chart.js/issues/3575
		canvas.style.height = height + 'px';
		canvas.style.width = width + 'px';
	};
	// -- Canvas methods
	helpers.clear = function(chart) {
		chart.ctx.clearRect(0, 0, chart.width, chart.height);
	};
	helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
		return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
	};
	helpers.longestText = function(ctx, font, arrayOfThings, cache) {
		cache = cache || {};
		var data = cache.data = cache.data || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];

		if (cache.font !== font) {
			data = cache.data = {};
			gc = cache.garbageCollect = [];
			cache.font = font;
		}

		ctx.font = font;
		var longest = 0;
		helpers.each(arrayOfThings, function(thing) {
			// Undefined strings and arrays should not be measured
			if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
				longest = helpers.measureText(ctx, data, gc, longest, thing);
			} else if (helpers.isArray(thing)) {
				// if it is an array lets measure each element
				// to do maybe simplify this function a bit so we can do this more recursively?
				helpers.each(thing, function(nestedThing) {
					// Undefined strings and arrays should not be measured
					if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
						longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
					}
				});
			}
		});

		var gcLen = gc.length / 2;
		if (gcLen > arrayOfThings.length) {
			for (var i = 0; i < gcLen; i++) {
				delete data[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		return longest;
	};
	helpers.measureText = function(ctx, data, gc, longest, string) {
		var textWidth = data[string];
		if (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(string);
		}
		if (textWidth > longest) {
			longest = textWidth;
		}
		return longest;
	};
	helpers.numberOfLabelLines = function(arrayOfThings) {
		var numberOfLines = 1;
		helpers.each(arrayOfThings, function(thing) {
			if (helpers.isArray(thing)) {
				if (thing.length > numberOfLines) {
					numberOfLines = thing.length;
				}
			}
		});
		return numberOfLines;
	};
	helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {
		ctx.beginPath();
		ctx.moveTo(x + radius, y);
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.closePath();
	};

	helpers.color = !color?
		function(value) {
			console.error('Color.js not found!');
			return value;
		} :
		function(value) {
			/* global CanvasGradient */
			if (value instanceof CanvasGradient) {
				value = Chart.defaults.global.defaultColor;
			}

			return color(value);
		};

	helpers.isArray = Array.isArray?
		function(obj) {
			return Array.isArray(obj);
		} :
		function(obj) {
			return Object.prototype.toString.call(obj) === '[object Array]';
		};
	// ! @see http://stackoverflow.com/a/14853974
	helpers.arrayEquals = function(a0, a1) {
		var i, ilen, v0, v1;

		if (!a0 || !a1 || a0.length !== a1.length) {
			return false;
		}

		for (i = 0, ilen=a0.length; i < ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];

			if (v0 instanceof Array && v1 instanceof Array) {
				if (!helpers.arrayEquals(v0, v1)) {
					return false;
				}
			} else if (v0 !== v1) {
				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}

		return true;
	};
	helpers.callback = function(fn, args, thisArg) {
		if (fn && typeof fn.call === 'function') {
			fn.apply(thisArg, args);
		}
	};
	helpers.getHoverColor = function(colorValue) {
		/* global CanvasPattern */
		return (colorValue instanceof CanvasPattern) ?
			colorValue :
			helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
	};

	/**
	 * Provided for backward compatibility, use Chart.helpers#callback instead.
	 * @function Chart.helpers#callCallback
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 */
	helpers.callCallback = helpers.callback;
};

},{"chartjs-color":45}],21:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {
	var helpers = Chart.helpers;

	/**
	 * Helper function to get relative position for an event
	 * @param {Event|IEvent} event - The event to get the position for
	 * @param {Chart} chart - The chart
	 * @returns {Point} the event position
	 */
	function getRelativePosition(e, chart) {
		if (e.native) {
			return {
				x: e.x,
				y: e.y
			};
		}

		return helpers.getRelativePosition(e, chart);
	}

	/**
	 * Helper function to traverse all of the visible elements in the chart
	 * @param chart {chart} the chart
	 * @param handler {Function} the callback to execute for each visible item
	 */
	function parseVisibleItems(chart, handler) {
		var datasets = chart.data.datasets;
		var meta, i, j, ilen, jlen;

		for (i = 0, ilen = datasets.length; i < ilen; ++i) {
			if (!chart.isDatasetVisible(i)) {
				continue;
			}

			meta = chart.getDatasetMeta(i);
			for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
				var element = meta.data[j];
				if (!element._view.skip) {
					handler(element);
				}
			}
		}
	}

	/**
	 * Helper function to get the items that intersect the event position
	 * @param items {ChartElement[]} elements to filter
	 * @param position {Point} the point to be nearest to
	 * @return {ChartElement[]} the nearest items
	 */
	function getIntersectItems(chart, position) {
		var elements = [];

		parseVisibleItems(chart, function(element) {
			if (element.inRange(position.x, position.y)) {
				elements.push(element);
			}
		});

		return elements;
	}

	/**
	 * Helper function to get the items nearest to the event position considering all visible items in teh chart
	 * @param chart {Chart} the chart to look at elements from
	 * @param position {Point} the point to be nearest to
	 * @param intersect {Boolean} if true, only consider items that intersect the position
	 * @param distanceMetric {Function} Optional function to provide the distance between
	 * @return {ChartElement[]} the nearest items
	 */
	function getNearestItems(chart, position, intersect, distanceMetric) {
		var minDistance = Number.POSITIVE_INFINITY;
		var nearestItems = [];

		if (!distanceMetric) {
			distanceMetric = helpers.distanceBetweenPoints;
		}

		parseVisibleItems(chart, function(element) {
			if (intersect && !element.inRange(position.x, position.y)) {
				return;
			}

			var center = element.getCenterPoint();
			var distance = distanceMetric(position, center);

			if (distance < minDistance) {
				nearestItems = [element];
				minDistance = distance;
			} else if (distance === minDistance) {
				// Can have multiple items at the same distance in which case we sort by size
				nearestItems.push(element);
			}
		});

		return nearestItems;
	}

	function indexMode(chart, e, options) {
		var position = getRelativePosition(e, chart);
		var distanceMetric = function(pt1, pt2) {
			return Math.abs(pt1.x - pt2.x);
		};
		var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
		var elements = [];

		if (!items.length) {
			return [];
		}

		chart.data.datasets.forEach(function(dataset, datasetIndex) {
			if (chart.isDatasetVisible(datasetIndex)) {
				var meta = chart.getDatasetMeta(datasetIndex),
					element = meta.data[items[0]._index];

				// don't count items that are skipped (null data)
				if (element && !element._view.skip) {
					elements.push(element);
				}
			}
		});

		return elements;
	}

	/**
	 * @interface IInteractionOptions
	 */
	/**
	 * If true, only consider items that intersect the point
	 * @name IInterfaceOptions#boolean
	 * @type Boolean
	 */

	/**
	 * Contains interaction related functions
	 * @namespace Chart.Interaction
	 */
	Chart.Interaction = {
		// Helper function for different modes
		modes: {
			single: function(chart, e) {
				var position = getRelativePosition(e, chart);
				var elements = [];

				parseVisibleItems(chart, function(element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
						return elements;
					}
				});

				return elements.slice(0, 1);
			},

			/**
			 * @function Chart.Interaction.modes.label
			 * @deprecated since version 2.4.0
	 		 * @todo remove at version 3
			 * @private
			 */
			label: indexMode,

			/**
			 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
			 * @function Chart.Interaction.modes.index
			 * @since v2.4.0
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			index: indexMode,

			/**
			 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect is false, we find the nearest item and return the items in that dataset
			 * @function Chart.Interaction.modes.dataset
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			dataset: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);

				if (items.length > 0) {
					items = chart.getDatasetMeta(items[0]._datasetIndex).data;
				}

				return items;
			},

			/**
			 * @function Chart.Interaction.modes.x-axis
			 * @deprecated since version 2.4.0. Use index mode and intersect == true
			 * @todo remove at version 3
			 * @private
			 */
			'x-axis': function(chart, e) {
				return indexMode(chart, e, true);
			},

			/**
			 * Point mode returns all elements that hit test based on the event position
			 * of the event
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			point: function(chart, e) {
				var position = getRelativePosition(e, chart);
				return getIntersectItems(chart, position);
			},

			/**
			 * nearest mode returns the element closest to the point
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			nearest: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var nearestItems = getNearestItems(chart, position, options.intersect);

				// We have multiple items at the same distance from the event. Now sort by smallest
				if (nearestItems.length > 1) {
					nearestItems.sort(function(a, b) {
						var sizeA = a.getArea();
						var sizeB = b.getArea();
						var ret = sizeA - sizeB;

						if (ret === 0) {
							// if equal sort by dataset index
							ret = a._datasetIndex - b._datasetIndex;
						}

						return ret;
					});
				}

				// Return only 1 item
				return nearestItems.slice(0, 1);
			},

			/**
			 * x mode returns the elements that hit-test at the current x coordinate
			 * @function Chart.Interaction.modes.x
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			x: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inXRange(position.x)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don't have any items
				// that intersect the position, return nothing
				if (options.intersect && !intersectsItem) {
					items = [];
				}
				return items;
			},

			/**
			 * y mode returns the elements that hit-test at the current y coordinate
			 * @function Chart.Interaction.modes.y
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			y: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inYRange(position.y)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don't have any items
				// that intersect the position, return nothing
				if (options.intersect && !intersectsItem) {
					items = [];
				}
				return items;
			}
		}
	};
};

},{}],22:[function(require,module,exports){
'use strict';

module.exports = function() {

	// Occupy the global variable of Chart, and create a simple base class
	var Chart = function(item, config) {
		this.construct(item, config);
		return this;
	};

	// Globally expose the defaults to allow for user updating/changing
	Chart.defaults = {
		global: {
			responsive: true,
			responsiveAnimationDuration: 0,
			maintainAspectRatio: true,
			events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
			hover: {
				onHover: null,
				mode: 'nearest',
				intersect: true,
				animationDuration: 400
			},
			onClick: null,
			defaultColor: 'rgba(0,0,0,0.1)',
			defaultFontColor: '#666',
			defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
			defaultFontSize: 12,
			defaultFontStyle: 'normal',
			showLines: true,

			// Element defaults defined in element extensions
			elements: {},

			// Legend callback string
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
				for (var i = 0; i < chart.data.datasets.length; i++) {
					text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
					if (chart.data.datasets[i].label) {
						text.push(chart.data.datasets[i].label);
					}
					text.push('</li>');
				}
				text.push('</ul>');

				return text.join('');
			}
		}
	};

	Chart.Chart = Chart;

	return Chart;
};

},{}],23:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	function filterByPosition(array, position) {
		return helpers.where(array, function(v) {
			return v.position === position;
		});
	}

	function sortByWeight(array, reverse) {
		array.forEach(function(v, i) {
			v._tmpIndex_ = i;
			return v;
		});
		array.sort(function(a, b) {
			var v0 = reverse ? b : a;
			var v1 = reverse ? a : b;
			return v0.weight === v1.weight ?
				v0._tmpIndex_ - v1._tmpIndex_ :
				v0.weight - v1.weight;
		});
		array.forEach(function(v) {
			delete v._tmpIndex_;
		});
	}

	/**
	 * @interface ILayoutItem
	 * @prop {String} position - The position of the item in the chart layout. Possible values are
	 * 'left', 'top', 'right', 'bottom', and 'chartArea'
	 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
	 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
	 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
	 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
	 * @prop {Function} getPadding -  Returns an object with padding on the edges
	 * @prop {Number} width - Width of item. Must be valid after update()
	 * @prop {Number} height - Height of item. Must be valid after update()
	 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
	 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
	 */

	// The layout service is very self explanatory.  It's responsible for the layout within a chart.
	// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
	// It is this service's responsibility of carrying out that layout.
	Chart.layoutService = {
		defaults: {},

		/**
		 * Register a box to a chart.
		 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
		 * @param {Chart} chart - the chart to use
		 * @param {ILayoutItem} item - the item to add to be layed out
		 */
		addBox: function(chart, item) {
			if (!chart.boxes) {
				chart.boxes = [];
			}

			// initialize item with default values
			item.fullWidth = item.fullWidth || false;
			item.position = item.position || 'top';
			item.weight = item.weight || 0;

			chart.boxes.push(item);
		},

		/**
		 * Remove a layoutItem from a chart
		 * @param {Chart} chart - the chart to remove the box from
		 * @param {Object} layoutItem - the item to remove from the layout
		 */
		removeBox: function(chart, layoutItem) {
			var index = chart.boxes? chart.boxes.indexOf(layoutItem) : -1;
			if (index !== -1) {
				chart.boxes.splice(index, 1);
			}
		},

		/**
		 * Sets (or updates) options on the given `item`.
		 * @param {Chart} chart - the chart in which the item lives (or will be added to)
		 * @param {Object} item - the item to configure with the given options
		 * @param {Object} options - the new item options.
		 */
		configure: function(chart, item, options) {
			var props = ['fullWidth', 'position', 'weight'];
			var ilen = props.length;
			var i = 0;
			var prop;

			for (; i<ilen; ++i) {
				prop = props[i];
				if (options.hasOwnProperty(prop)) {
					item[prop] = options[prop];
				}
			}
		},

		/**
		 * Fits boxes of the given chart into the given size by having each box measure itself
		 * then running a fitting algorithm
		 * @param {Chart} chart - the chart
		 * @param {Number} width - the width to fit into
		 * @param {Number} height - the height to fit into
		 */
		update: function(chart, width, height) {
			if (!chart) {
				return;
			}

			var layoutOptions = chart.options.layout;
			var padding = layoutOptions ? layoutOptions.padding : null;

			var leftPadding = 0;
			var rightPadding = 0;
			var topPadding = 0;
			var bottomPadding = 0;

			if (!isNaN(padding)) {
				// options.layout.padding is a number. assign to all
				leftPadding = padding;
				rightPadding = padding;
				topPadding = padding;
				bottomPadding = padding;
			} else {
				leftPadding = padding.left || 0;
				rightPadding = padding.right || 0;
				topPadding = padding.top || 0;
				bottomPadding = padding.bottom || 0;
			}

			var leftBoxes = filterByPosition(chart.boxes, 'left');
			var rightBoxes = filterByPosition(chart.boxes, 'right');
			var topBoxes = filterByPosition(chart.boxes, 'top');
			var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
			var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

			// Sort boxes by weight. A higher weight is further away from the chart area
			sortByWeight(leftBoxes, true);
			sortByWeight(rightBoxes, false);
			sortByWeight(topBoxes, true);
			sortByWeight(bottomBoxes, false);

			// Essentially we now have any number of boxes on each of the 4 sides.
			// Our canvas looks like the following.
			// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
			// B1 is the bottom axis
			// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
			// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
			// an error will be thrown.
			//
			// |----------------------------------------------------|
			// |                  T1 (Full Width)                   |
			// |----------------------------------------------------|
			// |    |    |                 T2                  |    |
			// |    |----|-------------------------------------|----|
			// |    |    | C1 |                           | C2 |    |
			// |    |    |----|                           |----|    |
			// |    |    |                                     |    |
			// | L1 | L2 |           ChartArea (C0)            | R1 |
			// |    |    |                                     |    |
			// |    |    |----|                           |----|    |
			// |    |    | C3 |                           | C4 |    |
			// |    |----|-------------------------------------|----|
			// |    |    |                 B1                  |    |
			// |----------------------------------------------------|
			// |                  B2 (Full Width)                   |
			// |----------------------------------------------------|
			//
			// What we do to find the best sizing, we do the following
			// 1. Determine the minimum size of the chart area.
			// 2. Split the remaining width equally between each vertical axis
			// 3. Split the remaining height equally between each horizontal axis
			// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
			// 5. Adjust the sizes of each axis based on it's minimum reported size.
			// 6. Refit each axis
			// 7. Position each axis in the final location
			// 8. Tell the chart the final location of the chart area
			// 9. Tell any axes that overlay the chart area the positions of the chart area

			// Step 1
			var chartWidth = width - leftPadding - rightPadding;
			var chartHeight = height - topPadding - bottomPadding;
			var chartAreaWidth = chartWidth / 2; // min 50%
			var chartAreaHeight = chartHeight / 2; // min 50%

			// Step 2
			var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

			// Step 3
			var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

			// Step 4
			var maxChartAreaWidth = chartWidth;
			var maxChartAreaHeight = chartHeight;
			var minBoxSizes = [];

			function getMinimumBoxSize(box) {
				var minSize;
				var isHorizontal = box.isHorizontal();

				if (isHorizontal) {
					minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
					maxChartAreaHeight -= minSize.height;
				} else {
					minSize = box.update(verticalBoxWidth, chartAreaHeight);
					maxChartAreaWidth -= minSize.width;
				}

				minBoxSizes.push({
					horizontal: isHorizontal,
					minSize: minSize,
					box: box,
				});
			}

			helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

			// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
			var maxHorizontalLeftPadding = 0;
			var maxHorizontalRightPadding = 0;
			var maxVerticalTopPadding = 0;
			var maxVerticalBottomPadding = 0;

			helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
				if (horizontalBox.getPadding) {
					var boxPadding = horizontalBox.getPadding();
					maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
					maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
				}
			});

			helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
				if (verticalBox.getPadding) {
					var boxPadding = verticalBox.getPadding();
					maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
					maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
				}
			});

			// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
			// be if the axes are drawn at their minimum sizes.
			// Steps 5 & 6
			var totalLeftBoxesWidth = leftPadding;
			var totalRightBoxesWidth = rightPadding;
			var totalTopBoxesHeight = topPadding;
			var totalBottomBoxesHeight = bottomPadding;

			// Function to fit a box
			function fitBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
					return minBox.box === box;
				});

				if (minBoxSize) {
					if (box.isHorizontal()) {
						var scaleMargin = {
							left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
							right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
							top: 0,
							bottom: 0
						};

						// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
						// on the margin. Sometimes they need to increase in size slightly
						box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
					} else {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight);
					}
				}
			}

			// Update, and calculate the left and right margins for the horizontal boxes
			helpers.each(leftBoxes.concat(rightBoxes), fitBox);

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});

			// Set the Left and Right margins for the horizontal boxes
			helpers.each(topBoxes.concat(bottomBoxes), fitBox);

			// Figure out how much margin is on the top and bottom of the vertical boxes
			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});

			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});

			function finalFitVerticalBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
					return minSize.box === box;
				});

				var scaleMargin = {
					left: 0,
					right: 0,
					top: totalTopBoxesHeight,
					bottom: totalBottomBoxesHeight
				};

				if (minBoxSize) {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
				}
			}

			// Let the left layout know the final margin
			helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

			// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
			totalLeftBoxesWidth = leftPadding;
			totalRightBoxesWidth = rightPadding;
			totalTopBoxesHeight = topPadding;
			totalBottomBoxesHeight = bottomPadding;

			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});

			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});
			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});

			// We may be adding some padding to account for rotated x axis labels
			var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
			totalLeftBoxesWidth += leftPaddingAddition;
			totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

			var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
			totalTopBoxesHeight += topPaddingAddition;
			totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

			// Figure out if our chart area changed. This would occur if the dataset layout label rotation
			// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
			// without calling `fit` again
			var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
			var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

			if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
				helpers.each(leftBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(rightBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(topBoxes, function(box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				helpers.each(bottomBoxes, function(box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				maxChartAreaHeight = newMaxChartAreaHeight;
				maxChartAreaWidth = newMaxChartAreaWidth;
			}

			// Step 7 - Position the boxes
			var left = leftPadding + leftPaddingAddition;
			var top = topPadding + topPaddingAddition;

			function placeBox(box) {
				if (box.isHorizontal()) {
					box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
					box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
					box.top = top;
					box.bottom = top + box.height;

					// Move to next point
					top = box.bottom;

				} else {

					box.left = left;
					box.right = left + box.width;
					box.top = totalTopBoxesHeight;
					box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

					// Move to next point
					left = box.right;
				}
			}

			helpers.each(leftBoxes.concat(topBoxes), placeBox);

			// Account for chart width and height
			left += maxChartAreaWidth;
			top += maxChartAreaHeight;

			helpers.each(rightBoxes, placeBox);
			helpers.each(bottomBoxes, placeBox);

			// Step 8
			chart.chartArea = {
				left: totalLeftBoxesWidth,
				top: totalTopBoxesHeight,
				right: totalLeftBoxesWidth + maxChartAreaWidth,
				bottom: totalTopBoxesHeight + maxChartAreaHeight
			};

			// Step 9
			helpers.each(chartAreaBoxes, function(box) {
				box.left = chart.chartArea.left;
				box.top = chart.chartArea.top;
				box.right = chart.chartArea.right;
				box.bottom = chart.chartArea.bottom;

				box.update(maxChartAreaWidth, maxChartAreaHeight);
			});
		}
	};
};

},{}],24:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.global.plugins = {};

	/**
	 * The plugin service singleton
	 * @namespace Chart.plugins
	 * @since 2.1.0
	 */
	Chart.plugins = {
		/**
		 * Globally registered plugins.
		 * @private
		 */
		_plugins: [],

		/**
		 * This identifier is used to invalidate the descriptors cache attached to each chart
		 * when a global plugin is registered or unregistered. In this case, the cache ID is
		 * incremented and descriptors are regenerated during following API calls.
		 * @private
		 */
		_cacheId: 0,

		/**
		 * Registers the given plugin(s) if not already registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		register: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				if (p.indexOf(plugin) === -1) {
					p.push(plugin);
				}
			});

			this._cacheId++;
		},

		/**
		 * Unregisters the given plugin(s) only if registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		unregister: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				var idx = p.indexOf(plugin);
				if (idx !== -1) {
					p.splice(idx, 1);
				}
			});

			this._cacheId++;
		},

		/**
		 * Remove all registered plugins.
		 * @since 2.1.5
		 */
		clear: function() {
			this._plugins = [];
			this._cacheId++;
		},

		/**
		 * Returns the number of registered plugins?
		 * @returns {Number}
		 * @since 2.1.5
		 */
		count: function() {
			return this._plugins.length;
		},

		/**
		 * Returns all registered plugin instances.
		 * @returns {Array} array of plugin objects.
		 * @since 2.1.5
		 */
		getAll: function() {
			return this._plugins;
		},

		/**
		 * Calls enabled plugins for `chart` on the specified hook and with the given args.
		 * This method immediately returns as soon as a plugin explicitly returns false. The
		 * returned value can be used, for instance, to interrupt the current action.
		 * @param {Object} chart - The chart instance for which plugins should be called.
		 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
		 * @param {Array} [args] - Extra arguments to apply to the hook call.
		 * @returns {Boolean} false if any of the plugins return false, else returns true.
		 */
		notify: function(chart, hook, args) {
			var descriptors = this.descriptors(chart);
			var ilen = descriptors.length;
			var i, descriptor, plugin, params, method;

			for (i=0; i<ilen; ++i) {
				descriptor = descriptors[i];
				plugin = descriptor.plugin;
				method = plugin[hook];
				if (typeof method === 'function') {
					params = [chart].concat(args || []);
					params.push(descriptor.options);
					if (method.apply(plugin, params) === false) {
						return false;
					}
				}
			}

			return true;
		},

		/**
		 * Returns descriptors of enabled plugins for the given chart.
		 * @returns {Array} [{ plugin, options }]
		 * @private
		 */
		descriptors: function(chart) {
			var cache = chart._plugins || (chart._plugins = {});
			if (cache.id === this._cacheId) {
				return cache.descriptors;
			}

			var plugins = [];
			var descriptors = [];
			var config = (chart && chart.config) || {};
			var defaults = Chart.defaults.global.plugins;
			var options = (config.options && config.options.plugins) || {};

			this._plugins.concat(config.plugins || []).forEach(function(plugin) {
				var idx = plugins.indexOf(plugin);
				if (idx !== -1) {
					return;
				}

				var id = plugin.id;
				var opts = options[id];
				if (opts === false) {
					return;
				}

				if (opts === true) {
					opts = helpers.clone(defaults[id]);
				}

				plugins.push(plugin);
				descriptors.push({
					plugin: plugin,
					options: opts || {}
				});
			});

			cache.descriptors = descriptors;
			cache.id = this._cacheId;
			return descriptors;
		}
	};

	/**
	 * Plugin extension hooks.
	 * @interface IPlugin
	 * @since 2.1.0
	 */
	/**
	 * @method IPlugin#beforeInit
	 * @desc Called before initializing `chart`.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterInit
	 * @desc Called after `chart` has been initialized and before the first update.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeUpdate
	 * @desc Called before updating `chart`. If any plugin returns `false`, the update
	 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart update.
	 */
	/**
	 * @method IPlugin#afterUpdate
	 * @desc Called after `chart` has been updated and before rendering. Note that this
	 * hook will not be called if the chart update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsUpdate
 	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
	 * the datasets update is cancelled until another `update` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} false to cancel the datasets update.
	 * @since version 2.1.5
	 */
	/**
	 * @method IPlugin#afterDatasetsUpdate
	 * @desc Called after the `chart` datasets have been updated. Note that this hook
	 * will not be called if the datasets update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @since version 2.1.5
	 */
	/**
	 * @method IPlugin#beforeDatasetUpdate
 	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
	 * returns `false`, the datasets update is cancelled until another `update` is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.index - The dataset index.
	 * @param {Number} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetUpdate
 	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
	 * that this hook will not be called if the datasets update has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.index - The dataset index.
	 * @param {Number} args.meta - The dataset metadata.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeLayout
	 * @desc Called before laying out `chart`. If any plugin returns `false`,
	 * the layout update is cancelled until another `update` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart layout.
	 */
	/**
	 * @method IPlugin#afterLayout
	 * @desc Called after the `chart` has been layed out. Note that this hook will not
	 * be called if the layout update has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeRender
	 * @desc Called before rendering `chart`. If any plugin returns `false`,
	 * the rendering is cancelled until another `render` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart rendering.
	 */
	/**
	 * @method IPlugin#afterRender
	 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
	 * that this hook will not be called if the rendering has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDraw
	 * @desc Called before drawing `chart` at every animation frame specified by the given
	 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
	 * another `render` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart drawing.
	 */
	/**
	 * @method IPlugin#afterDraw
	 * @desc Called after the `chart` has been drawn for the specific easing value. Note
	 * that this hook will not be called if the drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetsDraw
 	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
	 * the datasets drawing is cancelled until another `render` is triggered.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetsDraw
	 * @desc Called after the `chart` datasets have been drawn. Note that this hook
	 * will not be called if the datasets drawing has been previously cancelled.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeDatasetDraw
 	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
	 * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
	 * is cancelled until another `render` is triggered.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.index - The dataset index.
	 * @param {Number} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 * @returns {Boolean} `false` to cancel the chart datasets drawing.
	 */
	/**
	 * @method IPlugin#afterDatasetDraw
 	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
	 * (datasets are drawn in the reverse order). Note that this hook will not be called
	 * if the datasets drawing has been previously cancelled.
	 * @param {Chart} chart - The chart instance.
	 * @param {Object} args - The call arguments.
	 * @param {Object} args.index - The dataset index.
	 * @param {Number} args.meta - The dataset metadata.
	 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#beforeEvent
 	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
	 * the event will be discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#afterEvent
	 * @desc Called after the `event` has been consumed. Note that this hook
	 * will not be called if the `event` has been previously discarded.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {IEvent} event - The event object.
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#resize
	 * @desc Called after the chart as been resized.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
	 * @param {Object} options - The plugin options.
	 */
	/**
	 * @method IPlugin#destroy
	 * @desc Called after the chart as been destroyed.
	 * @param {Chart.Controller} chart - The chart instance.
	 * @param {Object} options - The plugin options.
	 */

	/**
	 * Provided for backward compatibility, use Chart.plugins instead
	 * @namespace Chart.pluginService
	 * @deprecated since version 2.1.5
	 * @todo remove at version 3
	 * @private
	 */
	Chart.pluginService = Chart.plugins;

	/**
	 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
	 * effect, instead simply create/register plugins via plain JavaScript objects.
	 * @interface Chart.PluginBase
	 * @deprecated since version 2.5.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.PluginBase = Chart.Element.extend({});
};

},{}],25:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.scale = {
		display: true,
		position: 'left',

		// grid line settings
		gridLines: {
			display: true,
			color: 'rgba(0, 0, 0, 0.1)',
			lineWidth: 1,
			drawBorder: true,
			drawOnChartArea: true,
			drawTicks: true,
			tickMarkLength: 10,
			zeroLineWidth: 1,
			zeroLineColor: 'rgba(0,0,0,0.25)',
			zeroLineBorderDash: [],
			zeroLineBorderDashOffset: 0.0,
			offsetGridLines: false,
			borderDash: [],
			borderDashOffset: 0.0
		},

		// scale label
		scaleLabel: {
			// actual label
			labelString: '',

			// display property
			display: false
		},

		// label settings
		ticks: {
			beginAtZero: false,
			minRotation: 0,
			maxRotation: 50,
			mirror: false,
			padding: 0,
			reverse: false,
			display: true,
			autoSkip: true,
			autoSkipPadding: 0,
			labelOffset: 0,
			// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
			callback: Chart.Ticks.formatters.values
		}
	};

	function computeTextSize(context, tick, font) {
		return helpers.isArray(tick) ?
			helpers.longestText(context, font, tick) :
			context.measureText(tick).width;
	}

	function parseFontOptions(options) {
		var getValueOrDefault = helpers.getValueOrDefault;
		var globalDefaults = Chart.defaults.global;
		var size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
		var style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
		var family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

		return {
			size: size,
			style: style,
			family: family,
			font: helpers.fontString(size, style, family)
		};
	}

	Chart.Scale = Chart.Element.extend({
		/**
		 * Get the padding needed for the scale
		 * @method getPadding
		 * @private
		 * @returns {Padding} the necessary padding
		 */
		getPadding: function() {
			var me = this;
			return {
				left: me.paddingLeft || 0,
				top: me.paddingTop || 0,
				right: me.paddingRight || 0,
				bottom: me.paddingBottom || 0
			};
		},

		// These methods are ordered by lifecyle. Utilities then follow.
		// Any function defined here is inherited by all scale types.
		// Any function can be extended by the scale type

		beforeUpdate: function() {
			helpers.callback(this.options.beforeUpdate, [this]);
		},
		update: function(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = helpers.extend({
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, margins);
			me.longestTextCache = me.longestTextCache || {};

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();

			// Data min/max
			me.beforeDataLimits();
			me.determineDataLimits();
			me.afterDataLimits();

			// Ticks
			me.beforeBuildTicks();
			me.buildTicks();
			me.afterBuildTicks();

			me.beforeTickToLabelConversion();
			me.convertTicksToLabels();
			me.afterTickToLabelConversion();

			// Tick Rotation
			me.beforeCalculateTickRotation();
			me.calculateTickRotation();
			me.afterCalculateTickRotation();
			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;

		},
		afterUpdate: function() {
			helpers.callback(this.options.afterUpdate, [this]);
		},

		//

		beforeSetDimensions: function() {
			helpers.callback(this.options.beforeSetDimensions, [this]);
		},
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;
		},
		afterSetDimensions: function() {
			helpers.callback(this.options.afterSetDimensions, [this]);
		},

		// Data limits
		beforeDataLimits: function() {
			helpers.callback(this.options.beforeDataLimits, [this]);
		},
		determineDataLimits: helpers.noop,
		afterDataLimits: function() {
			helpers.callback(this.options.afterDataLimits, [this]);
		},

		//
		beforeBuildTicks: function() {
			helpers.callback(this.options.beforeBuildTicks, [this]);
		},
		buildTicks: helpers.noop,
		afterBuildTicks: function() {
			helpers.callback(this.options.afterBuildTicks, [this]);
		},

		beforeTickToLabelConversion: function() {
			helpers.callback(this.options.beforeTickToLabelConversion, [this]);
		},
		convertTicksToLabels: function() {
			var me = this;
			// Convert ticks to strings
			var tickOpts = me.options.ticks;
			me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);
		},
		afterTickToLabelConversion: function() {
			helpers.callback(this.options.afterTickToLabelConversion, [this]);
		},

		//

		beforeCalculateTickRotation: function() {
			helpers.callback(this.options.beforeCalculateTickRotation, [this]);
		},
		calculateTickRotation: function() {
			var me = this;
			var context = me.ctx;
			var tickOpts = me.options.ticks;

			// Get the width of each grid by calculating the difference
			// between x offsets between 0 and 1.
			var tickFont = parseFontOptions(tickOpts);
			context.font = tickFont.font;

			var labelRotation = tickOpts.minRotation || 0;

			if (me.options.display && me.isHorizontal()) {
				var originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);
				var labelWidth = originalLabelWidth;
				var cosRotation;
				var sinRotation;

				// Allow 3 pixels x2 padding either side for label readability
				var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

				// Max label rotation can be set or default to 90 - also act as a loop counter
				while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
					var angleRadians = helpers.toRadians(labelRotation);
					cosRotation = Math.cos(angleRadians);
					sinRotation = Math.sin(angleRadians);

					if (sinRotation * originalLabelWidth > me.maxHeight) {
						// go back one step
						labelRotation--;
						break;
					}

					labelRotation++;
					labelWidth = cosRotation * originalLabelWidth;
				}
			}

			me.labelRotation = labelRotation;
		},
		afterCalculateTickRotation: function() {
			helpers.callback(this.options.afterCalculateTickRotation, [this]);
		},

		//

		beforeFit: function() {
			helpers.callback(this.options.beforeFit, [this]);
		},
		fit: function() {
			var me = this;
			// Reset
			var minSize = me.minSize = {
				width: 0,
				height: 0
			};

			var opts = me.options;
			var tickOpts = opts.ticks;
			var scaleLabelOpts = opts.scaleLabel;
			var gridLineOpts = opts.gridLines;
			var display = opts.display;
			var isHorizontal = me.isHorizontal();

			var tickFont = parseFontOptions(tickOpts);
			var scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;
			var tickMarkLength = opts.gridLines.tickMarkLength;

			// Width
			if (isHorizontal) {
				// subtract the margins to line up with the chartArea if we are a full width scale
				minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
			} else {
				minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			}

			// height
			if (isHorizontal) {
				minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			} else {
				minSize.height = me.maxHeight; // fill all the height
			}

			// Are we showing a title for the scale?
			if (scaleLabelOpts.display && display) {
				if (isHorizontal) {
					minSize.height += scaleLabelFontSize;
				} else {
					minSize.width += scaleLabelFontSize;
				}
			}

			// Don't bother fitting the ticks if we are not showing them
			if (tickOpts.display && display) {
				var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);
				var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);
				var lineSpace = tickFont.size * 0.5;

				if (isHorizontal) {
					// A horizontal axis is more constrained by the height.
					me.longestLabelWidth = largestTextWidth;

					var angleRadians = helpers.toRadians(me.labelRotation);
					var cosRotation = Math.cos(angleRadians);
					var sinRotation = Math.sin(angleRadians);

					// TODO - improve this calculation
					var labelHeight = (sinRotation * largestTextWidth)
						+ (tickFont.size * tallestLabelHeightInLines)
						+ (lineSpace * tallestLabelHeightInLines);

					minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);
					me.ctx.font = tickFont.font;

					var firstTick = me.ticks[0];
					var firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);

					var lastTick = me.ticks[me.ticks.length - 1];
					var lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);

					// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated
					// by the font height
					if (me.labelRotation !== 0) {
						me.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
						me.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;
					} else {
						me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
						me.paddingRight = lastLabelWidth / 2 + 3;
					}
				} else {
					// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first
					// Account for padding

					if (tickOpts.mirror) {
						largestTextWidth = 0;
					} else {
						largestTextWidth += me.options.ticks.padding;
					}
					minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
					me.paddingTop = tickFont.size / 2;
					me.paddingBottom = tickFont.size / 2;
				}
			}

			me.handleMargins();

			me.width = minSize.width;
			me.height = minSize.height;
		},

		/**
		 * Handle margins and padding interactions
		 * @private
		 */
		handleMargins: function() {
			var me = this;
			if (me.margins) {
				me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
				me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
				me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
				me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
			}
		},

		afterFit: function() {
			helpers.callback(this.options.afterFit, [this]);
		},

		// Shared Methods
		isHorizontal: function() {
			return this.options.position === 'top' || this.options.position === 'bottom';
		},
		isFullWidth: function() {
			return (this.options.fullWidth);
		},

		// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
		getRightValue: function(rawValue) {
			// Null and undefined values first
			if (rawValue === null || typeof(rawValue) === 'undefined') {
				return NaN;
			}
			// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
			if (typeof(rawValue) === 'number' && !isFinite(rawValue)) {
				return NaN;
			}
			// If it is in fact an object, dive in one more level
			if (typeof(rawValue) === 'object') {
				if ((rawValue instanceof Date) || (rawValue.isValid)) {
					return rawValue;
				}
				return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);
			}

			// Value is good, return it
			return rawValue;
		},

		// Used to get the value to display in the tooltip for the data at the given index
		// function getLabelForIndex(index, datasetIndex)
		getLabelForIndex: helpers.noop,

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: helpers.noop,

		// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
		getValueForPixel: helpers.noop,

		// Used for tick location, should
		getPixelForTick: function(index, includeOffset) {
			var me = this;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
				var pixel = (tickWidth * index) + me.paddingLeft;

				if (includeOffset) {
					pixel += tickWidth / 2;
				}

				var finalVal = me.left + Math.round(pixel);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			}
			var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
			return me.top + (index * (innerHeight / (me.ticks.length - 1)));
		},

		// Utility for getting the pixel location of a percentage of scale
		getPixelForDecimal: function(decimal /* , includeOffset*/) {
			var me = this;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueOffset = (innerWidth * decimal) + me.paddingLeft;

				var finalVal = me.left + Math.round(valueOffset);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			}
			return me.top + (decimal * me.height);
		},

		getBasePixel: function() {
			return this.getPixelForValue(this.getBaseValue());
		},

		getBaseValue: function() {
			var me = this;
			var min = me.min;
			var max = me.max;

			return me.beginAtZero ? 0:
				min < 0 && max < 0? max :
				min > 0 && max > 0? min :
				0;
		},

		// Actually draw the scale on the canvas
		// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
		draw: function(chartArea) {
			var me = this;
			var options = me.options;
			if (!options.display) {
				return;
			}

			var context = me.ctx;
			var globalDefaults = Chart.defaults.global;
			var optionTicks = options.ticks;
			var gridLines = options.gridLines;
			var scaleLabel = options.scaleLabel;

			var isRotated = me.labelRotation !== 0;
			var skipRatio;
			var useAutoskipper = optionTicks.autoSkip;
			var isHorizontal = me.isHorizontal();

			// figure out the maximum number of gridlines to show
			var maxTicks;
			if (optionTicks.maxTicksLimit) {
				maxTicks = optionTicks.maxTicksLimit;
			}

			var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
			var tickFont = parseFontOptions(optionTicks);

			var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

			var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
			var scaleLabelFont = parseFontOptions(scaleLabel);

			var labelRotationRadians = helpers.toRadians(me.labelRotation);
			var cosRotation = Math.cos(labelRotationRadians);
			var longestRotatedLabel = me.longestLabelWidth * cosRotation;

			// Make sure we draw text in the correct color and font
			context.fillStyle = tickFontColor;

			var itemsToDraw = [];

			if (isHorizontal) {
				skipRatio = false;

				if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {
					skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));
				}

				// if they defined a max number of optionTicks,
				// increase skipRatio until that number is met
				if (maxTicks && me.ticks.length > maxTicks) {
					while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {
						if (!skipRatio) {
							skipRatio = 1;
						}
						skipRatio += 1;
					}
				}

				if (!useAutoskipper) {
					skipRatio = false;
				}
			}


			var xTickStart = options.position === 'right' ? me.left : me.right - tl;
			var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
			var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
			var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;

			helpers.each(me.ticks, function(label, index) {
				// If the callback returned a null or undefined value, do not draw this line
				if (label === undefined || label === null) {
					return;
				}

				var isLastTick = me.ticks.length === index + 1;

				// Since we always show the last tick,we need may need to hide the last shown one before
				var shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);
				if (shouldSkip && !isLastTick || (label === undefined || label === null)) {
					return;
				}

				var lineWidth, lineColor, borderDash, borderDashOffset;
				if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {
					// Draw the first index specially
					lineWidth = gridLines.zeroLineWidth;
					lineColor = gridLines.zeroLineColor;
					borderDash = gridLines.zeroLineBorderDash;
					borderDashOffset = gridLines.zeroLineBorderDashOffset;
				} else {
					lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);
					lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);
					borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
					borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
				}

				// Common properties
				var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
				var textAlign = 'middle';
				var textBaseline = 'middle';

				if (isHorizontal) {

					if (options.position === 'bottom') {
						// bottom
						textBaseline = !isRotated? 'top':'middle';
						textAlign = !isRotated? 'center': 'right';
						labelY = me.top + tl;
					} else {
						// top
						textBaseline = !isRotated? 'bottom':'middle';
						textAlign = !isRotated? 'center': 'left';
						labelY = me.bottom - tl;
					}

					var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines
					labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

					tx1 = tx2 = x1 = x2 = xLineValue;
					ty1 = yTickStart;
					ty2 = yTickEnd;
					y1 = chartArea.top;
					y2 = chartArea.bottom;
				} else {
					var isLeft = options.position === 'left';
					var tickPadding = optionTicks.padding;
					var labelXOffset;

					if (optionTicks.mirror) {
						textAlign = isLeft ? 'left' : 'right';
						labelXOffset = tickPadding;
					} else {
						textAlign = isLeft ? 'right' : 'left';
						labelXOffset = tl + tickPadding;
					}

					labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

					var yLineValue = me.getPixelForTick(index); // xvalues for grid lines
					yLineValue += helpers.aliasPixel(lineWidth);
					labelY = me.getPixelForTick(index, gridLines.offsetGridLines);

					tx1 = xTickStart;
					tx2 = xTickEnd;
					x1 = chartArea.left;
					x2 = chartArea.right;
					ty1 = ty2 = y1 = y2 = yLineValue;
				}

				itemsToDraw.push({
					tx1: tx1,
					ty1: ty1,
					tx2: tx2,
					ty2: ty2,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
					labelX: labelX,
					labelY: labelY,
					glWidth: lineWidth,
					glColor: lineColor,
					glBorderDash: borderDash,
					glBorderDashOffset: borderDashOffset,
					rotation: -1 * labelRotationRadians,
					label: label,
					textBaseline: textBaseline,
					textAlign: textAlign
				});
			});

			// Draw all of the tick labels, tick marks, and grid lines at the correct places
			helpers.each(itemsToDraw, function(itemToDraw) {
				if (gridLines.display) {
					context.save();
					context.lineWidth = itemToDraw.glWidth;
					context.strokeStyle = itemToDraw.glColor;
					if (context.setLineDash) {
						context.setLineDash(itemToDraw.glBorderDash);
						context.lineDashOffset = itemToDraw.glBorderDashOffset;
					}

					context.beginPath();

					if (gridLines.drawTicks) {
						context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
						context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
					}

					if (gridLines.drawOnChartArea) {
						context.moveTo(itemToDraw.x1, itemToDraw.y1);
						context.lineTo(itemToDraw.x2, itemToDraw.y2);
					}

					context.stroke();
					context.restore();
				}

				if (optionTicks.display) {
					context.save();
					context.translate(itemToDraw.labelX, itemToDraw.labelY);
					context.rotate(itemToDraw.rotation);
					context.font = tickFont.font;
					context.textBaseline = itemToDraw.textBaseline;
					context.textAlign = itemToDraw.textAlign;

					var label = itemToDraw.label;
					if (helpers.isArray(label)) {
						for (var i = 0, y = 0; i < label.length; ++i) {
							// We just make sure the multiline element is a string here..
							context.fillText('' + label[i], 0, y);
							// apply same lineSpacing as calculated @ L#320
							y += (tickFont.size * 1.5);
						}
					} else {
						context.fillText(label, 0, 0);
					}
					context.restore();
				}
			});

			if (scaleLabel.display) {
				// Draw the scale label
				var scaleLabelX;
				var scaleLabelY;
				var rotation = 0;

				if (isHorizontal) {
					scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
					scaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);
				} else {
					var isLeft = options.position === 'left';
					scaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);
					scaleLabelY = me.top + ((me.bottom - me.top) / 2);
					rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
				}

				context.save();
				context.translate(scaleLabelX, scaleLabelY);
				context.rotate(rotation);
				context.textAlign = 'center';
				context.textBaseline = 'middle';
				context.fillStyle = scaleLabelFontColor; // render in correct colour
				context.font = scaleLabelFont.font;
				context.fillText(scaleLabel.labelString, 0, 0);
				context.restore();
			}

			if (gridLines.drawBorder) {
				// Draw the line at the edge of the axis
				context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);
				context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);
				var x1 = me.left,
					x2 = me.right,
					y1 = me.top,
					y2 = me.bottom;

				var aliasPixel = helpers.aliasPixel(context.lineWidth);
				if (isHorizontal) {
					y1 = y2 = options.position === 'top' ? me.bottom : me.top;
					y1 += aliasPixel;
					y2 += aliasPixel;
				} else {
					x1 = x2 = options.position === 'left' ? me.right : me.left;
					x1 += aliasPixel;
					x2 += aliasPixel;
				}

				context.beginPath();
				context.moveTo(x1, y1);
				context.lineTo(x2, y2);
				context.stroke();
			}
		}
	});
};

},{}],26:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	Chart.scaleService = {
		// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
		// use the new chart options to grab the correct scale
		constructors: {},
		// Use a registration function so that we can move to an ES6 map when we no longer need to support
		// old browsers

		// Scale config defaults
		defaults: {},
		registerScaleType: function(type, scaleConstructor, defaults) {
			this.constructors[type] = scaleConstructor;
			this.defaults[type] = helpers.clone(defaults);
		},
		getScaleConstructor: function(type) {
			return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
		},
		getScaleDefaults: function(type) {
			// Return the scale defaults merged with the global settings so that we always use the latest ones
			return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};
		},
		updateScaleDefaults: function(type, additions) {
			var defaults = this.defaults;
			if (defaults.hasOwnProperty(type)) {
				defaults[type] = helpers.extend(defaults[type], additions);
			}
		},
		addScalesToLayout: function(chart) {
			// Adds each scale to the chart.boxes array to be sized accordingly
			helpers.each(chart.scales, function(scale) {
				// Set ILayoutItem parameters for backwards compatibility
				scale.fullWidth = scale.options.fullWidth;
				scale.position = scale.options.position;
				scale.weight = scale.options.weight;
				Chart.layoutService.addBox(chart, scale);
			});
		}
	};
};

},{}],27:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	/**
	 * Namespace to hold static tick generation functions
	 * @namespace Chart.Ticks
	 */
	Chart.Ticks = {
		/**
		 * Namespace to hold generators for different types of ticks
		 * @namespace Chart.Ticks.generators
		 */
		generators: {
			/**
			 * Interface for the options provided to the numeric tick generator
			 * @interface INumericTickGenerationOptions
			 */
			/**
			 * The maximum number of ticks to display
			 * @name INumericTickGenerationOptions#maxTicks
			 * @type Number
			 */
			/**
			 * The distance between each tick.
			 * @name INumericTickGenerationOptions#stepSize
			 * @type Number
			 * @optional
			 */
			/**
			 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
			 * @name INumericTickGenerationOptions#min
			 * @type Number
			 * @optional
			 */
			/**
			 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
			 * @name INumericTickGenerationOptions#max
			 * @type Number
			 * @optional
			 */

			/**
			 * Generate a set of linear ticks
			 * @method Chart.Ticks.generators.linear
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
			linear: function(generationOptions, dataRange) {
				var ticks = [];
				// To get a "nice" value for the tick spacing, we will use the appropriately named
				// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
				// for details.

				var spacing;
				if (generationOptions.stepSize && generationOptions.stepSize > 0) {
					spacing = generationOptions.stepSize;
				} else {
					var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
					spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
				}
				var niceMin = Math.floor(dataRange.min / spacing) * spacing;
				var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

				// If min, max and stepSize is set and they make an evenly spaced scale use it.
				if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
					// If very close to our whole number, use it.
					if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
						niceMin = generationOptions.min;
						niceMax = generationOptions.max;
					}
				}

				var numSpaces = (niceMax - niceMin) / spacing;
				// If very close to our rounded value, use it.
				if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
					numSpaces = Math.round(numSpaces);
				} else {
					numSpaces = Math.ceil(numSpaces);
				}

				// Put the values into the ticks array
				ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
				for (var j = 1; j < numSpaces; ++j) {
					ticks.push(niceMin + (j * spacing));
				}
				ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

				return ticks;
			},

			/**
			 * Generate a set of logarithmic ticks
			 * @method Chart.Ticks.generators.logarithmic
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
			logarithmic: function(generationOptions, dataRange) {
				var ticks = [];
				var getValueOrDefault = helpers.getValueOrDefault;

				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph
				var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

				var endExp = Math.floor(helpers.log10(dataRange.max));
				var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
				var exp;
				var significand;

				if (tickVal === 0) {
					exp = Math.floor(helpers.log10(dataRange.minNotZero));
					significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

					ticks.push(tickVal);
					tickVal = significand * Math.pow(10, exp);
				} else {
					exp = Math.floor(helpers.log10(tickVal));
					significand = Math.floor(tickVal / Math.pow(10, exp));
				}

				do {
					ticks.push(tickVal);

					++significand;
					if (significand === 10) {
						significand = 1;
						++exp;
					}

					tickVal = significand * Math.pow(10, exp);
				} while (exp < endExp || (exp === endExp && significand < endSignificand));

				var lastTick = getValueOrDefault(generationOptions.max, tickVal);
				ticks.push(lastTick);

				return ticks;
			}
		},

		/**
		 * Namespace to hold formatters for different types of ticks
		 * @namespace Chart.Ticks.formatters
		 */
		formatters: {
			/**
			 * Formatter for value labels
			 * @method Chart.Ticks.formatters.values
			 * @param value the value to display
			 * @return {String|Array} the label to display
			 */
			values: function(value) {
				return helpers.isArray(value) ? value : '' + value;
			},

			/**
			 * Formatter for linear numeric ticks
			 * @method Chart.Ticks.formatters.linear
			 * @param tickValue {Number} the value to be formatted
			 * @param index {Number} the position of the tickValue parameter in the ticks array
			 * @param ticks {Array<Number>} the list of ticks being converted
			 * @return {String} string representation of the tickValue parameter
			 */
			linear: function(tickValue, index, ticks) {
				// If we have lots of ticks, don't use the ones
				var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

				// If we have a number like 2.5 as the delta, figure out how many decimal places we need
				if (Math.abs(delta) > 1) {
					if (tickValue !== Math.floor(tickValue)) {
						// not an integer
						delta = tickValue - Math.floor(tickValue);
					}
				}

				var logDelta = helpers.log10(Math.abs(delta));
				var tickString = '';

				if (tickValue !== 0) {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				} else {
					tickString = '0'; // never show decimal places for 0
				}

				return tickString;
			},

			logarithmic: function(tickValue, index, ticks) {
				var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

				if (tickValue === 0) {
					return '0';
				} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
					return tickValue.toExponential();
				}
				return '';
			}
		}
	};
};

},{}],28:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	/**
 	 * Helper method to merge the opacity into a color
 	 */
	function mergeOpacity(colorString, opacity) {
		var color = helpers.color(colorString);
		return color.alpha(opacity * color.alpha()).rgbaString();
	}

	Chart.defaults.global.tooltips = {
		enabled: true,
		custom: null,
		mode: 'nearest',
		position: 'average',
		intersect: true,
		backgroundColor: 'rgba(0,0,0,0.8)',
		titleFontStyle: 'bold',
		titleSpacing: 2,
		titleMarginBottom: 6,
		titleFontColor: '#fff',
		titleAlign: 'left',
		bodySpacing: 2,
		bodyFontColor: '#fff',
		bodyAlign: 'left',
		footerFontStyle: 'bold',
		footerSpacing: 2,
		footerMarginTop: 6,
		footerFontColor: '#fff',
		footerAlign: 'left',
		yPadding: 6,
		xPadding: 6,
		caretPadding: 2,
		caretSize: 5,
		cornerRadius: 6,
		multiKeyBackground: '#fff',
		displayColors: true,
		borderColor: 'rgba(0,0,0,0)',
		borderWidth: 0,
		callbacks: {
			// Args are: (tooltipItems, data)
			beforeTitle: helpers.noop,
			title: function(tooltipItems, data) {
				// Pick first xLabel for now
				var title = '';
				var labels = data.labels;
				var labelCount = labels ? labels.length : 0;

				if (tooltipItems.length > 0) {
					var item = tooltipItems[0];

					if (item.xLabel) {
						title = item.xLabel;
					} else if (labelCount > 0 && item.index < labelCount) {
						title = labels[item.index];
					}
				}

				return title;
			},
			afterTitle: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeBody: helpers.noop,

			// Args are: (tooltipItem, data)
			beforeLabel: helpers.noop,
			label: function(tooltipItem, data) {
				var label = data.datasets[tooltipItem.datasetIndex].label || '';

				if (label) {
					label += ': ';
				}
				label += tooltipItem.yLabel;
				return label;
			},
			labelColor: function(tooltipItem, chart) {
				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				return {
					borderColor: view.borderColor,
					backgroundColor: view.backgroundColor
				};
			},
			afterLabel: helpers.noop,

			// Args are: (tooltipItems, data)
			afterBody: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeFooter: helpers.noop,
			footer: helpers.noop,
			afterFooter: helpers.noop
		}
	};

	// Helper to push or concat based on if the 2nd parameter is an array or not
	function pushOrConcat(base, toPush) {
		if (toPush) {
			if (helpers.isArray(toPush)) {
				// base = base.concat(toPush);
				Array.prototype.push.apply(base, toPush);
			} else {
				base.push(toPush);
			}
		}

		return base;
	}

	// Private helper to create a tooltip item model
	// @param element : the chart element (point, arc, bar) to create the tooltip item for
	// @return : new tooltip item
	function createTooltipItem(element) {
		var xScale = element._xScale;
		var yScale = element._yScale || element._scale; // handle radar || polarArea charts
		var index = element._index,
			datasetIndex = element._datasetIndex;

		return {
			xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
			yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
			index: index,
			datasetIndex: datasetIndex,
			x: element._model.x,
			y: element._model.y
		};
	}

	/**
	 * Helper to get the reset model for the tooltip
	 * @param tooltipOpts {Object} the tooltip options
	 */
	function getBaseModel(tooltipOpts) {
		var globalDefaults = Chart.defaults.global;
		var getValueOrDefault = helpers.getValueOrDefault;

		return {
			// Positioning
			xPadding: tooltipOpts.xPadding,
			yPadding: tooltipOpts.yPadding,
			xAlign: tooltipOpts.xAlign,
			yAlign: tooltipOpts.yAlign,

			// Body
			bodyFontColor: tooltipOpts.bodyFontColor,
			_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
			_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
			_bodyAlign: tooltipOpts.bodyAlign,
			bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
			bodySpacing: tooltipOpts.bodySpacing,

			// Title
			titleFontColor: tooltipOpts.titleFontColor,
			_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
			_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
			titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
			_titleAlign: tooltipOpts.titleAlign,
			titleSpacing: tooltipOpts.titleSpacing,
			titleMarginBottom: tooltipOpts.titleMarginBottom,

			// Footer
			footerFontColor: tooltipOpts.footerFontColor,
			_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
			_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
			footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
			_footerAlign: tooltipOpts.footerAlign,
			footerSpacing: tooltipOpts.footerSpacing,
			footerMarginTop: tooltipOpts.footerMarginTop,

			// Appearance
			caretSize: tooltipOpts.caretSize,
			cornerRadius: tooltipOpts.cornerRadius,
			backgroundColor: tooltipOpts.backgroundColor,
			opacity: 0,
			legendColorBackground: tooltipOpts.multiKeyBackground,
			displayColors: tooltipOpts.displayColors,
			borderColor: tooltipOpts.borderColor,
			borderWidth: tooltipOpts.borderWidth
		};
	}

	/**
	 * Get the size of the tooltip
	 */
	function getTooltipSize(tooltip, model) {
		var ctx = tooltip._chart.ctx;

		var height = model.yPadding * 2; // Tooltip Padding
		var width = 0;

		// Count of all lines in the body
		var body = model.body;
		var combinedBodyLength = body.reduce(function(count, bodyItem) {
			return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
		}, 0);
		combinedBodyLength += model.beforeBody.length + model.afterBody.length;

		var titleLineCount = model.title.length;
		var footerLineCount = model.footer.length;
		var titleFontSize = model.titleFontSize,
			bodyFontSize = model.bodyFontSize,
			footerFontSize = model.footerFontSize;

		height += titleLineCount * titleFontSize; // Title Lines
		height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
		height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
		height += combinedBodyLength * bodyFontSize; // Body Lines
		height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
		height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
		height += footerLineCount * (footerFontSize); // Footer Lines
		height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

		// Title width
		var widthPadding = 0;
		var maxLineWidth = function(line) {
			width = Math.max(width, ctx.measureText(line).width + widthPadding);
		};

		ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
		helpers.each(model.title, maxLineWidth);

		// Body width
		ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
		helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

		// Body lines may include some extra width due to the color box
		widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
		helpers.each(body, function(bodyItem) {
			helpers.each(bodyItem.before, maxLineWidth);
			helpers.each(bodyItem.lines, maxLineWidth);
			helpers.each(bodyItem.after, maxLineWidth);
		});

		// Reset back to 0
		widthPadding = 0;

		// Footer width
		ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
		helpers.each(model.footer, maxLineWidth);

		// Add padding
		width += 2 * model.xPadding;

		return {
			width: width,
			height: height
		};
	}

	/**
	 * Helper to get the alignment of a tooltip given the size
	 */
	function determineAlignment(tooltip, size) {
		var model = tooltip._model;
		var chart = tooltip._chart;
		var chartArea = tooltip._chart.chartArea;
		var xAlign = 'center';
		var yAlign = 'center';

		if (model.y < size.height) {
			yAlign = 'top';
		} else if (model.y > (chart.height - size.height)) {
			yAlign = 'bottom';
		}

		var lf, rf; // functions to determine left, right alignment
		var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
		var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
		var midX = (chartArea.left + chartArea.right) / 2;
		var midY = (chartArea.top + chartArea.bottom) / 2;

		if (yAlign === 'center') {
			lf = function(x) {
				return x <= midX;
			};
			rf = function(x) {
				return x > midX;
			};
		} else {
			lf = function(x) {
				return x <= (size.width / 2);
			};
			rf = function(x) {
				return x >= (chart.width - (size.width / 2));
			};
		}

		olf = function(x) {
			return x + size.width > chart.width;
		};
		orf = function(x) {
			return x - size.width < 0;
		};
		yf = function(y) {
			return y <= midY ? 'top' : 'bottom';
		};

		if (lf(model.x)) {
			xAlign = 'left';

			// Is tooltip too wide and goes over the right side of the chart.?
			if (olf(model.x)) {
				xAlign = 'center';
				yAlign = yf(model.y);
			}
		} else if (rf(model.x)) {
			xAlign = 'right';

			// Is tooltip too wide and goes outside left edge of canvas?
			if (orf(model.x)) {
				xAlign = 'center';
				yAlign = yf(model.y);
			}
		}

		var opts = tooltip._options;
		return {
			xAlign: opts.xAlign ? opts.xAlign : xAlign,
			yAlign: opts.yAlign ? opts.yAlign : yAlign
		};
	}

	/**
	 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
	 */
	function getBackgroundPoint(vm, size, alignment) {
		// Background Position
		var x = vm.x;
		var y = vm.y;

		var caretSize = vm.caretSize,
			caretPadding = vm.caretPadding,
			cornerRadius = vm.cornerRadius,
			xAlign = alignment.xAlign,
			yAlign = alignment.yAlign,
			paddingAndSize = caretSize + caretPadding,
			radiusAndPadding = cornerRadius + caretPadding;

		if (xAlign === 'right') {
			x -= size.width;
		} else if (xAlign === 'center') {
			x -= (size.width / 2);
		}

		if (yAlign === 'top') {
			y += paddingAndSize;
		} else if (yAlign === 'bottom') {
			y -= size.height + paddingAndSize;
		} else {
			y -= (size.height / 2);
		}

		if (yAlign === 'center') {
			if (xAlign === 'left') {
				x += paddingAndSize;
			} else if (xAlign === 'right') {
				x -= paddingAndSize;
			}
		} else if (xAlign === 'left') {
			x -= radiusAndPadding;
		} else if (xAlign === 'right') {
			x += radiusAndPadding;
		}

		return {
			x: x,
			y: y
		};
	}

	Chart.Tooltip = Chart.Element.extend({
		initialize: function() {
			this._model = getBaseModel(this._options);
		},

		// Get the title
		// Args are: (tooltipItem, data)
		getTitle: function() {
			var me = this;
			var opts = me._options;
			var callbacks = opts.callbacks;

			var beforeTitle = callbacks.beforeTitle.apply(me, arguments),
				title = callbacks.title.apply(me, arguments),
				afterTitle = callbacks.afterTitle.apply(me, arguments);

			var lines = [];
			lines = pushOrConcat(lines, beforeTitle);
			lines = pushOrConcat(lines, title);
			lines = pushOrConcat(lines, afterTitle);

			return lines;
		},

		// Args are: (tooltipItem, data)
		getBeforeBody: function() {
			var lines = this._options.callbacks.beforeBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Args are: (tooltipItem, data)
		getBody: function(tooltipItems, data) {
			var me = this;
			var callbacks = me._options.callbacks;
			var bodyItems = [];

			helpers.each(tooltipItems, function(tooltipItem) {
				var bodyItem = {
					before: [],
					lines: [],
					after: []
				};
				pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

				bodyItems.push(bodyItem);
			});

			return bodyItems;
		},

		// Args are: (tooltipItem, data)
		getAfterBody: function() {
			var lines = this._options.callbacks.afterBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Get the footer and beforeFooter and afterFooter lines
		// Args are: (tooltipItem, data)
		getFooter: function() {
			var me = this;
			var callbacks = me._options.callbacks;

			var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
			var footer = callbacks.footer.apply(me, arguments);
			var afterFooter = callbacks.afterFooter.apply(me, arguments);

			var lines = [];
			lines = pushOrConcat(lines, beforeFooter);
			lines = pushOrConcat(lines, footer);
			lines = pushOrConcat(lines, afterFooter);

			return lines;
		},

		update: function(changed) {
			var me = this;
			var opts = me._options;

			// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
			// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
			// which breaks any animations.
			var existingModel = me._model;
			var model = me._model = getBaseModel(opts);
			var active = me._active;

			var data = me._data;

			// In the case where active.length === 0 we need to keep these at existing values for good animations
			var alignment = {
				xAlign: existingModel.xAlign,
				yAlign: existingModel.yAlign
			};
			var backgroundPoint = {
				x: existingModel.x,
				y: existingModel.y
			};
			var tooltipSize = {
				width: existingModel.width,
				height: existingModel.height
			};
			var tooltipPosition = {
				x: existingModel.caretX,
				y: existingModel.caretY
			};

			var i, len;

			if (active.length) {
				model.opacity = 1;

				var labelColors = [];
				tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);

				var tooltipItems = [];
				for (i = 0, len = active.length; i < len; ++i) {
					tooltipItems.push(createTooltipItem(active[i]));
				}

				// If the user provided a filter function, use it to modify the tooltip items
				if (opts.filter) {
					tooltipItems = tooltipItems.filter(function(a) {
						return opts.filter(a, data);
					});
				}

				// If the user provided a sorting function, use it to modify the tooltip items
				if (opts.itemSort) {
					tooltipItems = tooltipItems.sort(function(a, b) {
						return opts.itemSort(a, b, data);
					});
				}

				// Determine colors for boxes
				helpers.each(tooltipItems, function(tooltipItem) {
					labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
				});

				// Build the Text Lines
				model.title = me.getTitle(tooltipItems, data);
				model.beforeBody = me.getBeforeBody(tooltipItems, data);
				model.body = me.getBody(tooltipItems, data);
				model.afterBody = me.getAfterBody(tooltipItems, data);
				model.footer = me.getFooter(tooltipItems, data);

				// Initial positioning and colors
				model.x = Math.round(tooltipPosition.x);
				model.y = Math.round(tooltipPosition.y);
				model.caretPadding = opts.caretPadding;
				model.labelColors = labelColors;

				// data points
				model.dataPoints = tooltipItems;

				// We need to determine alignment of the tooltip
				tooltipSize = getTooltipSize(this, model);
				alignment = determineAlignment(this, tooltipSize);
				// Final Size and Position
				backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
			} else {
				model.opacity = 0;
			}

			model.xAlign = alignment.xAlign;
			model.yAlign = alignment.yAlign;
			model.x = backgroundPoint.x;
			model.y = backgroundPoint.y;
			model.width = tooltipSize.width;
			model.height = tooltipSize.height;

			// Point where the caret on the tooltip points to
			model.caretX = tooltipPosition.x;
			model.caretY = tooltipPosition.y;

			me._model = model;

			if (changed && opts.custom) {
				opts.custom.call(me, model);
			}

			return me;
		},
		drawCaret: function(tooltipPoint, size) {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

			ctx.lineTo(caretPosition.x1, caretPosition.y1);
			ctx.lineTo(caretPosition.x2, caretPosition.y2);
			ctx.lineTo(caretPosition.x3, caretPosition.y3);
		},
		getCaretPosition: function(tooltipPoint, size, vm) {
			var x1, x2, x3;
			var y1, y2, y3;
			var caretSize = vm.caretSize;
			var cornerRadius = vm.cornerRadius;
			var xAlign = vm.xAlign,
				yAlign = vm.yAlign;
			var ptX = tooltipPoint.x,
				ptY = tooltipPoint.y;
			var width = size.width,
				height = size.height;

			if (yAlign === 'center') {
				y2 = ptY + (height / 2);

				if (xAlign === 'left') {
					x1 = ptX;
					x2 = x1 - caretSize;
					x3 = x1;

					y1 = y2 + caretSize;
					y3 = y2 - caretSize;
				} else {
					x1 = ptX + width;
					x2 = x1 + caretSize;
					x3 = x1;

					y1 = y2 - caretSize;
					y3 = y2 + caretSize;
				}
			} else {
				if (xAlign === 'left') {
					x2 = ptX + cornerRadius + (caretSize);
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				} else if (xAlign === 'right') {
					x2 = ptX + width - cornerRadius - caretSize;
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				} else {
					x2 = ptX + (width / 2);
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				}
				if (yAlign === 'top') {
					y1 = ptY;
					y2 = y1 - caretSize;
					y3 = y1;
				} else {
					y1 = ptY + height;
					y2 = y1 + caretSize;
					y3 = y1;
					// invert drawing order
					var tmp = x3;
					x3 = x1;
					x1 = tmp;
				}
			}
			return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
		},
		drawTitle: function(pt, vm, ctx, opacity) {
			var title = vm.title;

			if (title.length) {
				ctx.textAlign = vm._titleAlign;
				ctx.textBaseline = 'top';

				var titleFontSize = vm.titleFontSize,
					titleSpacing = vm.titleSpacing;

				ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
				ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

				var i, len;
				for (i = 0, len = title.length; i < len; ++i) {
					ctx.fillText(title[i], pt.x, pt.y);
					pt.y += titleFontSize + titleSpacing; // Line Height and spacing

					if (i + 1 === title.length) {
						pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
					}
				}
			}
		},
		drawBody: function(pt, vm, ctx, opacity) {
			var bodyFontSize = vm.bodyFontSize;
			var bodySpacing = vm.bodySpacing;
			var body = vm.body;

			ctx.textAlign = vm._bodyAlign;
			ctx.textBaseline = 'top';

			var textColor = mergeOpacity(vm.bodyFontColor, opacity);
			ctx.fillStyle = textColor;
			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

			// Before Body
			var xLinePadding = 0;
			var fillLineOfText = function(line) {
				ctx.fillText(line, pt.x + xLinePadding, pt.y);
				pt.y += bodyFontSize + bodySpacing;
			};

			// Before body lines
			helpers.each(vm.beforeBody, fillLineOfText);

			var drawColorBoxes = vm.displayColors;
			xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

			// Draw body lines now
			helpers.each(body, function(bodyItem, i) {
				helpers.each(bodyItem.before, fillLineOfText);

				helpers.each(bodyItem.lines, function(line) {
					// Draw Legend-like boxes if needed
					if (drawColorBoxes) {
						// Fill a white rect so that colours merge nicely if the opacity is < 1
						ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
						ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Border
						ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
						ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Inner square
						ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
						ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);

						ctx.fillStyle = textColor;
					}

					fillLineOfText(line);
				});

				helpers.each(bodyItem.after, fillLineOfText);
			});

			// Reset back to 0 for after body
			xLinePadding = 0;

			// After body lines
			helpers.each(vm.afterBody, fillLineOfText);
			pt.y -= bodySpacing; // Remove last body spacing
		},
		drawFooter: function(pt, vm, ctx, opacity) {
			var footer = vm.footer;

			if (footer.length) {
				pt.y += vm.footerMarginTop;

				ctx.textAlign = vm._footerAlign;
				ctx.textBaseline = 'top';

				ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
				ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

				helpers.each(footer, function(line) {
					ctx.fillText(line, pt.x, pt.y);
					pt.y += vm.footerFontSize + vm.footerSpacing;
				});
			}
		},
		drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
			ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
			ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
			ctx.lineWidth = vm.borderWidth;
			var xAlign = vm.xAlign;
			var yAlign = vm.yAlign;
			var x = pt.x;
			var y = pt.y;
			var width = tooltipSize.width;
			var height = tooltipSize.height;
			var radius = vm.cornerRadius;

			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			if (yAlign === 'top') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + width - radius, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
			if (yAlign === 'center' && xAlign === 'right') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + width, y + height - radius);
			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			if (yAlign === 'bottom') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + radius, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
			if (yAlign === 'center' && xAlign === 'left') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x, y + radius);
			ctx.quadraticCurveTo(x, y, x + radius, y);
			ctx.closePath();

			ctx.fill();

			if (vm.borderWidth > 0) {
				ctx.stroke();
			}
		},
		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;

			if (vm.opacity === 0) {
				return;
			}

			var tooltipSize = {
				width: vm.width,
				height: vm.height
			};
			var pt = {
				x: vm.x,
				y: vm.y
			};

			// IE11/Edge does not like very small opacities, so snap to 0
			var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

			// Truthy/falsey value for empty tooltip
			var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

			if (this._options.enabled && hasTooltipContent) {
				// Draw Background
				this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

				// Draw Title, Body, and Footer
				pt.x += vm.xPadding;
				pt.y += vm.yPadding;

				// Titles
				this.drawTitle(pt, vm, ctx, opacity);

				// Body
				this.drawBody(pt, vm, ctx, opacity);

				// Footer
				this.drawFooter(pt, vm, ctx, opacity);
			}
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event - The event to handle
		 * @returns {Boolean} true if the tooltip changed
		 */
		handleEvent: function(e) {
			var me = this;
			var options = me._options;
			var changed = false;

			me._lastActive = me._lastActive || [];

			// Find Active Elements for tooltips
			if (e.type === 'mouseout') {
				me._active = [];
			} else {
				me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
			}

			// Remember Last Actives
			changed = !helpers.arrayEquals(me._active, me._lastActive);

			// If tooltip didn't change, do not handle the target event
			if (!changed) {
				return false;
			}

			me._lastActive = me._active;

			if (options.enabled || options.custom) {
				me._eventPosition = {
					x: e.x,
					y: e.y
				};

				var model = me._model;
				me.update(true);
				me.pivot();

				// See if our tooltip position changed
				changed |= (model.x !== me._model.x) || (model.y !== me._model.y);
			}

			return changed;
		}
	});

	/**
	 * @namespace Chart.Tooltip.positioners
	 */
	Chart.Tooltip.positioners = {
		/**
		 * Average mode places the tooltip at the average position of the elements shown
		 * @function Chart.Tooltip.positioners.average
		 * @param elements {ChartElement[]} the elements being displayed in the tooltip
		 * @returns {Point} tooltip position
		 */
		average: function(elements) {
			if (!elements.length) {
				return false;
			}

			var i, len;
			var x = 0;
			var y = 0;
			var count = 0;

			for (i = 0, len = elements.length; i < len; ++i) {
				var el = elements[i];
				if (el && el.hasValue()) {
					var pos = el.tooltipPosition();
					x += pos.x;
					y += pos.y;
					++count;
				}
			}

			return {
				x: Math.round(x / count),
				y: Math.round(y / count)
			};
		},

		/**
		 * Gets the tooltip position nearest of the item nearest to the event position
		 * @function Chart.Tooltip.positioners.nearest
		 * @param elements {Chart.Element[]} the tooltip elements
		 * @param eventPosition {Point} the position of the event in canvas coordinates
		 * @returns {Point} the tooltip position
		 */
		nearest: function(elements, eventPosition) {
			var x = eventPosition.x;
			var y = eventPosition.y;

			var nearestElement;
			var minDistance = Number.POSITIVE_INFINITY;
			var i, len;
			for (i = 0, len = elements.length; i < len; ++i) {
				var el = elements[i];
				if (el && el.hasValue()) {
					var center = el.getCenterPoint();
					var d = helpers.distanceBetweenPoints(eventPosition, center);

					if (d < minDistance) {
						minDistance = d;
						nearestElement = el;
					}
				}
			}

			if (nearestElement) {
				var tp = nearestElement.tooltipPosition();
				x = tp.x;
				y = tp.y;
			}

			return {
				x: x,
				y: y
			};
		}
	};
};

},{}],29:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers,
		globalOpts = Chart.defaults.global;

	globalOpts.elements.arc = {
		backgroundColor: globalOpts.defaultColor,
		borderColor: '#fff',
		borderWidth: 2
	};

	Chart.elements.Arc = Chart.Element.extend({
		inLabelRange: function(mouseX) {
			var vm = this._view;

			if (vm) {
				return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
			}
			return false;
		},
		inRange: function(chartX, chartY) {
			var vm = this._view;

			if (vm) {
				var pointRelativePosition = helpers.getAngleFromPoint(vm, {
						x: chartX,
						y: chartY
					}),
					angle = pointRelativePosition.angle,
					distance = pointRelativePosition.distance;

				// Sanitise angle range
				var startAngle = vm.startAngle;
				var endAngle = vm.endAngle;
				while (endAngle < startAngle) {
					endAngle += 2.0 * Math.PI;
				}
				while (angle > endAngle) {
					angle -= 2.0 * Math.PI;
				}
				while (angle < startAngle) {
					angle += 2.0 * Math.PI;
				}

				// Check if within the range of the open/close angle
				var betweenAngles = (angle >= startAngle && angle <= endAngle),
					withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

				return (betweenAngles && withinRadius);
			}
			return false;
		},
		getCenterPoint: function() {
			var vm = this._view;
			var halfAngle = (vm.startAngle + vm.endAngle) / 2;
			var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
			return {
				x: vm.x + Math.cos(halfAngle) * halfRadius,
				y: vm.y + Math.sin(halfAngle) * halfRadius
			};
		},
		getArea: function() {
			var vm = this._view;
			return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
		},
		tooltipPosition: function() {
			var vm = this._view;

			var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),
				rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
			return {
				x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
				y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},
		draw: function() {

			var ctx = this._chart.ctx,
				vm = this._view,
				sA = vm.startAngle,
				eA = vm.endAngle;

			ctx.beginPath();

			ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
			ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

			ctx.closePath();
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = vm.borderWidth;

			ctx.fillStyle = vm.backgroundColor;

			ctx.fill();
			ctx.lineJoin = 'bevel';

			if (vm.borderWidth) {
				ctx.stroke();
			}
		}
	});
};

},{}],30:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var globalDefaults = Chart.defaults.global;

	Chart.defaults.global.elements.line = {
		tension: 0.4,
		backgroundColor: globalDefaults.defaultColor,
		borderWidth: 3,
		borderColor: globalDefaults.defaultColor,
		borderCapStyle: 'butt',
		borderDash: [],
		borderDashOffset: 0.0,
		borderJoinStyle: 'miter',
		capBezierPoints: true,
		fill: true, // do we fill in the area between the line and its base axis
	};

	Chart.elements.Line = Chart.Element.extend({
		draw: function() {
			var me = this;
			var vm = me._view;
			var ctx = me._chart.ctx;
			var spanGaps = vm.spanGaps;
			var points = me._children.slice(); // clone array
			var globalOptionLineElements = globalDefaults.elements.line;
			var lastDrawnIndex = -1;
			var index, current, previous, currentVM;

			// If we are looping, adding the first point again
			if (me._loop && points.length) {
				points.push(points[0]);
			}

			ctx.save();

			// Stroke Line Options
			ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

			// IE 9 and 10 do not support line dash
			if (ctx.setLineDash) {
				ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
			}

			ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
			ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
			ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
			ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

			// Stroke Line
			ctx.beginPath();
			lastDrawnIndex = -1;

			for (index = 0; index < points.length; ++index) {
				current = points[index];
				previous = helpers.previousItem(points, index);
				currentVM = current._view;

				// First point moves to it's starting position no matter what
				if (index === 0) {
					if (!currentVM.skip) {
						ctx.moveTo(currentVM.x, currentVM.y);
						lastDrawnIndex = index;
					}
				} else {
					previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

					if (!currentVM.skip) {
						if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
							// There was a gap and this is the first point after the gap
							ctx.moveTo(currentVM.x, currentVM.y);
						} else {
							// Line to next point
							helpers.canvas.lineTo(ctx, previous._view, current._view);
						}
						lastDrawnIndex = index;
					}
				}
			}

			ctx.stroke();
			ctx.restore();
		}
	});
};

},{}],31:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers,
		globalOpts = Chart.defaults.global,
		defaultColor = globalOpts.defaultColor;

	globalOpts.elements.point = {
		radius: 3,
		pointStyle: 'circle',
		backgroundColor: defaultColor,
		borderWidth: 1,
		borderColor: defaultColor,
		// Hover
		hitRadius: 1,
		hoverRadius: 4,
		hoverBorderWidth: 1
	};

	function xRange(mouseX) {
		var vm = this._view;
		return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
	}

	function yRange(mouseY) {
		var vm = this._view;
		return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
	}

	Chart.elements.Point = Chart.Element.extend({
		inRange: function(mouseX, mouseY) {
			var vm = this._view;
			return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
		},

		inLabelRange: xRange,
		inXRange: xRange,
		inYRange: yRange,

		getCenterPoint: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		},
		getArea: function() {
			return Math.PI * Math.pow(this._view.radius, 2);
		},
		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y,
				padding: vm.radius + vm.borderWidth
			};
		},
		draw: function(chartArea) {
			var vm = this._view;
			var model = this._model;
			var ctx = this._chart.ctx;
			var pointStyle = vm.pointStyle;
			var radius = vm.radius;
			var x = vm.x;
			var y = vm.y;
			var color = Chart.helpers.color;
			var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
			var ratio = 0;

			if (vm.skip) {
				return;
			}

			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;

			// Cliping for Points.
			// going out from inner charArea?
			if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {
				// Point fade out
				if (model.x < chartArea.left) {
					ratio = (x - model.x) / (chartArea.left - model.x);
				} else if (chartArea.right*errMargin < model.x) {
					ratio = (model.x - x) / (model.x - chartArea.right);
				} else if (model.y < chartArea.top) {
					ratio = (y - model.y) / (chartArea.top - model.y);
				} else if (chartArea.bottom*errMargin < model.y) {
					ratio = (model.y - y) / (model.y - chartArea.bottom);
				}
				ratio = Math.round(ratio*100) / 100;
				ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
				ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
			}

			Chart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);
		}
	});
};

},{}],32:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var globalOpts = Chart.defaults.global;

	globalOpts.elements.rectangle = {
		backgroundColor: globalOpts.defaultColor,
		borderWidth: 0,
		borderColor: globalOpts.defaultColor,
		borderSkipped: 'bottom'
	};

	function isVertical(bar) {
		return bar._view.width !== undefined;
	}

	/**
	 * Helper function to get the bounds of the bar regardless of the orientation
	 * @private
	 * @param bar {Chart.Element.Rectangle} the bar
	 * @return {Bounds} bounds of the bar
	 */
	function getBarBounds(bar) {
		var vm = bar._view;
		var x1, x2, y1, y2;

		if (isVertical(bar)) {
			// vertical
			var halfWidth = vm.width / 2;
			x1 = vm.x - halfWidth;
			x2 = vm.x + halfWidth;
			y1 = Math.min(vm.y, vm.base);
			y2 = Math.max(vm.y, vm.base);
		} else {
			// horizontal bar
			var halfHeight = vm.height / 2;
			x1 = Math.min(vm.x, vm.base);
			x2 = Math.max(vm.x, vm.base);
			y1 = vm.y - halfHeight;
			y2 = vm.y + halfHeight;
		}

		return {
			left: x1,
			top: y1,
			right: x2,
			bottom: y2
		};
	}

	Chart.elements.Rectangle = Chart.Element.extend({
		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var left, right, top, bottom, signX, signY, borderSkipped;
			var borderWidth = vm.borderWidth;

			if (!vm.horizontal) {
				// bar
				left = vm.x - vm.width / 2;
				right = vm.x + vm.width / 2;
				top = vm.y;
				bottom = vm.base;
				signX = 1;
				signY = bottom > top? 1: -1;
				borderSkipped = vm.borderSkipped || 'bottom';
			} else {
				// horizontal bar
				left = vm.base;
				right = vm.x;
				top = vm.y - vm.height / 2;
				bottom = vm.y + vm.height / 2;
				signX = right > left? 1: -1;
				signY = 1;
				borderSkipped = vm.borderSkipped || 'left';
			}

			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (borderWidth) {
				// borderWidth shold be less than bar width and bar height.
				var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
				borderWidth = borderWidth > barSize? barSize: borderWidth;
				var halfStroke = borderWidth / 2;
				// Adjust borderWidth when bar top position is near vm.base(zero).
				var borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);
				var borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);
				var borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);
				var borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);
				// not become a vertical line?
				if (borderLeft !== borderRight) {
					top = borderTop;
					bottom = borderBottom;
				}
				// not become a horizontal line?
				if (borderTop !== borderBottom) {
					left = borderLeft;
					right = borderRight;
				}
			}

			ctx.beginPath();
			ctx.fillStyle = vm.backgroundColor;
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = borderWidth;

			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners = [
				[left, bottom],
				[left, top],
				[right, top],
				[right, bottom]
			];

			// Find first (starting) corner with fallback to 'bottom'
			var borders = ['bottom', 'left', 'top', 'right'];
			var startCorner = borders.indexOf(borderSkipped, 0);
			if (startCorner === -1) {
				startCorner = 0;
			}

			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}

			// Draw rectangle from 'startCorner'
			var corner = cornerAt(0);
			ctx.moveTo(corner[0], corner[1]);

			for (var i = 1; i < 4; i++) {
				corner = cornerAt(i);
				ctx.lineTo(corner[0], corner[1]);
			}

			ctx.fill();
			if (borderWidth) {
				ctx.stroke();
			}
		},
		height: function() {
			var vm = this._view;
			return vm.base - vm.y;
		},
		inRange: function(mouseX, mouseY) {
			var inRange = false;

			if (this._view) {
				var bounds = getBarBounds(this);
				inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},
		inLabelRange: function(mouseX, mouseY) {
			var me = this;
			if (!me._view) {
				return false;
			}

			var inRange = false;
			var bounds = getBarBounds(me);

			if (isVertical(me)) {
				inRange = mouseX >= bounds.left && mouseX <= bounds.right;
			} else {
				inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},
		inXRange: function(mouseX) {
			var bounds = getBarBounds(this);
			return mouseX >= bounds.left && mouseX <= bounds.right;
		},
		inYRange: function(mouseY) {
			var bounds = getBarBounds(this);
			return mouseY >= bounds.top && mouseY <= bounds.bottom;
		},
		getCenterPoint: function() {
			var vm = this._view;
			var x, y;
			if (isVertical(this)) {
				x = vm.x;
				y = (vm.y + vm.base) / 2;
			} else {
				x = (vm.x + vm.base) / 2;
				y = vm.y;
			}

			return {x: x, y: y};
		},
		getArea: function() {
			var vm = this._view;
			return vm.width * Math.abs(vm.y - vm.base);
		},
		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});

};

},{}],33:[function(require,module,exports){
'use strict';

// Chart.Platform implementation for targeting a web browser
module.exports = function(Chart) {
	var helpers = Chart.helpers;

	// DOM event types -> Chart.js event types.
	// Note: only events with different types are mapped.
	// https://developer.mozilla.org/en-US/docs/Web/Events
	var eventTypeMap = {
		// Touch events
		touchstart: 'mousedown',
		touchmove: 'mousemove',
		touchend: 'mouseup',

		// Pointer events
		pointerenter: 'mouseenter',
		pointerdown: 'mousedown',
		pointermove: 'mousemove',
		pointerup: 'mouseup',
		pointerleave: 'mouseout',
		pointerout: 'mouseout'
	};

	/**
	 * The "used" size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of `element` but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * `element` has a size relative to its parent and this last one is not yet displayed,
	 * for example because of `display: none` on a parent node.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns {Number} Size in pixels or undefined if unknown.
	 */
	function readUsedSize(element, property) {
		var value = helpers.getStyle(element, property);
		var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
		return matches? Number(matches[1]) : undefined;
	}

	/**
	 * Initializes the canvas style and render size without modifying the canvas display size,
	 * since responsiveness is handled by the controller.resize() method. The config is used
	 * to determine the aspect ratio to apply in case no explicit height has been specified.
	 */
	function initCanvas(canvas, config) {
		var style = canvas.style;

		// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
		// returns null or '' if no explicit value has been set to the canvas attribute.
		var renderHeight = canvas.getAttribute('height');
		var renderWidth = canvas.getAttribute('width');

		// Chart.js modifies some canvas values that we want to restore on destroy
		canvas._chartjs = {
			initial: {
				height: renderHeight,
				width: renderWidth,
				style: {
					display: style.display,
					height: style.height,
					width: style.width
				}
			}
		};

		// Force canvas to display as block to avoid extra space caused by inline
		// elements, which would interfere with the responsive resize process.
		// https://github.com/chartjs/Chart.js/issues/2538
		style.display = style.display || 'block';

		if (renderWidth === null || renderWidth === '') {
			var displayWidth = readUsedSize(canvas, 'width');
			if (displayWidth !== undefined) {
				canvas.width = displayWidth;
			}
		}

		if (renderHeight === null || renderHeight === '') {
			if (canvas.style.height === '') {
				// If no explicit render height and style height, let's apply the aspect ratio,
				// which one can be specified by the user but also by charts as default option
				// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
				canvas.height = canvas.width / (config.options.aspectRatio || 2);
			} else {
				var displayHeight = readUsedSize(canvas, 'height');
				if (displayWidth !== undefined) {
					canvas.height = displayHeight;
				}
			}
		}

		return canvas;
	}

	function createEvent(type, chart, x, y, nativeEvent) {
		return {
			type: type,
			chart: chart,
			native: nativeEvent || null,
			x: x !== undefined? x : null,
			y: y !== undefined? y : null,
		};
	}

	function fromNativeEvent(event, chart) {
		var type = eventTypeMap[event.type] || event.type;
		var pos = helpers.getRelativePosition(event, chart);
		return createEvent(type, chart, pos.x, pos.y, event);
	}

	function createResizer(handler) {
		var iframe = document.createElement('iframe');
		iframe.className = 'chartjs-hidden-iframe';
		iframe.style.cssText =
			'display:block;'+
			'overflow:hidden;'+
			'border:0;'+
			'margin:0;'+
			'top:0;'+
			'left:0;'+
			'bottom:0;'+
			'right:0;'+
			'height:100%;'+
			'width:100%;'+
			'position:absolute;'+
			'pointer-events:none;'+
			'z-index:-1;';

		// Prevent the iframe to gain focus on tab.
		// https://github.com/chartjs/Chart.js/issues/3090
		iframe.tabIndex = -1;

		// If the iframe is re-attached to the DOM, the resize listener is removed because the
		// content is reloaded, so make sure to install the handler after the iframe is loaded.
		// https://github.com/chartjs/Chart.js/issues/3521
		helpers.addEvent(iframe, 'load', function() {
			helpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);

			// The iframe size might have changed while loading, which can also
			// happen if the size has been changed while detached from the DOM.
			handler();
		});

		return iframe;
	}

	function addResizeListener(node, listener, chart) {
		var stub = node._chartjs = {
			ticking: false
		};

		// Throttle the callback notification until the next animation frame.
		var notify = function() {
			if (!stub.ticking) {
				stub.ticking = true;
				helpers.requestAnimFrame.call(window, function() {
					if (stub.resizer) {
						stub.ticking = false;
						return listener(createEvent('resize', chart));
					}
				});
			}
		};

		// Let's keep track of this added iframe and thus avoid DOM query when removing it.
		stub.resizer = createResizer(notify);

		node.insertBefore(stub.resizer, node.firstChild);
	}

	function removeResizeListener(node) {
		if (!node || !node._chartjs) {
			return;
		}

		var resizer = node._chartjs.resizer;
		if (resizer) {
			resizer.parentNode.removeChild(resizer);
			node._chartjs.resizer = null;
		}

		delete node._chartjs;
	}

	return {
		acquireContext: function(item, config) {
			if (typeof item === 'string') {
				item = document.getElementById(item);
			} else if (item.length) {
				// Support for array based queries (such as jQuery)
				item = item[0];
			}

			if (item && item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item = item.canvas;
			}

			// To prevent canvas fingerprinting, some add-ons undefine the getContext
			// method, for example: https://github.com/kkapsner/CanvasBlocker
			// https://github.com/chartjs/Chart.js/issues/2807
			var context = item && item.getContext && item.getContext('2d');

			// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
			// inside an iframe or when running in a protected environment. We could guess the
			// types from their toString() value but let's keep things flexible and assume it's
			// a sufficient condition if the item has a context2D which has item as `canvas`.
			// https://github.com/chartjs/Chart.js/issues/3887
			// https://github.com/chartjs/Chart.js/issues/4102
			// https://github.com/chartjs/Chart.js/issues/4152
			if (context && context.canvas === item) {
				initCanvas(item, config);
				return context;
			}

			return null;
		},

		releaseContext: function(context) {
			var canvas = context.canvas;
			if (!canvas._chartjs) {
				return;
			}

			var initial = canvas._chartjs.initial;
			['height', 'width'].forEach(function(prop) {
				var value = initial[prop];
				if (value === undefined || value === null) {
					canvas.removeAttribute(prop);
				} else {
					canvas.setAttribute(prop, value);
				}
			});

			helpers.each(initial.style || {}, function(value, key) {
				canvas.style[key] = value;
			});

			// The canvas render size might have been changed (and thus the state stack discarded),
			// we can't use save() and restore() to restore the initial state. So make sure that at
			// least the canvas context is reset to the default state by setting the canvas width.
			// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
			canvas.width = canvas.width;

			delete canvas._chartjs;
		},

		addEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === 'resize') {
				// Note: the resize event is not supported on all browsers.
				addResizeListener(canvas.parentNode, listener, chart);
				return;
			}

			var stub = listener._chartjs || (listener._chartjs = {});
			var proxies = stub.proxies || (stub.proxies = {});
			var proxy = proxies[chart.id + '_' + type] = function(event) {
				listener(fromNativeEvent(event, chart));
			};

			helpers.addEvent(canvas, type, proxy);
		},

		removeEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === 'resize') {
				// Note: the resize event is not supported on all browsers.
				removeResizeListener(canvas.parentNode, listener);
				return;
			}

			var stub = listener._chartjs || {};
			var proxies = stub.proxies || {};
			var proxy = proxies[chart.id + '_' + type];
			if (!proxy) {
				return;
			}

			helpers.removeEvent(canvas, type, proxy);
		}
	};
};

},{}],34:[function(require,module,exports){
'use strict';

// By default, select the browser (DOM) platform.
// @TODO Make possible to select another platform at build time.
var implementation = require('./platform.dom.js');

module.exports = function(Chart) {
	/**
	 * @namespace Chart.platform
	 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
	 * @since 2.4.0
	 */
	Chart.platform = {
		/**
		 * Called at chart construction time, returns a context2d instance implementing
		 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
		 * @param {*} item - The native item from which to acquire context (platform specific)
		 * @param {Object} options - The chart options
		 * @returns {CanvasRenderingContext2D} context2d instance
		 */
		acquireContext: function() {},

		/**
		 * Called at chart destruction time, releases any resources associated to the context
		 * previously returned by the acquireContext() method.
		 * @param {CanvasRenderingContext2D} context - The context2d instance
		 * @returns {Boolean} true if the method succeeded, else false
		 */
		releaseContext: function() {},

		/**
		 * Registers the specified listener on the given chart.
		 * @param {Chart} chart - Chart from which to listen for event
		 * @param {String} type - The ({@link IEvent}) type to listen for
		 * @param {Function} listener - Receives a notification (an object that implements
		 * the {@link IEvent} interface) when an event of the specified type occurs.
		 */
		addEventListener: function() {},

		/**
		 * Removes the specified listener previously registered with addEventListener.
		 * @param {Chart} chart -Chart from which to remove the listener
		 * @param {String} type - The ({@link IEvent}) type to remove
		 * @param {Function} listener - The listener function to remove from the event target.
		 */
		removeEventListener: function() {}
	};

	/**
	 * @interface IPlatform
	 * Allows abstracting platform dependencies away from the chart
	 * @borrows Chart.platform.acquireContext as acquireContext
	 * @borrows Chart.platform.releaseContext as releaseContext
	 * @borrows Chart.platform.addEventListener as addEventListener
	 * @borrows Chart.platform.removeEventListener as removeEventListener
	 */

	/**
	 * @interface IEvent
	 * @prop {String} type - The event type name, possible values are:
	 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
	 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
	 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
	 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
	 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
	 */

	Chart.helpers.extend(Chart.platform, implementation(Chart));
};

},{"./platform.dom.js":33}],35:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {
	/**
	 * Plugin based on discussion from the following Chart.js issues:
	 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
	 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
	 */
	Chart.defaults.global.plugins.filler = {
		propagate: true
	};

	var defaults = Chart.defaults;
	var helpers = Chart.helpers;
	var mappers = {
		dataset: function(source) {
			var index = source.fill;
			var chart = source.chart;
			var meta = chart.getDatasetMeta(index);
			var visible = meta && chart.isDatasetVisible(index);
			var points = (visible && meta.dataset._children) || [];

			return !points.length? null : function(point, i) {
				return points[i]._view || null;
			};
		},

		boundary: function(source) {
			var boundary = source.boundary;
			var x = boundary? boundary.x : null;
			var y = boundary? boundary.y : null;

			return function(point) {
				return {
					x: x === null? point.x : x,
					y: y === null? point.y : y,
				};
			};
		}
	};

	// @todo if (fill[0] === '#')
	function decodeFill(el, index, count) {
		var model = el._model || {};
		var fill = model.fill;
		var target;

		if (fill === undefined) {
			fill = !!model.backgroundColor;
		}

		if (fill === false || fill === null) {
			return false;
		}

		if (fill === true) {
			return 'origin';
		}

		target = parseFloat(fill, 10);
		if (isFinite(target) && Math.floor(target) === target) {
			if (fill[0] === '-' || fill[0] === '+') {
				target = index + target;
			}

			if (target === index || target < 0 || target >= count) {
				return false;
			}

			return target;
		}

		switch (fill) {
		// compatibility
		case 'bottom':
			return 'start';
		case 'top':
			return 'end';
		case 'zero':
			return 'origin';
		// supported boundaries
		case 'origin':
		case 'start':
		case 'end':
			return fill;
		// invalid fill values
		default:
			return false;
		}
	}

	function computeBoundary(source) {
		var model = source.el._model || {};
		var scale = source.el._scale || {};
		var fill = source.fill;
		var target = null;
		var horizontal;

		if (isFinite(fill)) {
			return null;
		}

		// Backward compatibility: until v3, we still need to support boundary values set on
		// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
		// controllers might still use it (e.g. the Smith chart).

		if (fill === 'start') {
			target = model.scaleBottom === undefined? scale.bottom : model.scaleBottom;
		} else if (fill === 'end') {
			target = model.scaleTop === undefined? scale.top : model.scaleTop;
		} else if (model.scaleZero !== undefined) {
			target = model.scaleZero;
		} else if (scale.getBasePosition) {
			target = scale.getBasePosition();
		} else if (scale.getBasePixel) {
			target = scale.getBasePixel();
		}

		if (target !== undefined && target !== null) {
			if (target.x !== undefined && target.y !== undefined) {
				return target;
			}

			if (typeof target === 'number' && isFinite(target)) {
				horizontal = scale.isHorizontal();
				return {
					x: horizontal? target : null,
					y: horizontal? null : target
				};
			}
		}

		return null;
	}

	function resolveTarget(sources, index, propagate) {
		var source = sources[index];
		var fill = source.fill;
		var visited = [index];
		var target;

		if (!propagate) {
			return fill;
		}

		while (fill !== false && visited.indexOf(fill) === -1) {
			if (!isFinite(fill)) {
				return fill;
			}

			target = sources[fill];
			if (!target) {
				return false;
			}

			if (target.visible) {
				return fill;
			}

			visited.push(fill);
			fill = target.fill;
		}

		return false;
	}

	function createMapper(source) {
		var fill = source.fill;
		var type = 'dataset';

		if (fill === false) {
			return null;
		}

		if (!isFinite(fill)) {
			type = 'boundary';
		}

		return mappers[type](source);
	}

	function isDrawable(point) {
		return point && !point.skip;
	}

	function drawArea(ctx, curve0, curve1, len0, len1) {
		var i;

		if (!len0 || !len1) {
			return;
		}

		// building first area curve (normal)
		ctx.moveTo(curve0[0].x, curve0[0].y);
		for (i=1; i<len0; ++i) {
			helpers.canvas.lineTo(ctx, curve0[i-1], curve0[i]);
		}

		// joining the two area curves
		ctx.lineTo(curve1[len1-1].x, curve1[len1-1].y);

		// building opposite area curve (reverse)
		for (i=len1-1; i>0; --i) {
			helpers.canvas.lineTo(ctx, curve1[i], curve1[i-1], true);
		}
	}

	function doFill(ctx, points, mapper, view, color, loop) {
		var count = points.length;
		var span = view.spanGaps;
		var curve0 = [];
		var curve1 = [];
		var len0 = 0;
		var len1 = 0;
		var i, ilen, index, p0, p1, d0, d1;

		ctx.beginPath();

		for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
			index = i%count;
			p0 = points[index]._view;
			p1 = mapper(p0, index, view);
			d0 = isDrawable(p0);
			d1 = isDrawable(p1);

			if (d0 && d1) {
				len0 = curve0.push(p0);
				len1 = curve1.push(p1);
			} else if (len0 && len1) {
				if (!span) {
					drawArea(ctx, curve0, curve1, len0, len1);
					len0 = len1 = 0;
					curve0 = [];
					curve1 = [];
				} else {
					if (d0) {
						curve0.push(p0);
					}
					if (d1) {
						curve1.push(p1);
					}
				}
			}
		}

		drawArea(ctx, curve0, curve1, len0, len1);

		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}

	return {
		id: 'filler',

		afterDatasetsUpdate: function(chart, options) {
			var count = (chart.data.datasets || []).length;
			var propagate = options.propagate;
			var sources = [];
			var meta, i, el, source;

			for (i = 0; i < count; ++i) {
				meta = chart.getDatasetMeta(i);
				el = meta.dataset;
				source = null;

				if (el && el._model && el instanceof Chart.elements.Line) {
					source = {
						visible: chart.isDatasetVisible(i),
						fill: decodeFill(el, i, count),
						chart: chart,
						el: el
					};
				}

				meta.$filler = source;
				sources.push(source);
			}

			for (i=0; i<count; ++i) {
				source = sources[i];
				if (!source) {
					continue;
				}

				source.fill = resolveTarget(sources, i, propagate);
				source.boundary = computeBoundary(source);
				source.mapper = createMapper(source);
			}
		},

		beforeDatasetDraw: function(chart, args) {
			var meta = args.meta.$filler;
			if (!meta) {
				return;
			}

			var el = meta.el;
			var view = el._view;
			var points = el._children || [];
			var mapper = meta.mapper;
			var color = view.backgroundColor || defaults.global.defaultColor;

			if (mapper && color && points.length) {
				doFill(chart.ctx, points, mapper, view, color, el._loop);
			}
		}
	};
};

},{}],36:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var layout = Chart.layoutService;
	var noop = helpers.noop;

	Chart.defaults.global.legend = {
		display: true,
		position: 'top',
		fullWidth: true,
		reverse: false,
		weight: 1000,

		// a callback that will handle
		onClick: function(e, legendItem) {
			var index = legendItem.datasetIndex;
			var ci = this.chart;
			var meta = ci.getDatasetMeta(index);

			// See controller.isDatasetVisible comment
			meta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;

			// We hid a dataset ... rerender the chart
			ci.update();
		},

		onHover: null,

		labels: {
			boxWidth: 40,
			padding: 10,
			// Generates labels shown in the legend
			// Valid properties to return:
			// text : text to display
			// fillStyle : fill of coloured box
			// strokeStyle: stroke of coloured box
			// hidden : if this legend item refers to a hidden item
			// lineCap : cap style for line
			// lineDash
			// lineDashOffset :
			// lineJoin :
			// lineWidth :
			generateLabels: function(chart) {
				var data = chart.data;
				return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
					return {
						text: dataset.label,
						fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
						hidden: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: dataset.borderDash,
						lineDashOffset: dataset.borderDashOffset,
						lineJoin: dataset.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
						pointStyle: dataset.pointStyle,

						// Below is extra data used for toggling the datasets
						datasetIndex: i
					};
				}, this) : [];
			}
		}
	};

	/**
	 * Helper function to get the box width based on the usePointStyle option
	 * @param labelopts {Object} the label options on the legend
	 * @param fontSize {Number} the label font size
	 * @return {Number} width of the color box area
	 */
	function getBoxWidth(labelOpts, fontSize) {
		return labelOpts.usePointStyle ?
			fontSize * Math.SQRT2 :
			labelOpts.boxWidth;
	}

	Chart.Legend = Chart.Element.extend({

		initialize: function(config) {
			helpers.extend(this, config);

			// Contains hit boxes for each dataset (in dataset order)
			this.legendHitBoxes = [];

			// Are we in doughnut mode which has a different data type
			this.doughnutMode = false;
		},

		// These methods are ordered by lifecycle. Utilities then follow.
		// Any function defined here is inherited by all legend types.
		// Any function can be extended by the legend type

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: function() {
			var me = this;
			var labelOpts = me.options.labels;
			var legendItems = labelOpts.generateLabels.call(me, me.chart);

			if (labelOpts.filter) {
				legendItems = legendItems.filter(function(item) {
					return labelOpts.filter(item, me.chart.data);
				});
			}

			if (me.options.reverse) {
				legendItems.reverse();
			}

			me.legendItems = legendItems;
		},
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var display = opts.display;

			var ctx = me.ctx;

			var globalDefault = Chart.defaults.global,
				itemOrDefault = helpers.getValueOrDefault,
				fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
				fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
				fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
				labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

			// Reset hit boxes
			var hitboxes = me.legendHitBoxes = [];

			var minSize = me.minSize;
			var isHorizontal = me.isHorizontal();

			if (isHorizontal) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? 10 : 0;
			} else {
				minSize.width = display ? 10 : 0;
				minSize.height = me.maxHeight; // fill all the height
			}

			// Increase sizes here
			if (display) {
				ctx.font = labelFont;

				if (isHorizontal) {
					// Labels

					// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
					var lineWidths = me.lineWidths = [0];
					var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

					ctx.textAlign = 'left';
					ctx.textBaseline = 'top';

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
							totalHeight += fontSize + (labelOpts.padding);
							lineWidths[lineWidths.length] = me.left;
						}

						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: width,
							height: fontSize
						};

						lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
					});

					minSize.height += totalHeight;

				} else {
					var vPadding = labelOpts.padding;
					var columnWidths = me.columnWidths = [];
					var totalWidth = labelOpts.padding;
					var currentColWidth = 0;
					var currentColHeight = 0;
					var itemHeight = fontSize + vPadding;

					helpers.each(me.legendItems, function(legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

						// If too tall, go to new column
						if (currentColHeight + itemHeight > minSize.height) {
							totalWidth += currentColWidth + labelOpts.padding;
							columnWidths.push(currentColWidth); // previous column width

							currentColWidth = 0;
							currentColHeight = 0;
						}

						// Get max width
						currentColWidth = Math.max(currentColWidth, itemWidth);
						currentColHeight += itemHeight;

						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: itemWidth,
							height: fontSize
						};
					});

					totalWidth += currentColWidth;
					columnWidths.push(currentColWidth);
					minSize.width += totalWidth;
				}
			}

			me.width = minSize.width;
			me.height = minSize.height;
		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			return this.options.position === 'top' || this.options.position === 'bottom';
		},

		// Actually draw the legend on the canvas
		draw: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var globalDefault = Chart.defaults.global,
				lineDefault = globalDefault.elements.line,
				legendWidth = me.width,
				lineWidths = me.lineWidths;

			if (opts.display) {
				var ctx = me.ctx,
					cursor,
					itemOrDefault = helpers.getValueOrDefault,
					fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),
					fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
					fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
					fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
					labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

				// Canvas setup
				ctx.textAlign = 'left';
				ctx.textBaseline = 'top';
				ctx.lineWidth = 0.5;
				ctx.strokeStyle = fontColor; // for strikethrough effect
				ctx.fillStyle = fontColor; // render in correct colour
				ctx.font = labelFont;

				var boxWidth = getBoxWidth(labelOpts, fontSize),
					hitboxes = me.legendHitBoxes;

				// current position
				var drawLegendBox = function(x, y, legendItem) {
					if (isNaN(boxWidth) || boxWidth <= 0) {
						return;
					}

					// Set the ctx for the box
					ctx.save();

					ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
					ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
					ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
					ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
					ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
					ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
					var isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

					if (ctx.setLineDash) {
						// IE 9 and 10 do not support line dash
						ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));
					}

					if (opts.labels && opts.labels.usePointStyle) {
						// Recalculate x and y for drawPoint() because its expecting
						// x and y to be center of figure (instead of top left)
						var radius = fontSize * Math.SQRT2 / 2;
						var offSet = radius / Math.SQRT2;
						var centerX = x + offSet;
						var centerY = y + offSet;

						// Draw pointStyle as legend symbol
						Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
					} else {
						// Draw box as legend symbol
						if (!isLineWidthZero) {
							ctx.strokeRect(x, y, boxWidth, fontSize);
						}
						ctx.fillRect(x, y, boxWidth, fontSize);
					}

					ctx.restore();
				};
				var fillText = function(x, y, legendItem, textWidth) {
					ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);

					if (legendItem.hidden) {
						// Strikethrough the text if hidden
						ctx.beginPath();
						ctx.lineWidth = 2;
						ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));
						ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));
						ctx.stroke();
					}
				};

				// Horizontal
				var isHorizontal = me.isHorizontal();
				if (isHorizontal) {
					cursor = {
						x: me.left + ((legendWidth - lineWidths[0]) / 2),
						y: me.top + labelOpts.padding,
						line: 0
					};
				} else {
					cursor = {
						x: me.left + labelOpts.padding,
						y: me.top + labelOpts.padding,
						line: 0
					};
				}

				var itemHeight = fontSize + labelOpts.padding;
				helpers.each(me.legendItems, function(legendItem, i) {
					var textWidth = ctx.measureText(legendItem.text).width,
						width = boxWidth + (fontSize / 2) + textWidth,
						x = cursor.x,
						y = cursor.y;

					if (isHorizontal) {
						if (x + width >= legendWidth) {
							y = cursor.y += itemHeight;
							cursor.line++;
							x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
						}
					} else if (y + itemHeight > me.bottom) {
						x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
						y = cursor.y = me.top + labelOpts.padding;
						cursor.line++;
					}

					drawLegendBox(x, y, legendItem);

					hitboxes[i].left = x;
					hitboxes[i].top = y;

					// Fill the actual label
					fillText(x, y, legendItem, textWidth);

					if (isHorizontal) {
						cursor.x += width + (labelOpts.padding);
					} else {
						cursor.y += itemHeight;
					}

				});
			}
		},

		/**
		 * Handle an event
		 * @private
		 * @param {IEvent} event - The event to handle
		 * @return {Boolean} true if a change occured
		 */
		handleEvent: function(e) {
			var me = this;
			var opts = me.options;
			var type = e.type === 'mouseup' ? 'click' : e.type;
			var changed = false;

			if (type === 'mousemove') {
				if (!opts.onHover) {
					return;
				}
			} else if (type === 'click') {
				if (!opts.onClick) {
					return;
				}
			} else {
				return;
			}

			// Chart event already has relative position in it
			var x = e.x,
				y = e.y;

			if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
				// See if we are touching one of the dataset boxes
				var lh = me.legendHitBoxes;
				for (var i = 0; i < lh.length; ++i) {
					var hitBox = lh[i];

					if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
						// Touching an element
						if (type === 'click') {
							// use e.native for backwards compatibility
							opts.onClick.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						} else if (type === 'mousemove') {
							// use e.native for backwards compatibility
							opts.onHover.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						}
					}
				}
			}

			return changed;
		}
	});

	function createNewLegendAndAttach(chart, legendOpts) {
		var legend = new Chart.Legend({
			ctx: chart.ctx,
			options: legendOpts,
			chart: chart
		});

		layout.configure(chart, legend, legendOpts);
		layout.addBox(chart, legend);
		chart.legend = legend;
	}

	return {
		id: 'legend',

		beforeInit: function(chart) {
			var legendOpts = chart.options.legend;

			if (legendOpts) {
				createNewLegendAndAttach(chart, legendOpts);
			}
		},

		beforeUpdate: function(chart) {
			var legendOpts = chart.options.legend;
			var legend = chart.legend;

			if (legendOpts) {
				legendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);

				if (legend) {
					layout.configure(chart, legend, legendOpts);
					legend.options = legendOpts;
				} else {
					createNewLegendAndAttach(chart, legendOpts);
				}
			} else if (legend) {
				layout.removeBox(chart, legend);
				delete chart.legend;
			}
		},

		afterEvent: function(chart, e) {
			var legend = chart.legend;
			if (legend) {
				legend.handleEvent(e);
			}
		}
	};
};

},{}],37:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var layout = Chart.layoutService;
	var noop = helpers.noop;

	Chart.defaults.global.title = {
		display: false,
		position: 'top',
		fullWidth: true,
		weight: 2000,        // by default greater than legend (1000) to be above
		fontStyle: 'bold',
		padding: 10,

		// actual title
		text: ''
	};

	Chart.Title = Chart.Element.extend({
		initialize: function(config) {
			var me = this;
			helpers.extend(me, config);

			// Contains hit boxes for each dataset (in dataset order)
			me.legendHitBoxes = [];
		},

		// These methods are ordered by lifecycle. Utilities then follow.

		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;

		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: noop,
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function() {
			var me = this,
				valueOrDefault = helpers.getValueOrDefault,
				opts = me.options,
				globalDefaults = Chart.defaults.global,
				display = opts.display,
				fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
				minSize = me.minSize;

			if (me.isHorizontal()) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? fontSize + (opts.padding * 2) : 0;
			} else {
				minSize.width = display ? fontSize + (opts.padding * 2) : 0;
				minSize.height = me.maxHeight; // fill all the height
			}

			me.width = minSize.width;
			me.height = minSize.height;

		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function() {
			var pos = this.options.position;
			return pos === 'top' || pos === 'bottom';
		},

		// Actually draw the title block on the canvas
		draw: function() {
			var me = this,
				ctx = me.ctx,
				valueOrDefault = helpers.getValueOrDefault,
				opts = me.options,
				globalDefaults = Chart.defaults.global;

			if (opts.display) {
				var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
					fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),
					fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),
					titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),
					rotation = 0,
					titleX,
					titleY,
					top = me.top,
					left = me.left,
					bottom = me.bottom,
					right = me.right,
					maxWidth;

				ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
				ctx.font = titleFont;

				// Horizontal
				if (me.isHorizontal()) {
					titleX = left + ((right - left) / 2); // midpoint of the width
					titleY = top + ((bottom - top) / 2); // midpoint of the height
					maxWidth = right - left;
				} else {
					titleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);
					titleY = top + ((bottom - top) / 2);
					maxWidth = bottom - top;
					rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
				}

				ctx.save();
				ctx.translate(titleX, titleY);
				ctx.rotate(rotation);
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(opts.text, 0, 0, maxWidth);
				ctx.restore();
			}
		}
	});

	function createNewTitleBlockAndAttach(chart, titleOpts) {
		var title = new Chart.Title({
			ctx: chart.ctx,
			options: titleOpts,
			chart: chart
		});

		layout.configure(chart, title, titleOpts);
		layout.addBox(chart, title);
		chart.titleBlock = title;
	}

	return {
		id: 'title',

		beforeInit: function(chart) {
			var titleOpts = chart.options.title;

			if (titleOpts) {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		},

		beforeUpdate: function(chart) {
			var titleOpts = chart.options.title;
			var titleBlock = chart.titleBlock;

			if (titleOpts) {
				titleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);

				if (titleBlock) {
					layout.configure(chart, titleBlock, titleOpts);
					titleBlock.options = titleOpts;
				} else {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			} else if (titleBlock) {
				Chart.layoutService.removeBox(chart, titleBlock);
				delete chart.titleBlock;
			}
		}
	};
};

},{}],38:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	// Default config for a category scale
	var defaultConfig = {
		position: 'bottom'
	};

	var DatasetScale = Chart.Scale.extend({
		/**
		* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
		* else fall back to data.labels
		* @private
		*/
		getLabels: function() {
			var data = this.chart.data;
			return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
		},

		determineDataLimits: function() {
			var me = this;
			var labels = me.getLabels();
			me.minIndex = 0;
			me.maxIndex = labels.length - 1;
			var findIndex;

			if (me.options.ticks.min !== undefined) {
				// user specified min value
				findIndex = helpers.indexOf(labels, me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}

			if (me.options.ticks.max !== undefined) {
				// user specified max value
				findIndex = helpers.indexOf(labels, me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}

			me.min = labels[me.minIndex];
			me.max = labels[me.maxIndex];
		},

		buildTicks: function() {
			var me = this;
			var labels = me.getLabels();
			// If we are viewing some subset of labels, slice the original array
			me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
		},

		getLabelForIndex: function(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var isHorizontal = me.isHorizontal();

			if (data.yLabels && !isHorizontal) {
				return me.getRightValue(data.datasets[datasetIndex].data[index]);
			}
			return me.ticks[index - me.minIndex];
		},

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: function(value, index, datasetIndex, includeOffset) {
			var me = this;
			// 1 is added because we need the length but we have the indexes
			var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);

			// If value is a data object, then index is the index in the data array,
			// not the index of the scale. We need to change that.
			var valueCategory;
			if (value !== undefined && value !== null) {
				valueCategory = me.isHorizontal() ? value.x : value.y;
			}
			if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
				var labels = me.getLabels();
				value = valueCategory || value;
				var idx = labels.indexOf(value);
				index = idx !== -1 ? idx : index;
			}

			if (me.isHorizontal()) {
				var valueWidth = me.width / offsetAmt;
				var widthOffset = (valueWidth * (index - me.minIndex));

				if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {
					widthOffset += (valueWidth / 2);
				}

				return me.left + Math.round(widthOffset);
			}
			var valueHeight = me.height / offsetAmt;
			var heightOffset = (valueHeight * (index - me.minIndex));

			if (me.options.gridLines.offsetGridLines && includeOffset) {
				heightOffset += (valueHeight / 2);
			}

			return me.top + Math.round(heightOffset);
		},
		getPixelForTick: function(index, includeOffset) {
			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var value;
			var offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
			var horz = me.isHorizontal();
			var valueDimension = (horz ? me.width : me.height) / offsetAmt;

			pixel -= horz ? me.left : me.top;

			if (me.options.gridLines.offsetGridLines) {
				pixel -= (valueDimension / 2);
			}

			if (pixel <= 0) {
				value = 0;
			} else {
				value = Math.round(pixel / valueDimension);
			}

			return value;
		},
		getBasePixel: function() {
			return this.bottom;
		}
	});

	Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);

};

},{}],39:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	var defaultConfig = {
		position: 'left',
		ticks: {
			callback: Chart.Ticks.formatters.linear
		}
	};

	var LinearScale = Chart.LinearScaleBase.extend({

		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var isHorizontal = me.isHorizontal();
			var DEFAULT_MIN = 0;
			var DEFAULT_MAX = 1;

			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// First Calculate the range
			me.min = null;
			me.max = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function(dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [
						meta.type,
						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
						meta.stack
					].join('.');

					if (valuesPerStack[key] === undefined) {
						valuesPerStack[key] = {
							positiveValues: [],
							negativeValues: []
						};
					}

					// Store these per type
					var positiveValues = valuesPerStack[key].positiveValues;
					var negativeValues = valuesPerStack[key].negativeValues;

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							positiveValues[index] = positiveValues[index] || 0;
							negativeValues[index] = negativeValues[index] || 0;

							if (opts.relativePoints) {
								positiveValues[index] = 100;
							} else if (value < 0) {
								negativeValues[index] += value;
							} else {
								positiveValues[index] += value;
							}
						});
					}
				});

				helpers.each(valuesPerStack, function(valuesForType) {
					var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
					var minVal = helpers.min(values);
					var maxVal = helpers.max(values);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});

			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}
						});
					}
				});
			}

			me.min = isFinite(me.min) ? me.min : DEFAULT_MIN;
			me.max = isFinite(me.max) ? me.max : DEFAULT_MAX;

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			this.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var maxTicks;
			var me = this;
			var tickOpts = me.options.ticks;

			if (me.isHorizontal()) {
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
			} else {
				// The factor of 2 used to scale the font size has been experimentally determined.
				var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
			}

			return maxTicks;
		},
		// Called after the ticks are built. We need
		handleDirectionalChanges: function() {
			if (!this.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				this.ticks.reverse();
			}
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		// Utils
		getPixelForValue: function(value) {
			// This must be called after fit has been run so that
			// this.left, this.top, this.right, and this.bottom have been defined
			var me = this;
			var start = me.start;

			var rightValue = +me.getRightValue(value);
			var pixel;
			var range = me.end - start;

			if (me.isHorizontal()) {
				pixel = me.left + (me.width / range * (rightValue - start));
				return Math.round(pixel);
			}

			pixel = me.bottom - (me.height / range * (rightValue - start));
			return Math.round(pixel);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var isHorizontal = me.isHorizontal();
			var innerDimension = isHorizontal ? me.width : me.height;
			var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
			return me.start + ((me.end - me.start) * offset);
		},
		getPixelForTick: function(index) {
			return this.getPixelForValue(this.ticksAsNumbers[index]);
		}
	});
	Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);

};

},{}],40:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers,
		noop = helpers.noop;

	Chart.LinearScaleBase = Chart.Scale.extend({
		handleTickRangeOptions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
			// do nothing since that would make the chart weird. If the user really wants a weird chart
			// axis, they can manually override it
			if (tickOpts.beginAtZero) {
				var minSign = helpers.sign(me.min);
				var maxSign = helpers.sign(me.max);

				if (minSign < 0 && maxSign < 0) {
					// move the top up to 0
					me.max = 0;
				} else if (minSign > 0 && maxSign > 0) {
					// move the bottom down to 0
					me.min = 0;
				}
			}

			if (tickOpts.min !== undefined) {
				me.min = tickOpts.min;
			} else if (tickOpts.suggestedMin !== undefined) {
				if (me.min === null) {
					me.min = tickOpts.suggestedMin;
				} else {
					me.min = Math.min(me.min, tickOpts.suggestedMin);
				}
			}

			if (tickOpts.max !== undefined) {
				me.max = tickOpts.max;
			} else if (tickOpts.suggestedMax !== undefined) {
				if (me.max === null) {
					me.max = tickOpts.suggestedMax;
				} else {
					me.max = Math.max(me.max, tickOpts.suggestedMax);
				}
			}

			if (me.min === me.max) {
				me.max++;

				if (!tickOpts.beginAtZero) {
					me.min--;
				}
			}
		},
		getTickLimit: noop,
		handleDirectionalChanges: noop,

		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph. Make sure we always have at least 2 ticks
			var maxTicks = me.getTickLimit();
			maxTicks = Math.max(2, maxTicks);

			var numericGeneratorOptions = {
				maxTicks: maxTicks,
				min: tickOpts.min,
				max: tickOpts.max,
				stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
			};
			var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);

			me.handleDirectionalChanges();

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				ticks.reverse();

				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function() {
			var me = this;
			me.ticksAsNumbers = me.ticks.slice();
			me.zeroLineIndex = me.ticks.indexOf(0);

			Chart.Scale.prototype.convertTicksToLabels.call(me);
		}
	});
};

},{}],41:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;

	var defaultConfig = {
		position: 'left',

		// label settings
		ticks: {
			callback: Chart.Ticks.formatters.logarithmic
		}
	};

	var LogarithmicScale = Chart.Scale.extend({
		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var getValueOrDefault = helpers.getValueOrDefault;
			var isHorizontal = me.isHorizontal();
			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// Calculate Range
			me.min = null;
			me.max = null;
			me.minNotZero = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function(dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [
						meta.type,
						// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
						((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
						meta.stack
					].join('.');

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = [];
						}

						helpers.each(dataset.data, function(rawValue, index) {
							var values = valuesPerStack[key];
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							values[index] = values[index] || 0;

							if (opts.relativePoints) {
								values[index] = 100;
							} else {
								// Don't need to split positive and negative since the log scale can't handle a 0 crossing
								values[index] += value;
							}
						});
					}
				});

				helpers.each(valuesPerStack, function(valuesForType) {
					var minVal = helpers.min(valuesForType);
					var maxVal = helpers.max(valuesForType);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});

			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}

							if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
								me.minNotZero = value;
							}
						});
					}
				});
			}

			me.min = getValueOrDefault(tickOpts.min, me.min);
			me.max = getValueOrDefault(tickOpts.max, me.max);

			if (me.min === me.max) {
				if (me.min !== 0 && me.min !== null) {
					me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
					me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
				} else {
					me.min = 1;
					me.max = 10;
				}
			}
		},
		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			var generationOptions = {
				min: tickOpts.min,
				max: tickOpts.max
			};
			var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);

			if (!me.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				ticks.reverse();
			}

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				ticks.reverse();

				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function() {
			this.tickValues = this.ticks.slice();

			Chart.Scale.prototype.convertTicksToLabels.call(this);
		},
		// Get the correct tooltip label
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		getPixelForTick: function(index) {
			return this.getPixelForValue(this.tickValues[index]);
		},
		getPixelForValue: function(value) {
			var me = this;
			var innerDimension;
			var pixel;

			var start = me.start;
			var newVal = +me.getRightValue(value);
			var range;
			var opts = me.options;
			var tickOpts = opts.ticks;

			if (me.isHorizontal()) {
				range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
				if (newVal === 0) {
					pixel = me.left;
				} else {
					innerDimension = me.width;
					pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
				}
			} else {
				// Bottom - top since pixels increase downward on a screen
				innerDimension = me.height;
				if (start === 0 && !tickOpts.reverse) {
					range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
					if (newVal === start) {
						pixel = me.bottom;
					} else if (newVal === me.minNotZero) {
						pixel = me.bottom - innerDimension * 0.02;
					} else {
						pixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));
					}
				} else if (me.end === 0 && tickOpts.reverse) {
					range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
					if (newVal === me.end) {
						pixel = me.top;
					} else if (newVal === me.minNotZero) {
						pixel = me.top + innerDimension * 0.02;
					} else {
						pixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));
					}
				} else if (newVal === 0) {
					pixel = tickOpts.reverse ? me.top : me.bottom;
				} else {
					range = helpers.log10(me.end) - helpers.log10(start);
					innerDimension = me.height;
					pixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
				}
			}
			return pixel;
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var range = helpers.log10(me.end) - helpers.log10(me.start);
			var value, innerDimension;

			if (me.isHorizontal()) {
				innerDimension = me.width;
				value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
			} else {  // todo: if start === 0
				innerDimension = me.height;
				value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
			}
			return value;
		}
	});
	Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);

};

},{}],42:[function(require,module,exports){
'use strict';

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var globalDefaults = Chart.defaults.global;

	var defaultConfig = {
		display: true,

		// Boolean - Whether to animate scaling the chart from the centre
		animate: true,
		position: 'chartArea',

		angleLines: {
			display: true,
			color: 'rgba(0, 0, 0, 0.1)',
			lineWidth: 1
		},

		gridLines: {
			circular: false
		},

		// label settings
		ticks: {
			// Boolean - Show a backdrop to the scale label
			showLabelBackdrop: true,

			// String - The colour of the label backdrop
			backdropColor: 'rgba(255,255,255,0.75)',

			// Number - The backdrop padding above & below the label in pixels
			backdropPaddingY: 2,

			// Number - The backdrop padding to the side of the label in pixels
			backdropPaddingX: 2,

			callback: Chart.Ticks.formatters.linear
		},

		pointLabels: {
			// Boolean - if true, show point labels
			display: true,

			// Number - Point label font size in pixels
			fontSize: 10,

			// Function - Used to convert point labels
			callback: function(label) {
				return label;
			}
		}
	};

	function getValueCount(scale) {
		var opts = scale.options;
		return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
	}

	function getPointLabelFontOptions(scale) {
		var pointLabelOptions = scale.options.pointLabels;
		var fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
		var fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
		var fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
		var font = helpers.fontString(fontSize, fontStyle, fontFamily);

		return {
			size: fontSize,
			style: fontStyle,
			family: fontFamily,
			font: font
		};
	}

	function measureLabelSize(ctx, fontSize, label) {
		if (helpers.isArray(label)) {
			return {
				w: helpers.longestText(ctx, ctx.font, label),
				h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
			};
		}

		return {
			w: ctx.measureText(label).width,
			h: fontSize
		};
	}

	function determineLimits(angle, pos, size, min, max) {
		if (angle === min || angle === max) {
			return {
				start: pos - (size / 2),
				end: pos + (size / 2)
			};
		} else if (angle < min || angle > max) {
			return {
				start: pos - size - 5,
				end: pos
			};
		}

		return {
			start: pos,
			end: pos + size + 5
		};
	}

	/**
	 * Helper function to fit a radial linear scale with point labels
	 */
	function fitWithPointLabels(scale) {
		/*
		 * Right, this is really confusing and there is a lot of maths going on here
		 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
		 *
		 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
		 *
		 * Solution:
		 *
		 * We assume the radius of the polygon is half the size of the canvas at first
		 * at each index we check if the text overlaps.
		 *
		 * Where it does, we store that angle and that index.
		 *
		 * After finding the largest index and angle we calculate how much we need to remove
		 * from the shape radius to move the point inwards by that x.
		 *
		 * We average the left and right distances to get the maximum shape radius that can fit in the box
		 * along with labels.
		 *
		 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
		 * on each side, removing that from the size, halving it and adding the left x protrusion width.
		 *
		 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
		 * and position it in the most space efficient manner
		 *
		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
		 */

		var plFont = getPointLabelFontOptions(scale);

		// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
		// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		var furthestLimits = {
			r: scale.width,
			l: 0,
			t: scale.height,
			b: 0
		};
		var furthestAngles = {};
		var i;
		var textSize;
		var pointPosition;

		scale.ctx.font = plFont.font;
		scale._pointLabelSizes = [];

		var valueCount = getValueCount(scale);
		for (i = 0; i < valueCount; i++) {
			pointPosition = scale.getPointPosition(i, largestPossibleRadius);
			textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
			scale._pointLabelSizes[i] = textSize;

			// Add quarter circle to make degree 0 mean top of circle
			var angleRadians = scale.getIndexAngle(i);
			var angle = helpers.toDegrees(angleRadians) % 360;
			var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
			var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

			if (hLimits.start < furthestLimits.l) {
				furthestLimits.l = hLimits.start;
				furthestAngles.l = angleRadians;
			}

			if (hLimits.end > furthestLimits.r) {
				furthestLimits.r = hLimits.end;
				furthestAngles.r = angleRadians;
			}

			if (vLimits.start < furthestLimits.t) {
				furthestLimits.t = vLimits.start;
				furthestAngles.t = angleRadians;
			}

			if (vLimits.end > furthestLimits.b) {
				furthestLimits.b = vLimits.end;
				furthestAngles.b = angleRadians;
			}
		}

		scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
	}

	/**
	 * Helper function to fit a radial linear scale with no point labels
	 */
	function fit(scale) {
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		scale.drawingArea = Math.round(largestPossibleRadius);
		scale.setCenterPoint(0, 0, 0, 0);
	}

	function getTextAlignForAngle(angle) {
		if (angle === 0 || angle === 180) {
			return 'center';
		} else if (angle < 180) {
			return 'left';
		}

		return 'right';
	}

	function fillText(ctx, text, position, fontSize) {
		if (helpers.isArray(text)) {
			var y = position.y;
			var spacing = 1.5 * fontSize;

			for (var i = 0; i < text.length; ++i) {
				ctx.fillText(text[i], position.x, y);
				y+= spacing;
			}
		} else {
			ctx.fillText(text, position.x, position.y);
		}
	}

	function adjustPointPositionForLabelHeight(angle, textSize, position) {
		if (angle === 90 || angle === 270) {
			position.y -= (textSize.h / 2);
		} else if (angle > 270 || angle < 90) {
			position.y -= textSize.h;
		}
	}

	function drawPointLabels(scale) {
		var ctx = scale.ctx;
		var getValueOrDefault = helpers.getValueOrDefault;
		var opts = scale.options;
		var angleLineOpts = opts.angleLines;
		var pointLabelOpts = opts.pointLabels;

		ctx.lineWidth = angleLineOpts.lineWidth;
		ctx.strokeStyle = angleLineOpts.color;

		var outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);

		// Point Label Font
		var plFont = getPointLabelFontOptions(scale);

		ctx.textBaseline = 'top';

		for (var i = getValueCount(scale) - 1; i >= 0; i--) {
			if (angleLineOpts.display) {
				var outerPosition = scale.getPointPosition(i, outerDistance);
				ctx.beginPath();
				ctx.moveTo(scale.xCenter, scale.yCenter);
				ctx.lineTo(outerPosition.x, outerPosition.y);
				ctx.stroke();
				ctx.closePath();
			}

			if (pointLabelOpts.display) {
				// Extra 3px out for some label spacing
				var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

				// Keep this in loop since we may support array properties here
				var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
				ctx.font = plFont.font;
				ctx.fillStyle = pointLabelFontColor;

				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians);
				ctx.textAlign = getTextAlignForAngle(angle);
				adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
			}
		}
	}

	function drawRadiusLine(scale, gridLineOpts, radius, index) {
		var ctx = scale.ctx;
		ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);
		ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

		if (scale.options.gridLines.circular) {
			// Draw circular arcs between the points
			ctx.beginPath();
			ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
			ctx.closePath();
			ctx.stroke();
		} else {
			// Draw straight lines connecting each index
			var valueCount = getValueCount(scale);

			if (valueCount === 0) {
				return;
			}

			ctx.beginPath();
			var pointPosition = scale.getPointPosition(0, radius);
			ctx.moveTo(pointPosition.x, pointPosition.y);

			for (var i = 1; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, radius);
				ctx.lineTo(pointPosition.x, pointPosition.y);
			}

			ctx.closePath();
			ctx.stroke();
		}
	}

	function numberOrZero(param) {
		return helpers.isNumber(param) ? param : 0;
	}

	var LinearRadialScale = Chart.LinearScaleBase.extend({
		setDimensions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			// Set the unconstrained dimension before label rotation
			me.width = me.maxWidth;
			me.height = me.maxHeight;
			me.xCenter = Math.round(me.width / 2);
			me.yCenter = Math.round(me.height / 2);

			var minSize = helpers.min([me.height, me.width]);
			var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
		},
		determineDataLimits: function() {
			var me = this;
			var chart = me.chart;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;

			helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
				if (chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex);

					helpers.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}

						min = Math.min(value, min);
						max = Math.max(value, max);
					});
				}
			});

			me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
			me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			me.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var tickOpts = this.options.ticks;
			var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
		},
		convertTicksToLabels: function() {
			var me = this;
			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

			// Point labels
			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		fit: function() {
			if (this.options.pointLabels.display) {
				fitWithPointLabels(this);
			} else {
				fit(this);
			}
		},
		/**
		 * Set radius reductions and determine new radius and center point
		 * @private
		 */
		setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
			var me = this;
			var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
			var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
			var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
			var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

			radiusReductionLeft = numberOrZero(radiusReductionLeft);
			radiusReductionRight = numberOrZero(radiusReductionRight);
			radiusReductionTop = numberOrZero(radiusReductionTop);
			radiusReductionBottom = numberOrZero(radiusReductionBottom);

			me.drawingArea = Math.min(
				Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
				Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
			me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
		},
		setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
			var me = this;
			var maxRight = me.width - rightMovement - me.drawingArea,
				maxLeft = leftMovement + me.drawingArea,
				maxTop = topMovement + me.drawingArea,
				maxBottom = me.height - bottomMovement - me.drawingArea;

			me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
			me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
		},

		getIndexAngle: function(index) {
			var angleMultiplier = (Math.PI * 2) / getValueCount(this);
			var startAngle = this.chart.options && this.chart.options.startAngle ?
				this.chart.options.startAngle :
				0;

			var startAngleRadians = startAngle * Math.PI * 2 / 360;

			// Start from the top instead of right, so remove a quarter of the circle
			return index * angleMultiplier + startAngleRadians;
		},
		getDistanceFromCenterForValue: function(value) {
			var me = this;

			if (value === null) {
				return 0; // null always in center
			}

			// Take into account half font size + the yPadding of the top value
			var scalingFactor = me.drawingArea / (me.max - me.min);
			if (me.options.reverse) {
				return (me.max - value) * scalingFactor;
			}
			return (value - me.min) * scalingFactor;
		},
		getPointPosition: function(index, distanceFromCenter) {
			var me = this;
			var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
			return {
				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
			};
		},
		getPointPositionForValue: function(index, value) {
			return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
		},

		getBasePosition: function() {
			var me = this;
			var min = me.min;
			var max = me.max;

			return me.getPointPositionForValue(0,
				me.beginAtZero? 0:
				min < 0 && max < 0? max :
				min > 0 && max > 0? min :
				0);
		},

		draw: function() {
			var me = this;
			var opts = me.options;
			var gridLineOpts = opts.gridLines;
			var tickOpts = opts.ticks;
			var getValueOrDefault = helpers.getValueOrDefault;

			if (opts.display) {
				var ctx = me.ctx;

				// Tick Font
				var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
				var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

				helpers.each(me.ticks, function(label, index) {
					// Don't draw a centre value (if it is minimum)
					if (index > 0 || opts.reverse) {
						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
						var yHeight = me.yCenter - yCenterOffset;

						// Draw circular lines around the scale
						if (gridLineOpts.display && index !== 0) {
							drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
						}

						if (tickOpts.display) {
							var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = tickLabelFont;

							if (tickOpts.showLabelBackdrop) {
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = tickOpts.backdropColor;
								ctx.fillRect(
									me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,
									yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,
									labelWidth + tickOpts.backdropPaddingX * 2,
									tickFontSize + tickOpts.backdropPaddingY * 2
								);
							}

							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillStyle = tickFontColor;
							ctx.fillText(label, me.xCenter, yHeight);
						}
					}
				});

				if (opts.angleLines.display || opts.pointLabels.display) {
					drawPointLabels(me);
				}
			}
		}
	});
	Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);

};

},{}],43:[function(require,module,exports){
/* global window: false */
'use strict';

var moment = require('moment');
moment = typeof(moment) === 'function' ? moment : window.moment;

module.exports = function(Chart) {

	var helpers = Chart.helpers;
	var interval = {
		millisecond: {
			size: 1,
			steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
		},
		second: {
			size: 1000,
			steps: [1, 2, 5, 10, 30]
		},
		minute: {
			size: 60000,
			steps: [1, 2, 5, 10, 30]
		},
		hour: {
			size: 3600000,
			steps: [1, 2, 3, 6, 12]
		},
		day: {
			size: 86400000,
			steps: [1, 2, 5]
		},
		week: {
			size: 604800000,
			maxStep: 4
		},
		month: {
			size: 2.628e9,
			maxStep: 3
		},
		quarter: {
			size: 7.884e9,
			maxStep: 4
		},
		year: {
			size: 3.154e10,
			maxStep: false
		}
	};

	var defaultConfig = {
		position: 'bottom',

		time: {
			parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
			format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
			unit: false, // false == automatic or override with week, month, year, etc.
			round: false, // none, or override with week, month, year, etc.
			displayFormat: false, // DEPRECATED
			isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
			minUnit: 'millisecond',

			// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
			displayFormats: {
				millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
				second: 'h:mm:ss a', // 11:20:01 AM
				minute: 'h:mm:ss a', // 11:20:01 AM
				hour: 'MMM D, hA', // Sept 4, 5PM
				day: 'll', // Sep 4 2015
				week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
				month: 'MMM YYYY', // Sept 2015
				quarter: '[Q]Q - YYYY', // Q3
				year: 'YYYY' // 2015
			},
		},
		ticks: {
			autoSkip: false
		}
	};

	/**
	 * Helper function to parse time to a moment object
	 * @param axis {TimeAxis} the time axis
	 * @param label {Date|string|number|Moment} The thing to parse
	 * @return {Moment} parsed time
	 */
	function parseTime(axis, label) {
		var timeOpts = axis.options.time;
		if (typeof timeOpts.parser === 'string') {
			return moment(label, timeOpts.parser);
		}
		if (typeof timeOpts.parser === 'function') {
			return timeOpts.parser(label);
		}
		if (typeof label.getMonth === 'function' || typeof label === 'number') {
			// Date objects
			return moment(label);
		}
		if (label.isValid && label.isValid()) {
			// Moment support
			return label;
		}
		var format = timeOpts.format;
		if (typeof format !== 'string' && format.call) {
			// Custom parsing (return an instance of moment)
			console.warn('options.time.format is deprecated and replaced by options.time.parser.');
			return format(label);
		}
		// Moment format parsing
		return moment(label, format);
	}

	/**
	 * Figure out which is the best unit for the scale
	 * @param minUnit {String} minimum unit to use
	 * @param min {Number} scale minimum
	 * @param max {Number} scale maximum
	 * @return {String} the unit to use
	 */
	function determineUnit(minUnit, min, max, maxTicks) {
		var units = Object.keys(interval);
		var unit;
		var numUnits = units.length;

		for (var i = units.indexOf(minUnit); i < numUnits; i++) {
			unit = units[i];
			var unitDetails = interval[unit];
			var steps = (unitDetails.steps && unitDetails.steps[unitDetails.steps.length - 1]) || unitDetails.maxStep;
			if (steps === undefined || Math.ceil((max - min) / (steps * unitDetails.size)) <= maxTicks) {
				break;
			}
		}

		return unit;
	}

	/**
	 * Determines how we scale the unit
	 * @param min {Number} the scale minimum
	 * @param max {Number} the scale maximum
	 * @param unit {String} the unit determined by the {@see determineUnit} method
	 * @return {Number} the axis step size as a multiple of unit
	 */
	function determineStepSize(min, max, unit, maxTicks) {
		// Using our unit, figoure out what we need to scale as
		var unitDefinition = interval[unit];
		var unitSizeInMilliSeconds = unitDefinition.size;
		var sizeInUnits = Math.ceil((max - min) / unitSizeInMilliSeconds);
		var multiplier = 1;
		var range = max - min;

		if (unitDefinition.steps) {
			// Have an array of steps
			var numSteps = unitDefinition.steps.length;
			for (var i = 0; i < numSteps && sizeInUnits > maxTicks; i++) {
				multiplier = unitDefinition.steps[i];
				sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));
			}
		} else {
			while (sizeInUnits > maxTicks && maxTicks > 0) {
				++multiplier;
				sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));
			}
		}

		return multiplier;
	}

	/**
	 * Helper for generating axis labels.
	 * @param options {ITimeGeneratorOptions} the options for generation
	 * @param dataRange {IRange} the data range
	 * @param niceRange {IRange} the pretty range to display
	 * @return {Number[]} ticks
	 */
	function generateTicks(options, dataRange, niceRange) {
		var ticks = [];
		if (options.maxTicks) {
			var stepSize = options.stepSize;
			ticks.push(options.min !== undefined ? options.min : niceRange.min);
			var cur = moment(niceRange.min);
			while (cur.add(stepSize, options.unit).valueOf() < niceRange.max) {
				ticks.push(cur.valueOf());
			}
			var realMax = options.max || niceRange.max;
			if (ticks[ticks.length - 1] !== realMax) {
				ticks.push(realMax);
			}
		}
		return ticks;
	}

	/**
	 * @function Chart.Ticks.generators.time
	 * @param options {ITimeGeneratorOptions} the options for generation
	 * @param dataRange {IRange} the data range
	 * @return {Number[]} ticks
	 */
	Chart.Ticks.generators.time = function(options, dataRange) {
		var niceMin;
		var niceMax;
		var isoWeekday = options.isoWeekday;
		if (options.unit === 'week' && isoWeekday !== false) {
			niceMin = moment(dataRange.min).startOf('isoWeek').isoWeekday(isoWeekday).valueOf();
			niceMax = moment(dataRange.max).startOf('isoWeek').isoWeekday(isoWeekday);
			if (dataRange.max - niceMax > 0) {
				niceMax.add(1, 'week');
			}
			niceMax = niceMax.valueOf();
		} else {
			niceMin = moment(dataRange.min).startOf(options.unit).valueOf();
			niceMax = moment(dataRange.max).startOf(options.unit);
			if (dataRange.max - niceMax > 0) {
				niceMax.add(1, options.unit);
			}
			niceMax = niceMax.valueOf();
		}
		return generateTicks(options, dataRange, {
			min: niceMin,
			max: niceMax
		});
	};

	var TimeScale = Chart.Scale.extend({
		initialize: function() {
			if (!moment) {
				throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
			}

			Chart.Scale.prototype.initialize.call(this);
		},
		determineDataLimits: function() {
			var me = this;
			var timeOpts = me.options.time;

			// We store the data range as unix millisecond timestamps so dataMin and dataMax will always be integers.
			var dataMin = Number.MAX_SAFE_INTEGER;
			var dataMax = Number.MIN_SAFE_INTEGER;

			var chartData = me.chart.data;
			var parsedData = {
				labels: [],
				datasets: []
			};

			var timestamp;

			helpers.each(chartData.labels, function(label, labelIndex) {
				var labelMoment = parseTime(me, label);

				if (labelMoment.isValid()) {
					// We need to round the time
					if (timeOpts.round) {
						labelMoment.startOf(timeOpts.round);
					}

					timestamp = labelMoment.valueOf();
					dataMin = Math.min(timestamp, dataMin);
					dataMax = Math.max(timestamp, dataMax);

					// Store this value for later
					parsedData.labels[labelIndex] = timestamp;
				}
			});

			helpers.each(chartData.datasets, function(dataset, datasetIndex) {
				var timestamps = [];

				if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null && me.chart.isDatasetVisible(datasetIndex)) {
					// We have potential point data, so we need to parse this
					helpers.each(dataset.data, function(value, dataIndex) {
						var dataMoment = parseTime(me, me.getRightValue(value));

						if (dataMoment.isValid()) {
							if (timeOpts.round) {
								dataMoment.startOf(timeOpts.round);
							}

							timestamp = dataMoment.valueOf();
							dataMin = Math.min(timestamp, dataMin);
							dataMax = Math.max(timestamp, dataMax);
							timestamps[dataIndex] = timestamp;
						}
					});
				} else {
					// We have no x coordinates, so use the ones from the labels
					timestamps = parsedData.labels.slice();
				}

				parsedData.datasets[datasetIndex] = timestamps;
			});

			me.dataMin = dataMin;
			me.dataMax = dataMax;
			me._parsedData = parsedData;
		},
		buildTicks: function() {
			var me = this;
			var timeOpts = me.options.time;

			var minTimestamp;
			var maxTimestamp;
			var dataMin = me.dataMin;
			var dataMax = me.dataMax;

			if (timeOpts.min) {
				var minMoment = parseTime(me, timeOpts.min);
				if (timeOpts.round) {
					minMoment.round(timeOpts.round);
				}
				minTimestamp = minMoment.valueOf();
			}

			if (timeOpts.max) {
				maxTimestamp = parseTime(me, timeOpts.max).valueOf();
			}

			var maxTicks = me.getLabelCapacity(minTimestamp || dataMin);
			var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, minTimestamp || dataMin, maxTimestamp || dataMax, maxTicks);
			me.displayFormat = timeOpts.displayFormats[unit];

			var stepSize = timeOpts.stepSize || determineStepSize(minTimestamp || dataMin, maxTimestamp || dataMax, unit, maxTicks);
			me.ticks = Chart.Ticks.generators.time({
				maxTicks: maxTicks,
				min: minTimestamp,
				max: maxTimestamp,
				stepSize: stepSize,
				unit: unit,
				isoWeekday: timeOpts.isoWeekday
			}, {
				min: dataMin,
				max: dataMax
			});

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(me.ticks);
			me.min = helpers.min(me.ticks);
		},
		// Get tooltip label
		getLabelForIndex: function(index, datasetIndex) {
			var me = this;
			var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';
			var value = me.chart.data.datasets[datasetIndex].data[index];

			if (value !== null && typeof value === 'object') {
				label = me.getRightValue(value);
			}

			// Format nicely
			if (me.options.time.tooltipFormat) {
				label = parseTime(me, label).format(me.options.time.tooltipFormat);
			}

			return label;
		},
		// Function to format an individual tick mark
		tickFormatFunction: function(tick, index, ticks) {
			var formattedTick = tick.format(this.displayFormat);
			var tickOpts = this.options.ticks;
			var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);

			if (callback) {
				return callback(formattedTick, index, ticks);
			}
			return formattedTick;
		},
		convertTicksToLabels: function() {
			var me = this;
			me.ticksAsTimestamps = me.ticks;
			me.ticks = me.ticks.map(function(tick) {
				return moment(tick);
			}).map(me.tickFormatFunction, me);
		},
		getPixelForOffset: function(offset) {
			var me = this;
			var epochWidth = me.max - me.min;
			var decimal = epochWidth ? (offset - me.min) / epochWidth : 0;

			if (me.isHorizontal()) {
				var valueOffset = (me.width * decimal);
				return me.left + Math.round(valueOffset);
			}

			var heightOffset = (me.height * decimal);
			return me.top + Math.round(heightOffset);
		},
		getPixelForValue: function(value, index, datasetIndex) {
			var me = this;
			var offset = null;
			if (index !== undefined && datasetIndex !== undefined) {
				offset = me._parsedData.datasets[datasetIndex][index];
			}

			if (offset === null) {
				if (!value || !value.isValid) {
					// not already a moment object
					value = parseTime(me, me.getRightValue(value));
				}

				if (value && value.isValid && value.isValid()) {
					offset = value.valueOf();
				}
			}

			if (offset !== null) {
				return me.getPixelForOffset(offset);
			}
		},
		getPixelForTick: function(index) {
			return this.getPixelForOffset(this.ticksAsTimestamps[index]);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var innerDimension = me.isHorizontal() ? me.width : me.height;
			var offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;
			return moment(me.min + (offset * (me.max - me.min)));
		},
		// Crude approximation of what the label width might be
		getLabelWidth: function(label) {
			var me = this;
			var ticks = me.options.ticks;

			var tickLabelWidth = me.ctx.measureText(label).width;
			var cosRotation = Math.cos(helpers.toRadians(ticks.maxRotation));
			var sinRotation = Math.sin(helpers.toRadians(ticks.maxRotation));
			var tickFontSize = helpers.getValueOrDefault(ticks.fontSize, Chart.defaults.global.defaultFontSize);
			return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
		},
		getLabelCapacity: function(exampleTime) {
			var me = this;

			me.displayFormat = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation
			var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);
			var tickLabelWidth = me.getLabelWidth(exampleLabel);

			var innerWidth = me.isHorizontal() ? me.width : me.height;
			var labelCapacity = innerWidth / tickLabelWidth;
			return labelCapacity;
		}
	});
	Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);

};

},{"moment":49}],44:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
       keyword = /(\w+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
    var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}

},{"color-name":48}],45:[function(require,module,exports){
/* MIT license */
var convert = require('color-convert');
var string = require('chartjs-color-string');

var Color = function (obj) {
	if (obj instanceof Color) {
		return obj;
	}
	if (!(this instanceof Color)) {
		return new Color(obj);
	}

	this.valid = false;
	this.values = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		hsv: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		alpha: 1
	};

	// parse Color() argument
	var vals;
	if (typeof obj === 'string') {
		vals = string.getRgba(obj);
		if (vals) {
			this.setValues('rgb', vals);
		} else if (vals = string.getHsla(obj)) {
			this.setValues('hsl', vals);
		} else if (vals = string.getHwb(obj)) {
			this.setValues('hwb', vals);
		}
	} else if (typeof obj === 'object') {
		vals = obj;
		if (vals.r !== undefined || vals.red !== undefined) {
			this.setValues('rgb', vals);
		} else if (vals.l !== undefined || vals.lightness !== undefined) {
			this.setValues('hsl', vals);
		} else if (vals.v !== undefined || vals.value !== undefined) {
			this.setValues('hsv', vals);
		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
			this.setValues('hwb', vals);
		} else if (vals.c !== undefined || vals.cyan !== undefined) {
			this.setValues('cmyk', vals);
		}
	}
};

Color.prototype = {
	isValid: function () {
		return this.valid;
	},
	rgb: function () {
		return this.setSpace('rgb', arguments);
	},
	hsl: function () {
		return this.setSpace('hsl', arguments);
	},
	hsv: function () {
		return this.setSpace('hsv', arguments);
	},
	hwb: function () {
		return this.setSpace('hwb', arguments);
	},
	cmyk: function () {
		return this.setSpace('cmyk', arguments);
	},

	rgbArray: function () {
		return this.values.rgb;
	},
	hslArray: function () {
		return this.values.hsl;
	},
	hsvArray: function () {
		return this.values.hsv;
	},
	hwbArray: function () {
		var values = this.values;
		if (values.alpha !== 1) {
			return values.hwb.concat([values.alpha]);
		}
		return values.hwb;
	},
	cmykArray: function () {
		return this.values.cmyk;
	},
	rgbaArray: function () {
		var values = this.values;
		return values.rgb.concat([values.alpha]);
	},
	hslaArray: function () {
		var values = this.values;
		return values.hsl.concat([values.alpha]);
	},
	alpha: function (val) {
		if (val === undefined) {
			return this.values.alpha;
		}
		this.setValues('alpha', val);
		return this;
	},

	red: function (val) {
		return this.setChannel('rgb', 0, val);
	},
	green: function (val) {
		return this.setChannel('rgb', 1, val);
	},
	blue: function (val) {
		return this.setChannel('rgb', 2, val);
	},
	hue: function (val) {
		if (val) {
			val %= 360;
			val = val < 0 ? 360 + val : val;
		}
		return this.setChannel('hsl', 0, val);
	},
	saturation: function (val) {
		return this.setChannel('hsl', 1, val);
	},
	lightness: function (val) {
		return this.setChannel('hsl', 2, val);
	},
	saturationv: function (val) {
		return this.setChannel('hsv', 1, val);
	},
	whiteness: function (val) {
		return this.setChannel('hwb', 1, val);
	},
	blackness: function (val) {
		return this.setChannel('hwb', 2, val);
	},
	value: function (val) {
		return this.setChannel('hsv', 2, val);
	},
	cyan: function (val) {
		return this.setChannel('cmyk', 0, val);
	},
	magenta: function (val) {
		return this.setChannel('cmyk', 1, val);
	},
	yellow: function (val) {
		return this.setChannel('cmyk', 2, val);
	},
	black: function (val) {
		return this.setChannel('cmyk', 3, val);
	},

	hexString: function () {
		return string.hexString(this.values.rgb);
	},
	rgbString: function () {
		return string.rgbString(this.values.rgb, this.values.alpha);
	},
	rgbaString: function () {
		return string.rgbaString(this.values.rgb, this.values.alpha);
	},
	percentString: function () {
		return string.percentString(this.values.rgb, this.values.alpha);
	},
	hslString: function () {
		return string.hslString(this.values.hsl, this.values.alpha);
	},
	hslaString: function () {
		return string.hslaString(this.values.hsl, this.values.alpha);
	},
	hwbString: function () {
		return string.hwbString(this.values.hwb, this.values.alpha);
	},
	keyword: function () {
		return string.keyword(this.values.rgb, this.values.alpha);
	},

	rgbNumber: function () {
		var rgb = this.values.rgb;
		return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.values.rgb;
		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}
		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();
		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}
		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.values.rgb;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = [];
		for (var i = 0; i < 3; i++) {
			rgb[i] = 255 - this.values.rgb[i];
		}
		this.setValues('rgb', rgb);
		return this;
	},

	lighten: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	darken: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	saturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	desaturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	whiten: function (ratio) {
		var hwb = this.values.hwb;
		hwb[1] += hwb[1] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	blacken: function (ratio) {
		var hwb = this.values.hwb;
		hwb[2] += hwb[2] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	greyscale: function () {
		var rgb = this.values.rgb;
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		this.setValues('rgb', [val, val, val]);
		return this;
	},

	clearer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha - (alpha * ratio));
		return this;
	},

	opaquer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha + (alpha * ratio));
		return this;
	},

	rotate: function (degrees) {
		var hsl = this.values.hsl;
		var hue = (hsl[0] + degrees) % 360;
		hsl[0] = hue < 0 ? 360 + hue : hue;
		this.setValues('hsl', hsl);
		return this;
	},

	/**
	 * Ported from sass implementation in C
	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
	 */
	mix: function (mixinColor, weight) {
		var color1 = this;
		var color2 = mixinColor;
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return this
			.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue()
			)
			.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
	},

	toJSON: function () {
		return this.rgb();
	},

	clone: function () {
		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
		// making the final build way to big to embed in Chart.js. So let's do it manually,
		// assuming that values to clone are 1 dimension arrays containing only numbers,
		// except 'alpha' which is a number.
		var result = new Color();
		var source = this.values;
		var target = result.values;
		var value, type;

		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				value = source[prop];
				type = ({}).toString.call(value);
				if (type === '[object Array]') {
					target[prop] = value.slice(0);
				} else if (type === '[object Number]') {
					target[prop] = value;
				} else {
					console.error('unexpected color value:', value);
				}
			}
		}

		return result;
	}
};

Color.prototype.spaces = {
	rgb: ['red', 'green', 'blue'],
	hsl: ['hue', 'saturation', 'lightness'],
	hsv: ['hue', 'saturation', 'value'],
	hwb: ['hue', 'whiteness', 'blackness'],
	cmyk: ['cyan', 'magenta', 'yellow', 'black']
};

Color.prototype.maxes = {
	rgb: [255, 255, 255],
	hsl: [360, 100, 100],
	hsv: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues = function (space) {
	var values = this.values;
	var vals = {};

	for (var i = 0; i < space.length; i++) {
		vals[space.charAt(i)] = values[space][i];
	}

	if (values.alpha !== 1) {
		vals.a = values.alpha;
	}

	// {r: 255, g: 255, b: 255, a: 0.4}
	return vals;
};

Color.prototype.setValues = function (space, vals) {
	var values = this.values;
	var spaces = this.spaces;
	var maxes = this.maxes;
	var alpha = 1;
	var i;

	this.valid = true;

	if (space === 'alpha') {
		alpha = vals;
	} else if (vals.length) {
		// [10, 10, 10]
		values[space] = vals.slice(0, space.length);
		alpha = vals[space.length];
	} else if (vals[space.charAt(0)] !== undefined) {
		// {r: 10, g: 10, b: 10}
		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[space.charAt(i)];
		}

		alpha = vals.a;
	} else if (vals[spaces[space][0]] !== undefined) {
		// {red: 10, green: 10, blue: 10}
		var chans = spaces[space];

		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[chans[i]];
		}

		alpha = vals.alpha;
	}

	values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

	if (space === 'alpha') {
		return false;
	}

	var capped;

	// cap values of the space prior converting all values
	for (i = 0; i < space.length; i++) {
		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
		values[space][i] = Math.round(capped);
	}

	// convert to all the other color spaces
	for (var sname in spaces) {
		if (sname !== space) {
			values[sname] = convert[space][sname](values[space]);
		}
	}

	return true;
};

Color.prototype.setSpace = function (space, args) {
	var vals = args[0];

	if (vals === undefined) {
		// color.rgb()
		return this.getValues(space);
	}

	// color.rgb(10, 10, 10)
	if (typeof vals === 'number') {
		vals = Array.prototype.slice.call(args);
	}

	this.setValues(space, vals);
	return this;
};

Color.prototype.setChannel = function (space, index, val) {
	var svalues = this.values[space];
	if (val === undefined) {
		// color.red()
		return svalues[index];
	} else if (val === svalues[index]) {
		// color.red(color.red())
		return this;
	}

	// color.red(100)
	svalues[index] = val;
	this.setValues(space, svalues);

	return this;
};

if (typeof window !== 'undefined') {
	window.Color = Color;
}

module.exports = Color;

},{"chartjs-color-string":44,"color-convert":47}],46:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],47:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":46}],48:[function(require,module,exports){
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],49:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],50:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],51:[function(require,module,exports){
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      var left = arguments[0].left;
      var top = arguments[0].top;

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          typeof left === 'number' ? left : this.scrollLeft,
          typeof top === 'number' ? top : this.scrollTop
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(
          this,
          arguments[0] === undefined ? true : arguments[0]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);

},{}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var toArray = exports.toArray = function toArray(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return arrayLike;
  }

  if (arrayLike instanceof Node) {
    return [arrayLike];
  }

  return Array.prototype.slice.call(arrayLike);
};

var $ = exports.$ = function $(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll.call(context, selector));
};

var selector = exports.selector = function selector(block, elem, modName, modVal) {
  return block + '__' + elem + (modName ? modVal ? '_' + modName + '_' + modVal : '_' + modName : '');
};

var buildClass = exports.buildClass = function buildClass() {
  return '.' + selector.apply(undefined, arguments);
};

var BEM = exports.BEM = function (_ref) {
  _inherits(BEM, _ref);

  function BEM(name, node) {
    _classCallCheck(this, BEM);

    var _this = _possibleConstructorReturn(this, (BEM.__proto__ || Object.getPrototypeOf(BEM)).call(this));

    _this.node = node;
    _this.name = name;
    return _this;
  }

  _createClass(BEM, [{
    key: 'elem',
    value: function elem(name, modName, modVal) {
      return this.node.querySelector(buildClass(this.name, name, modName, modVal));
    }
  }, {
    key: 'elems',
    value: function elems(name, modName, modVal) {
      return $(buildClass(this.name, name, modName, modVal), this.node);
    }
  }, {
    key: 'setMod',
    value: function setMod(elem, elemName, modName, modValue) {
      var _this2 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.add(selector(_this2.name, elemName, modName, modValue));
      });

      return this;
    }
  }, {
    key: 'delMod',
    value: function delMod(elem, elemName, modName) {
      var _this3 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.remove(selector(_this3.name, elemName, modName));
      });

      return this;
    }
  }]);

  return BEM;
}(null);

},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feedback = function (_BEM) {
  _inherits(Feedback, _BEM);

  function Feedback(node) {
    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this, 'feedback', node));

    _this.$name = _this.elem('name');
    _this.$message = _this.elem('message');
    _this.$mailTo = _this.elem('mailto');

    node.onsubmit = function (e) {
      e.preventDefault();

      _this.$mailTo.href = 'mailto:info@nszu.gov.ua?subject=\u0417\u0432\u043E\u0440\u043E\u0442\u043D\u0456\u0439 \u0437\u0432\u2019\u044F\u0437\u043E\u043A \u0432\u0456\u0434 ' + _this.$name.value + '&body=' + _this.$message.value;
      _this.$mailTo.click();
      return false;
    };
    return _this;
  }

  return Feedback;
}(_dom.BEM);

exports.default = Feedback;
module.exports = exports['default'];

},{"./dom":52}],54:[function(require,module,exports){
'use strict';

var _promisePolyfill = require('promise-polyfill');

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _smoothscrollPolyfill = require('smoothscroll-polyfill');

var _smoothscrollPolyfill2 = _interopRequireDefault(_smoothscrollPolyfill);

var _chart = require('chart.js');

var _chart2 = _interopRequireDefault(_chart);

var _dom = require('./dom');

var _utils = require('./utils');

var _nav = require('./nav');

var _nav2 = _interopRequireDefault(_nav);

var _tabs = require('./tabs');

var _tabs2 = _interopRequireDefault(_tabs);

var _slider = require('./slider');

var _slider2 = _interopRequireDefault(_slider);

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _statistic = require('./statistic');

var _statistic2 = _interopRequireDefault(_statistic);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.Promise) {
  window.Promise = _promisePolyfill2.default;
}

_smoothscrollPolyfill2.default.polyfill();

(0, _dom.$)('.nav').forEach(function (node) {
  return new _nav2.default(node);
});
(0, _dom.$)('.tabs').forEach(function (node) {
  return new _tabs2.default(node);
});
(0, _dom.$)('.slider').forEach(function (node) {
  return new _slider2.default(node);
});
(0, _dom.$)('.feedback').forEach(function (node) {
  return new _feedback2.default(node);
});

(0, _utils.fetchJSON)('data/stats.json').then(function (data) {
  (0, _dom.$)('.map').forEach(function (node) {
    return new _map2.default(node, data.slice());
  });
  // $('.declarations').forEach(node => new Statistic(node, data));
});

var REGION__MAP = {
  "Київ": 502,
  "Луцьк": 523,
  "Львов": 423,
  "Ужгород": 324,
  "Ивано-Франковск": 232,
  "Черновцы": 252,
  "Тернополь": 232,
  "Ровно": 200,
  "Хмельницкий": 182,
  "Житомир": 132,
  "Винница": 92,
  "Черкассы": 82,
  "Кировоград": 66,
  "Полтава": 50,
  "Чернигов": 32,
  "Суммы": 12,
  "Харьков": 9,
  "Луганск": 8,
  "Днепропетровск": 7,
  "Донецк": 6,
  "Запорожье": 5,
  "Херсон": 4,
  "Николаев": 3,
  "Одесса": 2,
  "Крым": 1
};

// Dinamical number of declaraion, mis, doctors
var dinamical_declaration = document.getElementById('declarations__graph-canvas').getContext('2d');
// const dinamical_doctors = document.getElementById('declarations__graph-canvas').getContext('2d');
// const dinamical_mis = document.getElementById('declarations__graph-canvas').getContext('2d');

var DATA = {
  labels: ["January", "February", "March", "April", "May", "June", "July"],
  datasets: [{
    label: "My First dataset",
    backgroundColor: 'rgb(98, 164, 240)',
    borderColor: 'rgb(72,98,237)',
    data: [0, 10, 12, 22, 29, 30, 45]
  }]
};

var customTooltips = function customTooltips(tooltip) {
  // Tooltip Element
  var tooltipEl = document.getElementById('chartjs-tooltip');
  if (!tooltipEl) {
    tooltipEl = document.createElement('div');
    tooltipEl.id = 'chartjs-tooltip';
    tooltipEl.innerHTML = "<table></table>";
    this._chart.canvas.offsetParent.appendChild(tooltipEl);
  }
  // Hide if no tooltip
  if (tooltip.opacity === 0) {
    tooltipEl.style.opacity = 0;
    return;
  }
  // Set caret Position
  tooltipEl.classList.remove('above', 'below', 'no-transform');
  if (tooltip.yAlign) {
    tooltipEl.classList.add(tooltip.yAlign);
  } else {
    tooltipEl.classList.add('no-transform');
  }
  function getBody(bodyItem) {
    return bodyItem.lines;
  }

  // Set Text
  if (tooltip.body) {
    var titleLines = tooltip.title || [];
    var bodyLines = tooltip.body.map(getBody);
    var innerHtml = '<thead>';
    titleLines.forEach(function (title) {
      innerHtml += '<tr><th>' + title + '</th></tr>';
    });
    innerHtml += '</thead><tbody>';
    bodyLines.forEach(function (body, i) {
      var colors = tooltip.labelColors[i];
      var style = 'background:' + colors.backgroundColor;
      style += '; border-color:' + colors.borderColor;
      style += '; border-width: 2px';
      var span = '<span class="chartjs-tooltip-key" style="' + style + '"></span>';
      innerHtml += '<tr><td>' + span + body + '</td></tr>';
    });
    innerHtml += '</tbody>';
    var tableRoot = tooltipEl.querySelector('table');
    tableRoot.innerHTML = innerHtml;
  }
  var positionY = this._eventPosition.x;
  var positionX = this._eventPosition.y;
  console.log('position', this, positionY, positionX);
  console.log('tooltip', tooltip.caretX, tooltip.caretX);

  // Display, position, and set styles for font
  tooltipEl.style.opacity = 1;
  tooltipEl.style.left = positionX + tooltip.caretX + 'px';
  tooltipEl.style.top = positionY + tooltip.caretY + 'px';
  tooltipEl.style.fontFamily = tooltip._fontFamily;
  tooltipEl.style.fontSize = tooltip.fontSize;
  tooltipEl.style.fontStyle = tooltip._fontStyle;
  tooltipEl.style.padding = tooltip.yPadding + 'px ' + tooltip.xPadding + 'px';
};

var dinamicalDeclarationChart = new _chart2.default(dinamical_declaration, {
  type: 'line',
  data: DATA,
  options: {
    title: {
      display: true,
      text: 'Chart.js Line Chart - Custom Tooltips'
    },
    scales: {
      xAxes: [{
        gridLines: {
          drawBorder: false,
          drawTicks: true,
          zeroLineWidth: 1,
          zeroLineColor: "rgba(232,232,232,1)"
        }
      }],
      yAxes: [{
        gridLines: {
          drawBorder: false,
          drawTicks: true,
          zeroLineWidth: 1,
          zeroLineColor: "rgba(232,232,232,1)"
        }
      }]
    },
    tooltips: {
      position: 'nearest',
      intersect: false,
      yPadding: 30,
      xPadding: 30,
      caretSize: 1,
      backgroundColor: '#fff',
      titleFontColor: '#000',
      bodyFontColor: '#000',
      borderColor: 'rgba(0,0,0,1)',
      borderWidth: 1,
      caretPadding: 40,
      cornerRadius: 0
    }
  }
});

// Number of declarations, mis, doctors
var NUMBER_BY_REGION_DECLARATION = document.getElementById('declarations_number__graph-canvas').getContext('2d');

var REGION_DECLARATIONS = {
  labels: Object.keys(REGION__MAP).map(function (i) {
    return i;
  }),
  datasets: [{
    backgroundColor: 'rgb(98, 164, 240)',
    borderColor: 'rgb(72,98,237)',
    data: Object.values(REGION__MAP).map(function (i) {
      return i;
    })
  }]
};

var NUMBER_BY_REGION = new _chart2.default(NUMBER_BY_REGION_DECLARATION, {
  type: 'horizontalBar',
  data: REGION_DECLARATIONS,
  onAnimationComplete: function onAnimationComplete() {
    console.log(this.chart);
    var ctx = this.chart.ctx;
    ctx.font = this.scale.font;
    ctx.fillStyle = this.scale.textColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    this.datasets.forEach(function (dataset) {
      dataset.bars.forEach(function (bar) {
        ctx.fillText(bar.value, bar.x, bar.y - 5);
      });
    });
  },
  scaleLineColor: "rgba(0,0,0,0)",
  options: {
    title: {
      display: false
    },
    legend: {
      display: false,
      labels: {
        padding: 20
      }
    },
    tooltipTemplate: "<%= value %>",
    scaleLineColor: "rgba(0,0,0,0)",
    scales: {
      xAxes: [{
        gridLines: {
          lineWidth: 0,
          display: false,
          drawBorder: false,
          drawTicks: false
        },
        ticks: {
          display: false
        }
      }],
      yAxes: [{
        barPercentage: 0.95,
        categoryPercentage: 1,
        ticks: {
          padding: 25
        },
        gridLines: {
          display: false,
          drawBorder: false,
          drawTicks: false
        }
      }]
    },
    tooltips: {
      enabled: false
    },
    hover: {
      animationDuration: 0
    },
    animation: {
      duration: 1,
      onComplete: function onComplete() {
        var chartInstance = this.chart,
            ctx = chartInstance.ctx;
        ctx.font = _chart2.default.helpers.fontString(14, '700', 'GothamPro');
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#000';

        this.data.datasets.forEach(function (dataset, i) {
          var meta = chartInstance.controller.getDatasetMeta(i);
          meta.data.forEach(function (bar, index) {
            var data = dataset.data[index];
            ctx.fillText(data, bar._model.x + 20, bar._model.y + 7);
          });
        });
      }
    }
  }
});

},{"./dom":52,"./feedback":53,"./map":55,"./nav":56,"./slider":57,"./statistic":58,"./tabs":59,"./utils":60,"chart.js":1,"promise-polyfill":50,"smoothscroll-polyfill":51}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require("./dom");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HOVER_DEBOUNCE_TIMEOUT = 200;

var REGION_POINT_MAP = {
  "Київ": { left: 453, top: 170 },
  "Луцьк": { left: 153, top: 100 },
  "Львов": { left: 83, top: 206 },
  "Ужгород": { left: 48, top: 312 },
  "Ивано-Франковск": { left: 153, top: 312 },
  "Черновцы": { left: 207, top: 329 },
  "Тернополь": { left: 188, top: 241 },
  "Ровно": { left: 241, top: 100 },
  "Хмельницкий": { left: 259, top: 206 },
  "Житомир": { left: 347, top: 153 },
  "Винница": { left: 365, top: 277 },
  "Черкассы": { left: 523, top: 241 },
  "Кировоград": { left: 541, top: 312 },
  "Полтава": { left: 646, top: 188 },
  "Чернигов": { left: 541, top: 65 },
  "Суммы": { left: 646, top: 100 },
  "Харьков": { left: 770, top: 205 },
  "Луганск": { left: 911, top: 259 },
  "Днепропетровск": { left: 682, top: 311 },
  "Донецк": { left: 840, top: 347 },
  "Запорожье": { left: 752, top: 417 },
  "Херсон": { left: 629, top: 452 },
  "Николаев": { left: 523, top: 399 },
  "Одесса": { left: 453, top: 435 },
  "Крым": { left: 664, top: 558 }
};

var createPoint = function createPoint(_ref) {
  var left = _ref.left,
      top = _ref.top;

  var node = document.createElement('div');

  node.classList.add('map__point');
  node.style.left = left + "px";
  node.style.top = top + "px";

  return node;
};

var Map = function (_BEM) {
  _inherits(Map, _BEM);

  function Map(node, data) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, 'map', node));

    _this.data = [];
    _this.timeout = null;


    _this.data = data;
    _this.$tooltip = _this.elem('tooltip');

    var fragment = document.createDocumentFragment();

    data.forEach(function (item, index) {
      var point = createPoint(REGION_POINT_MAP[item.region_name]);
      point.dataset.index = index;

      point.addEventListener('mouseover', _this, false);
      point.addEventListener('mouseout', _this, false);

      fragment.appendChild(point);
    });

    _this.$tooltip.addEventListener('mouseover', _this, false);
    _this.$tooltip.addEventListener('mouseout', _this, false);

    _this.elem('main').appendChild(fragment);
    return _this;
  }

  _createClass(Map, [{
    key: "handleEvent",
    value: function handleEvent(_ref2) {
      var _this2 = this;

      var target = _ref2.target,
          type = _ref2.type;

      if (type === 'mouseover' && target.dataset.index) {
        this.$tooltip.style.top = target.style.top;
        this.$tooltip.style.left = target.style.left;
      }

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        switch (type) {
          case 'mouseout':
            _this2.delMod(_this2.$tooltip, 'tooltip', 'show');
            _this2.delMod(_this2.$active, 'point', 'active');
            break;
          case 'mouseover':
            var data = _this2.data[target.dataset.index];

            if (data) {
              var $tooltipData = _this2.$tooltip.querySelectorAll((0, _dom.buildClass)('map', 'tooltip-data') + " dt");

              _this2.$tooltip.style.top = target.style.top;
              _this2.$tooltip.style.left = target.style.left;

              _this2.$active && _this2.delMod(_this2.$active, 'point', 'active');
              _this2.setMod(_this2.$tooltip, 'tooltip', 'show');

              _this2.$tooltip.querySelector((0, _dom.buildClass)('map', 'tooltip-title')).textContent = data.region_name;
              _this2.$active = target;

              $tooltipData[0].textContent = data.medical_system_providers;
              $tooltipData[1].textContent = data.doctors;
              $tooltipData[2].textContent = data.declarations_signed;

              _this2.setMod(_this2.$active, 'point', 'active');
            }

            _this2.setMod(_this2.$tooltip, 'tooltip', 'show');
            break;
        }
      }, HOVER_DEBOUNCE_TIMEOUT);
    }
  }]);

  return Map;
}(_dom.BEM);

exports.default = Map;
module.exports = exports["default"];

},{"./dom":52}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Nav = function Nav(node) {
  _classCallCheck(this, Nav);

  node.addEventListener('click', function (e) {
    e.preventDefault();

    if (e.target.href === undefined) {
      return;
    }

    var to = e.target.href.split('#')[1];

    var _document$getElementB = document.getElementById(to).getBoundingClientRect(),
        top = _document$getElementB.top;

    window.scroll({ top: top + window.scrollY - 50, left: 0, behavior: 'smooth' });
  });
};

exports.default = Nav;
module.exports = exports['default'];

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createMarker = function createMarker() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var node = document.createElement('li');

  node.classList.add((0, _dom.selector)('slider', 'marker'));
  active && node.classList.add((0, _dom.selector)('slider', 'marker', 'active'));

  return node;
};

var Slider = function (_BEM) {
  _inherits(Slider, _BEM);

  function Slider(node) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', node));

    _this.currentIndex = 0;

    _this.$slides = _this.elems('slide');

    _this.$markers = [];

    _this.$control = document.createElement('ul');
    _this.$control.classList.add((0, _dom.selector)(_this.name, 'markers'));

    _this.$slides.forEach(function (node, index) {
      var marker = createMarker(index === _this.currentIndex);
      _this.$control.appendChild(marker);
      _this.$markers.push(marker);
    });

    _this.$control.addEventListener('click', function (_ref) {
      var target = _ref.target;

      if (!target.closest((0, _dom.buildClass)(_this.name, 'marker'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('marker', 'active'), 'marker', 'active');
      _this.setMod(target, 'marker', 'active');

      _this.slide(toIndex);
    }, false);

    _this.node.appendChild(_this.$control);
    return _this;
  }

  _createClass(Slider, [{
    key: 'slide',
    value: function slide(index) {
      var isNext = this.currentIndex < index;

      this.$slides[this.currentIndex].animate([{ transform: 'translateX(0)' }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)' }], this.constructor.ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)' }, { transform: 'translateX(0)' }], this.constructor.ANIMATION_OPTIONS);

      this.currentIndex = index;
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$markers.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Slider;
}(_dom.BEM);

Slider.ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};
exports.default = Slider;
module.exports = exports['default'];

},{"./dom":52}],58:[function(require,module,exports){
// import { BEM, selector } from './dom';
// import { numberFormatting } from './utils';
//
// const COLORS_MAP = [
//   '#90c8e6', '#b097c6', '#dfb0d0',
//   '#e3aab8', '#afd5e7', '#c7b2d5',
//   '#e9c7df', '#ecc7cf', '#f1eec9',
//   '#ced8e2', '#5da892', '#5296cd',
//   '#a3d7f2', '#f3f1a0', '#bcdad5',
//   '#71b7a8', '#5ca9dc', '#dc91a3',
//   '#d8816f', '#e2a394', '#7566aa',
//   '#cadfeb', '#ddd2df', '#f4d9b5',
//   '#d381b2'
// ];
//
// const createListItemNode = (title, value, color) => {
//   const $li = document.createElement('li');
//   const $span = document.createElement('span');
//   const $value = document.createElement('div');
//
//   $li.classList.add(selector('declarations', 'list-item'));
//   $li.textContent = title;
//
//   $span.style.backgroundColor = color;
//
//   $value.classList.add(selector('declarations', 'list-item-value'));
//   $value.textContent = numberFormatting(value);
//
//   $li.prepend($span);
//   $li.append($value);
//
//   return $li;
// };
//
// export default class Statistic extends BEM {
//   constructor(node, data) {
//     super('declarations', node);
//
//     const fragment = document.createDocumentFragment();
//
//     this.$canvas = this.elem('graph-canvas');
//     this.context = this.$canvas.getContext('2d');
//
//     const total = data.reduce((target, { declarations }) => target + declarations, 0);
//
//     data.sort((a, b) => a.declarations < b.declarations ? 1 : -1);
//
//     let [x, y, r, s] = [490, 490, 480, 0];
//
//     data.forEach((item, index) => {
//       const $item = createListItemNode(
//         item.region_name,
//         item.declarations,
//         COLORS_MAP[index]
//       );
//
//       fragment.appendChild($item);
//
//       let radians = ((item.declarations / data[0].declarations) * 360) * (Math.PI / 360);
//
//       this.context.beginPath();
//       this.context.lineWidth = 6;
//       this.context.strokeStyle = COLORS_MAP[index];
//       this.context.arc(x, y, r - (20 * index), s, radians, false);
//       this.context.stroke();
//     });
//
//     this.elem('list').appendChild(fragment);
//     this.elem('total-value').textContent = numberFormatting(total);
//   }
// }
"use strict";

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PANEL_ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};

var Tabs = function (_BEM) {
  _inherits(Tabs, _BEM);

  function Tabs(node) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoHeight = _ref.autoHeight,
        autoHeight = _ref$autoHeight === undefined ? false : _ref$autoHeight;

    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, 'tabs', node));

    _this.$controls = _this.elems('nav-item');
    _this.$slides = _this.elems('slide');

    _this.$marker = document.createElement('div');
    _this.$marker.classList.add((0, _dom.selector)(_this.name, 'marker'));
    _this.elem('header').appendChild(_this.$marker);

    if (autoHeight) {
      var maxHeight = _this.$slides.reduce(function (target, item) {
        if (item.clientHeight > target) {
          target = item.clientHeight;
        }

        return target;
      }, 0);

      _this.elem('main').style.height = maxHeight + 'px';
    }

    _this.currentIndex = _this.getIndexByElem(_this.elem('nav-item', 'active'));

    _this.elem('nav').addEventListener('click', function (e) {
      var $elem = e.target.closest((0, _dom.buildClass)(_this.name, 'nav-item'));

      if (!$elem) {
        return;
      }

      var toIndex = _this.getIndexByElem($elem);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('nav-item', 'active'), 'nav-item', 'active');
      _this.setMod($elem, 'nav-item', 'active');

      _this.animatePanels(toIndex);
      _this.animateMarker(toIndex);

      _this.currentIndex = toIndex;
    }, false);

    _this.setMod(_this.elem('nav-item', 'active'), 'nav-item', 'marker');
    return _this;
  }

  _createClass(Tabs, [{
    key: 'animatePanels',
    value: function animatePanels(index) {
      var current = this.currentIndex;
      var isNext = current < index;

      current !== undefined && this.$slides[current].animate([{ transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)', opacity: 0 }], PANEL_ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)', opacity: 0 }, { transform: 'translateX(0)', opacity: 1 }], PANEL_ANIMATION_OPTIONS);
    }
  }, {
    key: 'animateMarker',
    value: function animateMarker(index) {
      var _this2 = this;

      var current = {
        left: this.$controls[this.currentIndex].offsetLeft,
        width: this.$controls[this.currentIndex].clientWidth
      };

      var left = this.$controls[index].offsetLeft;
      var width = this.$controls[index].clientWidth;

      var player = this.$marker.animate([{
        transform: 'translateX(' + current.left + 'px)',
        width: current.width + 'px'
      }, {
        transform: 'translateX(' + left + 'px)',
        width: width + 'px'
      }], _extends({}, PANEL_ANIMATION_OPTIONS));

      player.onfinish = function () {
        _this2.setMod(_this2.$controls[index], 'nav-item', 'marker');
        requestAnimationFrame(function () {
          return player.cancel();
        });
      };

      this.delMod(this.$controls[this.currentIndex], 'nav-item', 'marker');
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$controls.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Tabs;
}(_dom.BEM);

exports.default = Tabs;
module.exports = exports['default'];

},{"./dom":52}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var objectToQuery = function objectToQuery(target) {
  return '?' + Object.keys(target).reduce(function (arr, key) {
    return arr.push(key + '=' + target[key]) && arr;
  }, []).join('&');
};

var numberFormatting = exports.numberFormatting = function numberFormatting(number) {
  return number.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1 ').split('.')[0];
};

var fetchJSON = exports.fetchJSON = function fetchJSON(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { method: 'GET' };
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();

    if (options.body && options.method === 'GET') {
      url += objectToQuery(options.body);
    }

    request.onreadystatechange = function () {
      if (request.readyState !== 4) {
        return;
      }

      resolve(JSON.parse(request.responseText));
    };

    request.onerror = reject;
    request.open(options.method || 'GET', url);
    request.send(options.body ? JSON.stringify(options.body) : null);
  });
};

},{}]},{},[54])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NoYXJ0LmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jaGFydHMvQ2hhcnQuQmFyLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jaGFydHMvQ2hhcnQuQnViYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jaGFydHMvQ2hhcnQuRG91Z2hudXQuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NoYXJ0cy9DaGFydC5MaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jaGFydHMvQ2hhcnQuUG9sYXJBcmVhLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jaGFydHMvQ2hhcnQuUmFkYXIuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NoYXJ0cy9DaGFydC5TY2F0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJhci5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuZG91Z2hudXQuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucmFkYXIuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb24uanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jYW52YXNIZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0U2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGVTZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudGlja3MuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmFyYy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnJlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm1zL3BsYXRmb3JtLmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm1zL3BsYXRmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udGl0bGUuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5jYXRlZ29yeS5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhcmJhc2UuanMiLCJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5sb2dhcml0aG1pYy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnJhZGlhbExpbmVhci5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCJub2RlX21vZHVsZXMvY2hhcnRqcy1jb2xvci1zdHJpbmcvY29sb3Itc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NoYXJ0anMtY29sb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhcnRqcy1jb2xvci9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFydGpzLWNvbG9yL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzIiwic3JjL3NjcmlwdHMvZG9tLmpzIiwic3JjL3NjcmlwdHMvZmVlZGJhY2suanMiLCJzcmMvc2NyaXB0cy9tYWluLmpzIiwic3JjL3NjcmlwdHMvbWFwLmpzIiwic3JjL3NjcmlwdHMvbmF2LmpzIiwic3JjL3NjcmlwdHMvc2xpZGVyLmpzIiwic3JjL3NjcmlwdHMvc3RhdGlzdGljLmpzIiwic3JjL3NjcmlwdHMvdGFicy5qcyIsInNyYy9zY3JpcHRzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3g5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvMklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdFVPLElBQU0sNEJBQVUsU0FBVixPQUFVLFlBQWE7QUFDbEMsTUFBSSxNQUFNLE9BQU4sQ0FBYyxTQUFkLENBQUosRUFBOEI7QUFDNUIsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQsTUFBSSxxQkFBcUIsSUFBekIsRUFBK0I7QUFDN0IsV0FBTyxDQUFDLFNBQUQsQ0FBUDtBQUNEOztBQUVELFNBQU8sTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQVA7QUFDRCxDQVZNOztBQVlBLElBQU0sZ0JBQUksU0FBSixDQUFJLENBQUMsUUFBRDtBQUFBLE1BQVcsT0FBWCx1RUFBcUIsUUFBckI7QUFBQSxTQUNmLFFBQVEsUUFBUSxnQkFBUixDQUF5QixJQUF6QixDQUE4QixPQUE5QixFQUF1QyxRQUF2QyxDQUFSLENBRGU7QUFBQSxDQUFWOztBQUlBLElBQU0sOEJBQVcsU0FBWCxRQUFXLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCLE1BQXZCO0FBQUEsU0FDbkIsS0FEbUIsVUFDVCxJQURTLElBQ0YsVUFBVyxlQUFhLE9BQWIsU0FBd0IsTUFBeEIsU0FBdUMsT0FBbEQsR0FBK0QsRUFEN0Q7QUFBQSxDQUFqQjs7QUFJQSxJQUFNLGtDQUFhLFNBQWIsVUFBYTtBQUFBLGVBQWlCLG9DQUFqQjtBQUFBLENBQW5COztJQUVNLEcsV0FBQSxHOzs7QUFDWCxlQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0I7QUFBQTs7QUFBQTs7QUFFdEIsVUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLFVBQUssSUFBTCxHQUFZLElBQVo7QUFIc0I7QUFJdkI7Ozs7eUJBRUksSSxFQUFNLE8sRUFBUyxNLEVBQVE7QUFDMUIsYUFBTyxLQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFdBQVcsS0FBSyxJQUFoQixFQUFzQixJQUF0QixFQUE0QixPQUE1QixFQUFxQyxNQUFyQyxDQUF4QixDQUFQO0FBQ0Q7OzswQkFFSyxJLEVBQU0sTyxFQUFTLE0sRUFBUTtBQUMzQixhQUFPLEVBQUUsV0FBVyxLQUFLLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCLE9BQTVCLEVBQXFDLE1BQXJDLENBQUYsRUFBZ0QsS0FBSyxJQUFyRCxDQUFQO0FBQ0Q7OzsyQkFFTSxJLEVBQU0sUSxFQUFVLE8sRUFBUyxRLEVBQVU7QUFBQTs7QUFDeEMsY0FBUSxJQUFSLEVBQWMsT0FBZCxDQUFzQjtBQUFBLGVBQ3BCLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsU0FBUyxPQUFLLElBQWQsRUFBb0IsUUFBcEIsRUFBOEIsT0FBOUIsRUFBdUMsUUFBdkMsQ0FBbkIsQ0FEb0I7QUFBQSxPQUF0Qjs7QUFJQSxhQUFPLElBQVA7QUFDRDs7OzJCQUVNLEksRUFBTSxRLEVBQVUsTyxFQUFTO0FBQUE7O0FBQzlCLGNBQVEsSUFBUixFQUFjLE9BQWQsQ0FBc0I7QUFBQSxlQUNwQixLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFNBQVMsT0FBSyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLE9BQTlCLENBQXRCLENBRG9CO0FBQUEsT0FBdEI7O0FBSUEsYUFBTyxJQUFQO0FBQ0Q7Ozs7RUE3QnNCLEk7Ozs7Ozs7OztBQ3RCekI7Ozs7Ozs7O0lBRXFCLFE7OztBQUNuQixvQkFBWSxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsb0hBQ1YsVUFEVSxFQUNFLElBREY7O0FBR2hCLFVBQUssS0FBTCxHQUFhLE1BQUssSUFBTCxDQUFVLE1BQVYsQ0FBYjtBQUNBLFVBQUssUUFBTCxHQUFnQixNQUFLLElBQUwsQ0FBVSxTQUFWLENBQWhCO0FBQ0EsVUFBSyxPQUFMLEdBQWUsTUFBSyxJQUFMLENBQVUsUUFBVixDQUFmOztBQUVBLFNBQUssUUFBTCxHQUFnQixVQUFDLENBQUQsRUFBTztBQUNyQixRQUFFLGNBQUY7O0FBRUEsWUFBSyxPQUFMLENBQWEsSUFBYiw2SkFBNkUsTUFBSyxLQUFMLENBQVcsS0FBeEYsY0FBc0csTUFBSyxRQUFMLENBQWMsS0FBcEg7QUFDQSxZQUFLLE9BQUwsQ0FBYSxLQUFiO0FBQ0EsYUFBTyxLQUFQO0FBQ0QsS0FORDtBQVBnQjtBQWNqQjs7Ozs7a0JBZmtCLFE7Ozs7OztBQ0ZyQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUksQ0FBQyxPQUFPLE9BQVosRUFBcUI7QUFDbkIsU0FBTyxPQUFQO0FBQ0Q7O0FBRUQsK0JBQWEsUUFBYjs7QUFFQSxZQUFFLE1BQUYsRUFBVSxPQUFWLENBQWtCO0FBQUEsU0FBUSxrQkFBUSxJQUFSLENBQVI7QUFBQSxDQUFsQjtBQUNBLFlBQUUsT0FBRixFQUFXLE9BQVgsQ0FBbUI7QUFBQSxTQUFRLG1CQUFTLElBQVQsQ0FBUjtBQUFBLENBQW5CO0FBQ0EsWUFBRSxTQUFGLEVBQWEsT0FBYixDQUFxQjtBQUFBLFNBQVEscUJBQVcsSUFBWCxDQUFSO0FBQUEsQ0FBckI7QUFDQSxZQUFFLFdBQUYsRUFBZSxPQUFmLENBQXVCO0FBQUEsU0FBUSx1QkFBYSxJQUFiLENBQVI7QUFBQSxDQUF2Qjs7QUFFQSxzQkFBVSxpQkFBVixFQUE2QixJQUE3QixDQUFrQyxnQkFBUTtBQUN4QyxjQUFFLE1BQUYsRUFBVSxPQUFWLENBQWtCO0FBQUEsV0FBUSxrQkFBUSxJQUFSLEVBQWMsS0FBSyxLQUFMLEVBQWQsQ0FBUjtBQUFBLEdBQWxCO0FBQ0E7QUFDRCxDQUhEOztBQUtBLElBQU0sY0FBYztBQUNsQixVQUFRLEdBRFU7QUFFbEIsV0FBUyxHQUZTO0FBR2xCLFdBQVMsR0FIUztBQUlsQixhQUFXLEdBSk87QUFLbEIscUJBQW1CLEdBTEQ7QUFNbEIsY0FBWSxHQU5NO0FBT2xCLGVBQWEsR0FQSztBQVFsQixXQUFTLEdBUlM7QUFTbEIsaUJBQWUsR0FURztBQVVsQixhQUFXLEdBVk87QUFXbEIsYUFBVyxFQVhPO0FBWWxCLGNBQVksRUFaTTtBQWFsQixnQkFBYyxFQWJJO0FBY2xCLGFBQVcsRUFkTztBQWVsQixjQUFZLEVBZk07QUFnQmxCLFdBQVMsRUFoQlM7QUFpQmxCLGFBQVcsQ0FqQk87QUFrQmxCLGFBQVcsQ0FsQk87QUFtQmxCLG9CQUFrQixDQW5CQTtBQW9CbEIsWUFBVSxDQXBCUTtBQXFCbEIsZUFBYSxDQXJCSztBQXNCbEIsWUFBVSxDQXRCUTtBQXVCbEIsY0FBWSxDQXZCTTtBQXdCbEIsWUFBVSxDQXhCUTtBQXlCbEIsVUFBUTtBQXpCVSxDQUFwQjs7QUE0QkE7QUFDQSxJQUFNLHdCQUF3QixTQUFTLGNBQVQsQ0FBd0IsNEJBQXhCLEVBQXNELFVBQXRELENBQWlFLElBQWpFLENBQTlCO0FBQ0E7QUFDQTs7QUFFQSxJQUFNLE9BQU87QUFDWCxVQUFRLENBQUMsU0FBRCxFQUFZLFVBQVosRUFBd0IsT0FBeEIsRUFBaUMsT0FBakMsRUFBMEMsS0FBMUMsRUFBaUQsTUFBakQsRUFBeUQsTUFBekQsQ0FERztBQUVYLFlBQVUsQ0FBQztBQUNULFdBQU8sa0JBREU7QUFFVCxxQkFBaUIsbUJBRlI7QUFHVCxpQkFBYSxnQkFISjtBQUlULFVBQU0sQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCO0FBSkcsR0FBRDtBQUZDLENBQWI7O0FBVUEsSUFBTSxpQkFBaUIsU0FBakIsY0FBaUIsQ0FBUyxPQUFULEVBQWtCO0FBQ3ZDO0FBQ0EsTUFBSSxZQUFZLFNBQVMsY0FBVCxDQUF3QixpQkFBeEIsQ0FBaEI7QUFDQSxNQUFJLENBQUMsU0FBTCxFQUFnQjtBQUNkLGdCQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsY0FBVSxFQUFWLEdBQWUsaUJBQWY7QUFDQSxjQUFVLFNBQVYsR0FBc0IsaUJBQXRCO0FBQ0EsU0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixZQUFuQixDQUFnQyxXQUFoQyxDQUE0QyxTQUE1QztBQUNEO0FBQ0Q7QUFDQSxNQUFJLFFBQVEsT0FBUixLQUFvQixDQUF4QixFQUEyQjtBQUN6QixjQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsR0FBMEIsQ0FBMUI7QUFDQTtBQUNEO0FBQ0Q7QUFDQSxZQUFVLFNBQVYsQ0FBb0IsTUFBcEIsQ0FBMkIsT0FBM0IsRUFBb0MsT0FBcEMsRUFBNkMsY0FBN0M7QUFDQSxNQUFJLFFBQVEsTUFBWixFQUFvQjtBQUNsQixjQUFVLFNBQVYsQ0FBb0IsR0FBcEIsQ0FBd0IsUUFBUSxNQUFoQztBQUNELEdBRkQsTUFFTztBQUNMLGNBQVUsU0FBVixDQUFvQixHQUFwQixDQUF3QixjQUF4QjtBQUNEO0FBQ0QsV0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ3pCLFdBQU8sU0FBUyxLQUFoQjtBQUNEOztBQUVEO0FBQ0EsTUFBSSxRQUFRLElBQVosRUFBa0I7QUFDaEIsUUFBTSxhQUFhLFFBQVEsS0FBUixJQUFpQixFQUFwQztBQUNBLFFBQU0sWUFBWSxRQUFRLElBQVIsQ0FBYSxHQUFiLENBQWlCLE9BQWpCLENBQWxCO0FBQ0EsUUFBSSxZQUFZLFNBQWhCO0FBQ0EsZUFBVyxPQUFYLENBQW1CLFVBQVMsS0FBVCxFQUFnQjtBQUNqQyxtQkFBYSxhQUFhLEtBQWIsR0FBcUIsWUFBbEM7QUFDRCxLQUZEO0FBR0EsaUJBQWEsaUJBQWI7QUFDQSxjQUFVLE9BQVYsQ0FBa0IsVUFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQjtBQUNsQyxVQUFNLFNBQVMsUUFBUSxXQUFSLENBQW9CLENBQXBCLENBQWY7QUFDQSxVQUFJLFFBQVEsZ0JBQWdCLE9BQU8sZUFBbkM7QUFDQSxlQUFTLG9CQUFvQixPQUFPLFdBQXBDO0FBQ0EsZUFBUyxxQkFBVDtBQUNBLFVBQUksT0FBTyw4Q0FBOEMsS0FBOUMsR0FBc0QsV0FBakU7QUFDQSxtQkFBYSxhQUFhLElBQWIsR0FBb0IsSUFBcEIsR0FBMkIsWUFBeEM7QUFDRCxLQVBEO0FBUUEsaUJBQWEsVUFBYjtBQUNBLFFBQUksWUFBWSxVQUFVLGFBQVYsQ0FBd0IsT0FBeEIsQ0FBaEI7QUFDQSxjQUFVLFNBQVYsR0FBc0IsU0FBdEI7QUFDRDtBQUNELE1BQUksWUFBWSxLQUFLLGNBQUwsQ0FBb0IsQ0FBcEM7QUFDQSxNQUFJLFlBQVksS0FBSyxjQUFMLENBQW9CLENBQXBDO0FBQ0EsVUFBUSxHQUFSLENBQVksVUFBWixFQUF3QixJQUF4QixFQUE4QixTQUE5QixFQUF5QyxTQUF6QztBQUNBLFVBQVEsR0FBUixDQUFZLFNBQVosRUFBdUIsUUFBUSxNQUEvQixFQUF1QyxRQUFRLE1BQS9DOztBQUVBO0FBQ0EsWUFBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLENBQTFCO0FBQ0EsWUFBVSxLQUFWLENBQWdCLElBQWhCLEdBQXVCLFlBQVksUUFBUSxNQUFwQixHQUE2QixJQUFwRDtBQUNBLFlBQVUsS0FBVixDQUFnQixHQUFoQixHQUFzQixZQUFZLFFBQVEsTUFBcEIsR0FBNkIsSUFBbkQ7QUFDQSxZQUFVLEtBQVYsQ0FBZ0IsVUFBaEIsR0FBNkIsUUFBUSxXQUFyQztBQUNBLFlBQVUsS0FBVixDQUFnQixRQUFoQixHQUEyQixRQUFRLFFBQW5DO0FBQ0EsWUFBVSxLQUFWLENBQWdCLFNBQWhCLEdBQTRCLFFBQVEsVUFBcEM7QUFDQSxZQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsR0FBMEIsUUFBUSxRQUFSLEdBQW1CLEtBQW5CLEdBQTJCLFFBQVEsUUFBbkMsR0FBOEMsSUFBeEU7QUFDRCxDQTNERDs7QUE2REEsSUFBTSw0QkFBNEIsb0JBQVUscUJBQVYsRUFBaUM7QUFDakUsUUFBTSxNQUQyRDtBQUVqRSxRQUFNLElBRjJEO0FBR2pFLFdBQVM7QUFDUCxXQUFPO0FBQ0wsZUFBUyxJQURKO0FBRUwsWUFBTTtBQUZELEtBREE7QUFLUCxZQUFRO0FBQ04sYUFBTyxDQUFDO0FBQ04sbUJBQVc7QUFDVCxzQkFBWSxLQURIO0FBRVQscUJBQVcsSUFGRjtBQUdULHlCQUFlLENBSE47QUFJVCx5QkFBZTtBQUpOO0FBREwsT0FBRCxDQUREO0FBU04sYUFBTyxDQUFDO0FBQ04sbUJBQVc7QUFDVCxzQkFBWSxLQURIO0FBRVQscUJBQVcsSUFGRjtBQUdULHlCQUFlLENBSE47QUFJVCx5QkFBZTtBQUpOO0FBREwsT0FBRDtBQVRELEtBTEQ7QUF1QlAsY0FBVTtBQUNSLGdCQUFVLFNBREY7QUFFUixpQkFBVyxLQUZIO0FBR1IsZ0JBQVUsRUFIRjtBQUlSLGdCQUFVLEVBSkY7QUFLUixpQkFBVyxDQUxIO0FBTVIsdUJBQWlCLE1BTlQ7QUFPUixzQkFBZ0IsTUFQUjtBQVFSLHFCQUFlLE1BUlA7QUFTUixtQkFBYSxlQVRMO0FBVVIsbUJBQWEsQ0FWTDtBQVdSLG9CQUFjLEVBWE47QUFZUixvQkFBYztBQVpOO0FBdkJIO0FBSHdELENBQWpDLENBQWxDOztBQTRDQTtBQUNBLElBQU0sK0JBQStCLFNBQVMsY0FBVCxDQUF3QixtQ0FBeEIsRUFBNkQsVUFBN0QsQ0FBd0UsSUFBeEUsQ0FBckM7O0FBRUEsSUFBTSxzQkFBc0I7QUFDMUIsVUFBUSxPQUFPLElBQVAsQ0FBWSxXQUFaLEVBQXlCLEdBQXpCLENBQThCO0FBQUEsV0FBSyxDQUFMO0FBQUEsR0FBOUIsQ0FEa0I7QUFFMUIsWUFBVSxDQUFDO0FBQ1QscUJBQWlCLG1CQURSO0FBRVQsaUJBQWEsZ0JBRko7QUFHVCxVQUFNLE9BQU8sTUFBUCxDQUFjLFdBQWQsRUFBMkIsR0FBM0IsQ0FBZ0M7QUFBQSxhQUFLLENBQUw7QUFBQSxLQUFoQztBQUhHLEdBQUQ7QUFGZ0IsQ0FBNUI7O0FBVUEsSUFBTSxtQkFBbUIsb0JBQVUsNEJBQVYsRUFBd0M7QUFDL0QsUUFBTSxlQUR5RDtBQUUvRCxRQUFNLG1CQUZ5RDtBQUcvRCx1QkFBcUIsK0JBQVc7QUFDOUIsWUFBUSxHQUFSLENBQVksS0FBSyxLQUFqQjtBQUNBLFFBQUksTUFBTSxLQUFLLEtBQUwsQ0FBVyxHQUFyQjtBQUNBLFFBQUksSUFBSixHQUFXLEtBQUssS0FBTCxDQUFXLElBQXRCO0FBQ0EsUUFBSSxTQUFKLEdBQWdCLEtBQUssS0FBTCxDQUFXLFNBQTNCO0FBQ0EsUUFBSSxTQUFKLEdBQWdCLFFBQWhCO0FBQ0EsUUFBSSxZQUFKLEdBQW1CLFFBQW5COztBQUVBLFNBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsVUFBUyxPQUFULEVBQW1CO0FBQ3ZDLGNBQVEsSUFBUixDQUFhLE9BQWIsQ0FBcUIsVUFBUyxHQUFULEVBQWM7QUFDakMsWUFBSSxRQUFKLENBQWEsSUFBSSxLQUFqQixFQUF3QixJQUFJLENBQTVCLEVBQStCLElBQUksQ0FBSixHQUFRLENBQXZDO0FBQ0QsT0FGRDtBQUdELEtBSkQ7QUFLRCxHQWhCOEQ7QUFpQi9ELGtCQUFnQixlQWpCK0M7QUFrQi9ELFdBQVM7QUFDUCxXQUFPO0FBQ0wsZUFBUztBQURKLEtBREE7QUFJUCxZQUFRO0FBQ04sZUFBUyxLQURIO0FBRU4sY0FBUTtBQUNOLGlCQUFTO0FBREg7QUFGRixLQUpEO0FBVVAscUJBQWlCLGNBVlY7QUFXUCxvQkFBZ0IsZUFYVDtBQVlQLFlBQVE7QUFDTixhQUFPLENBQUM7QUFDTixtQkFBVztBQUNULHFCQUFXLENBREY7QUFFVCxtQkFBUyxLQUZBO0FBR1Qsc0JBQVksS0FISDtBQUlULHFCQUFXO0FBSkYsU0FETDtBQU9OLGVBQU87QUFDTCxtQkFBUztBQURKO0FBUEQsT0FBRCxDQUREO0FBWU4sYUFBTyxDQUFDO0FBQ04sdUJBQWUsSUFEVDtBQUVOLDRCQUFvQixDQUZkO0FBR04sZUFBTztBQUNMLG1CQUFTO0FBREosU0FIRDtBQU1OLG1CQUFXO0FBQ1QsbUJBQVMsS0FEQTtBQUVULHNCQUFZLEtBRkg7QUFHVCxxQkFBVztBQUhGO0FBTkwsT0FBRDtBQVpELEtBWkQ7QUFxQ1AsY0FBVTtBQUNSLGVBQVM7QUFERCxLQXJDSDtBQXdDUCxXQUFPO0FBQ0wseUJBQW1CO0FBRGQsS0F4Q0E7QUEyQ1AsZUFBVztBQUNULGdCQUFVLENBREQ7QUFFVCxrQkFBWSxzQkFBWTtBQUN0QixZQUFJLGdCQUFnQixLQUFLLEtBQXpCO0FBQUEsWUFDRSxNQUFNLGNBQWMsR0FEdEI7QUFFQSxZQUFJLElBQUosR0FBVyxnQkFBTSxPQUFOLENBQWMsVUFBZCxDQUF5QixFQUF6QixFQUE2QixLQUE3QixFQUFvQyxXQUFwQyxDQUFYO0FBQ0EsWUFBSSxTQUFKLEdBQWdCLFFBQWhCO0FBQ0EsWUFBSSxZQUFKLEdBQW1CLFFBQW5CO0FBQ0EsWUFBSSxTQUFKLEdBQWdCLE1BQWhCOztBQUVBLGFBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBVSxPQUFWLEVBQW1CLENBQW5CLEVBQXNCO0FBQy9DLGNBQUksT0FBTyxjQUFjLFVBQWQsQ0FBeUIsY0FBekIsQ0FBd0MsQ0FBeEMsQ0FBWDtBQUNBLGVBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsVUFBVSxHQUFWLEVBQWUsS0FBZixFQUFzQjtBQUN0QyxnQkFBSSxPQUFPLFFBQVEsSUFBUixDQUFhLEtBQWIsQ0FBWDtBQUNBLGdCQUFJLFFBQUosQ0FBYSxJQUFiLEVBQW1CLElBQUksTUFBSixDQUFXLENBQVgsR0FBZSxFQUFsQyxFQUFzQyxJQUFJLE1BQUosQ0FBVyxDQUFYLEdBQWUsQ0FBckQ7QUFDRCxXQUhEO0FBSUQsU0FORDtBQU9EO0FBakJRO0FBM0NKO0FBbEJzRCxDQUF4QyxDQUF6Qjs7Ozs7Ozs7Ozs7QUNoTUE7Ozs7Ozs7O0FBRUEsSUFBTSx5QkFBeUIsR0FBL0I7O0FBRUEsSUFBTSxtQkFBbUI7QUFDdkIsVUFBUSxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFEZTtBQUV2QixXQUFTLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQUZjO0FBR3ZCLFdBQVMsRUFBRSxNQUFNLEVBQVIsRUFBWSxLQUFLLEdBQWpCLEVBSGM7QUFJdkIsYUFBVyxFQUFFLE1BQU0sRUFBUixFQUFZLEtBQUssR0FBakIsRUFKWTtBQUt2QixxQkFBbUIsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBTEk7QUFNdkIsY0FBWSxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFOVztBQU92QixlQUFhLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQVBVO0FBUXZCLFdBQVMsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBUmM7QUFTdkIsaUJBQWUsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBVFE7QUFVdkIsYUFBVyxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFWWTtBQVd2QixhQUFXLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQVhZO0FBWXZCLGNBQVksRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBWlc7QUFhdkIsZ0JBQWMsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBYlM7QUFjdkIsYUFBVyxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFkWTtBQWV2QixjQUFZLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxFQUFsQixFQWZXO0FBZ0J2QixXQUFTLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQWhCYztBQWlCdkIsYUFBVyxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFqQlk7QUFrQnZCLGFBQVcsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBbEJZO0FBbUJ2QixvQkFBa0IsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBbkJLO0FBb0J2QixZQUFVLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQXBCYTtBQXFCdkIsZUFBYSxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUFyQlU7QUFzQnZCLFlBQVUsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCLEVBdEJhO0FBdUJ2QixjQUFZLEVBQUUsTUFBTSxHQUFSLEVBQWEsS0FBSyxHQUFsQixFQXZCVztBQXdCdkIsWUFBVSxFQUFFLE1BQU0sR0FBUixFQUFhLEtBQUssR0FBbEIsRUF4QmE7QUF5QnZCLFVBQVEsRUFBRSxNQUFNLEdBQVIsRUFBYSxLQUFLLEdBQWxCO0FBekJlLENBQXpCOztBQTRCQSxJQUFNLGNBQWMsU0FBZCxXQUFjLE9BQW1CO0FBQUEsTUFBaEIsSUFBZ0IsUUFBaEIsSUFBZ0I7QUFBQSxNQUFWLEdBQVUsUUFBVixHQUFVOztBQUNyQyxNQUFNLE9BQU8sU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWI7O0FBRUEsT0FBSyxTQUFMLENBQWUsR0FBZixDQUFtQixZQUFuQjtBQUNBLE9BQUssS0FBTCxDQUFXLElBQVgsR0FBcUIsSUFBckI7QUFDQSxPQUFLLEtBQUwsQ0FBVyxHQUFYLEdBQW9CLEdBQXBCOztBQUVBLFNBQU8sSUFBUDtBQUNELENBUkQ7O0lBVXFCLEc7OztBQUluQixlQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0I7QUFBQTs7QUFBQSwwR0FDaEIsS0FEZ0IsRUFDVCxJQURTOztBQUFBLFVBSHhCLElBR3dCLEdBSGpCLEVBR2lCO0FBQUEsVUFGeEIsT0FFd0IsR0FGZCxJQUVjOzs7QUFHdEIsVUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLFVBQUssUUFBTCxHQUFnQixNQUFLLElBQUwsQ0FBVSxTQUFWLENBQWhCOztBQUVBLFFBQU0sV0FBVyxTQUFTLHNCQUFULEVBQWpCOztBQUVBLFNBQUssT0FBTCxDQUFhLFVBQUMsSUFBRCxFQUFPLEtBQVAsRUFBaUI7QUFDNUIsVUFBTSxRQUFRLFlBQVksaUJBQWlCLEtBQUssV0FBdEIsQ0FBWixDQUFkO0FBQ0EsWUFBTSxPQUFOLENBQWMsS0FBZCxHQUFzQixLQUF0Qjs7QUFFQSxZQUFNLGdCQUFOLENBQXVCLFdBQXZCLFNBQTBDLEtBQTFDO0FBQ0EsWUFBTSxnQkFBTixDQUF1QixVQUF2QixTQUF5QyxLQUF6Qzs7QUFFQSxlQUFTLFdBQVQsQ0FBcUIsS0FBckI7QUFDRCxLQVJEOztBQVVBLFVBQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLFdBQS9CLFNBQWtELEtBQWxEO0FBQ0EsVUFBSyxRQUFMLENBQWMsZ0JBQWQsQ0FBK0IsVUFBL0IsU0FBaUQsS0FBakQ7O0FBRUEsVUFBSyxJQUFMLENBQVUsTUFBVixFQUFrQixXQUFsQixDQUE4QixRQUE5QjtBQXJCc0I7QUFzQnZCOzs7O3VDQUU2QjtBQUFBOztBQUFBLFVBQWhCLE1BQWdCLFNBQWhCLE1BQWdCO0FBQUEsVUFBUixJQUFRLFNBQVIsSUFBUTs7QUFDNUIsVUFBSSxTQUFTLFdBQVQsSUFBd0IsT0FBTyxPQUFQLENBQWUsS0FBM0MsRUFBa0Q7QUFDaEQsYUFBSyxRQUFMLENBQWMsS0FBZCxDQUFvQixHQUFwQixHQUEwQixPQUFPLEtBQVAsQ0FBYSxHQUF2QztBQUNBLGFBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsSUFBcEIsR0FBMkIsT0FBTyxLQUFQLENBQWEsSUFBeEM7QUFDRDs7QUFFRCxtQkFBYSxLQUFLLE9BQWxCO0FBQ0EsV0FBSyxPQUFMLEdBQWUsV0FBVyxZQUFNO0FBQzlCLGdCQUFRLElBQVI7QUFDRSxlQUFLLFVBQUw7QUFDRSxtQkFBSyxNQUFMLENBQVksT0FBSyxRQUFqQixFQUEyQixTQUEzQixFQUFzQyxNQUF0QztBQUNBLG1CQUFLLE1BQUwsQ0FBWSxPQUFLLE9BQWpCLEVBQTBCLE9BQTFCLEVBQW1DLFFBQW5DO0FBQ0E7QUFDRixlQUFLLFdBQUw7QUFDRSxnQkFBTSxPQUFPLE9BQUssSUFBTCxDQUFVLE9BQU8sT0FBUCxDQUFlLEtBQXpCLENBQWI7O0FBRUEsZ0JBQUksSUFBSixFQUFVO0FBQ1Isa0JBQU0sZUFBZSxPQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUFrQyxxQkFBVyxLQUFYLEVBQWtCLGNBQWxCLENBQWxDLFNBQXJCOztBQUVBLHFCQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLEdBQXBCLEdBQTBCLE9BQU8sS0FBUCxDQUFhLEdBQXZDO0FBQ0EscUJBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsSUFBcEIsR0FBMkIsT0FBTyxLQUFQLENBQWEsSUFBeEM7O0FBRUEscUJBQUssT0FBTCxJQUFnQixPQUFLLE1BQUwsQ0FBWSxPQUFLLE9BQWpCLEVBQTBCLE9BQTFCLEVBQW1DLFFBQW5DLENBQWhCO0FBQ0EscUJBQUssTUFBTCxDQUFZLE9BQUssUUFBakIsRUFBMkIsU0FBM0IsRUFBc0MsTUFBdEM7O0FBRUEscUJBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIscUJBQVcsS0FBWCxFQUFrQixlQUFsQixDQUE1QixFQUFnRSxXQUFoRSxHQUE4RSxLQUFLLFdBQW5GO0FBQ0EscUJBQUssT0FBTCxHQUFlLE1BQWY7O0FBRUEsMkJBQWEsQ0FBYixFQUFnQixXQUFoQixHQUE4QixLQUFLLHdCQUFuQztBQUNBLDJCQUFhLENBQWIsRUFBZ0IsV0FBaEIsR0FBOEIsS0FBSyxPQUFuQztBQUNBLDJCQUFhLENBQWIsRUFBZ0IsV0FBaEIsR0FBOEIsS0FBSyxtQkFBbkM7O0FBRUEscUJBQUssTUFBTCxDQUFZLE9BQUssT0FBakIsRUFBMEIsT0FBMUIsRUFBbUMsUUFBbkM7QUFDRDs7QUFFRCxtQkFBSyxNQUFMLENBQVksT0FBSyxRQUFqQixFQUEyQixTQUEzQixFQUFzQyxNQUF0QztBQUNBO0FBNUJKO0FBOEJELE9BL0JjLEVBK0JaLHNCQS9CWSxDQUFmO0FBZ0NEOzs7Ozs7a0JBbkVrQixHOzs7Ozs7Ozs7Ozs7SUMxQ0EsRyxHQUNuQixhQUFZLElBQVosRUFBa0I7QUFBQTs7QUFDaEIsT0FBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixhQUFLO0FBQ2xDLE1BQUUsY0FBRjs7QUFFQSxRQUFJLEVBQUUsTUFBRixDQUFTLElBQVQsS0FBa0IsU0FBdEIsRUFBaUM7QUFDL0I7QUFDRDs7QUFFRCxRQUFNLEtBQUssRUFBRSxNQUFGLENBQVMsSUFBVCxDQUFjLEtBQWQsQ0FBb0IsR0FBcEIsRUFBeUIsQ0FBekIsQ0FBWDs7QUFQa0MsZ0NBUWxCLFNBQVMsY0FBVCxDQUF3QixFQUF4QixFQUE0QixxQkFBNUIsRUFSa0I7QUFBQSxRQVExQixHQVIwQix5QkFRMUIsR0FSMEI7O0FBVWxDLFdBQU8sTUFBUCxDQUFjLEVBQUUsS0FBTSxNQUFNLE9BQU8sT0FBZCxHQUF5QixFQUFoQyxFQUFvQyxNQUFNLENBQTFDLEVBQTZDLFVBQVUsUUFBdkQsRUFBZDtBQUNELEdBWEQ7QUFZRCxDOztrQkFka0IsRzs7Ozs7Ozs7Ozs7O0FDQXJCOzs7Ozs7OztBQUVBLElBQU0sZUFBZSxTQUFmLFlBQWUsR0FBb0I7QUFBQSxNQUFuQixNQUFtQix1RUFBVixLQUFVOztBQUN2QyxNQUFNLE9BQU8sU0FBUyxhQUFULENBQXVCLElBQXZCLENBQWI7O0FBRUEsT0FBSyxTQUFMLENBQWUsR0FBZixDQUFtQixtQkFBUyxRQUFULEVBQW1CLFFBQW5CLENBQW5CO0FBQ0EsWUFBVSxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLG1CQUFTLFFBQVQsRUFBbUIsUUFBbkIsRUFBNkIsUUFBN0IsQ0FBbkIsQ0FBVjs7QUFFQSxTQUFPLElBQVA7QUFDRCxDQVBEOztJQVNxQixNOzs7QUFHbkIsa0JBQVksSUFBWixFQUFrQjtBQUFBOztBQUFBLGdIQUNWLFFBRFUsRUFDQSxJQURBOztBQUFBLFVBRmxCLFlBRWtCLEdBRkgsQ0FFRzs7QUFFaEIsVUFBSyxPQUFMLEdBQWUsTUFBSyxLQUFMLENBQVcsT0FBWCxDQUFmOztBQUVBLFVBQUssUUFBTCxHQUFnQixFQUFoQjs7QUFFQSxVQUFLLFFBQUwsR0FBZ0IsU0FBUyxhQUFULENBQXVCLElBQXZCLENBQWhCO0FBQ0EsVUFBSyxRQUFMLENBQWMsU0FBZCxDQUF3QixHQUF4QixDQUE0QixtQkFBUyxNQUFLLElBQWQsRUFBb0IsU0FBcEIsQ0FBNUI7O0FBRUEsVUFBSyxPQUFMLENBQWEsT0FBYixDQUFxQixVQUFDLElBQUQsRUFBTyxLQUFQLEVBQWlCO0FBQ3BDLFVBQU0sU0FBUyxhQUFhLFVBQVUsTUFBSyxZQUE1QixDQUFmO0FBQ0EsWUFBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixNQUExQjtBQUNBLFlBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsTUFBbkI7QUFDRCxLQUpEOztBQU1BLFVBQUssUUFBTCxDQUFjLGdCQUFkLENBQStCLE9BQS9CLEVBQXdDLGdCQUFnQjtBQUFBLFVBQWIsTUFBYSxRQUFiLE1BQWE7O0FBQ3RELFVBQUksQ0FBQyxPQUFPLE9BQVAsQ0FBZSxxQkFBVyxNQUFLLElBQWhCLEVBQXNCLFFBQXRCLENBQWYsQ0FBTCxFQUFzRDtBQUNwRDtBQUNEOztBQUVELFVBQU0sVUFBVSxNQUFLLGNBQUwsQ0FBb0IsTUFBcEIsQ0FBaEI7O0FBRUEsVUFBSSxZQUFZLE1BQUssWUFBckIsRUFBbUM7QUFDakM7QUFDRDs7QUFFRCxZQUFLLE1BQUwsQ0FBWSxNQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLFFBQXBCLENBQVosRUFBMkMsUUFBM0MsRUFBcUQsUUFBckQ7QUFDQSxZQUFLLE1BQUwsQ0FBWSxNQUFaLEVBQW9CLFFBQXBCLEVBQThCLFFBQTlCOztBQUVBLFlBQUssS0FBTCxDQUFXLE9BQVg7QUFDRCxLQWZELEVBZUcsS0FmSDs7QUFpQkEsVUFBSyxJQUFMLENBQVUsV0FBVixDQUFzQixNQUFLLFFBQTNCO0FBaENnQjtBQWlDakI7Ozs7MEJBRUssSyxFQUFPO0FBQ1gsVUFBTSxTQUFTLEtBQUssWUFBTCxHQUFvQixLQUFuQzs7QUFFQSxXQUFLLE9BQUwsQ0FBYSxLQUFLLFlBQWxCLEVBQWdDLE9BQWhDLENBQXdDLENBQ3RDLEVBQUUsV0FBVyxlQUFiLEVBRHNDLEVBRXRDLEVBQUUsNEJBQXlCLFNBQVMsR0FBVCxHQUFlLEVBQXhDLFdBQUYsRUFGc0MsQ0FBeEMsRUFHRyxLQUFLLFdBQUwsQ0FBaUIsaUJBSHBCOztBQUtBLFdBQUssT0FBTCxDQUFhLEtBQWIsRUFBb0IsT0FBcEIsQ0FBNEIsQ0FDMUIsRUFBRSw0QkFBeUIsU0FBUyxFQUFULEdBQWMsR0FBdkMsV0FBRixFQUQwQixFQUUxQixFQUFFLFdBQVcsZUFBYixFQUYwQixDQUE1QixFQUdHLEtBQUssV0FBTCxDQUFpQixpQkFIcEI7O0FBS0EsV0FBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0Q7OzttQ0FFYyxJLEVBQU07QUFDbkIsVUFBSSxRQUFRLENBQUMsQ0FBYjs7QUFFQSxXQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTtBQUM5QixZQUFJLFNBQVMsSUFBYixFQUFtQjtBQUNqQixrQkFBUSxDQUFSO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0YsT0FMRDs7QUFPQSxhQUFPLEtBQVA7QUFDRDs7Ozs7O0FBakVrQixNLENBbUVaLGlCLEdBQW9CO0FBQ3pCLFlBQVUsR0FEZTtBQUV6QixRQUFNLFVBRm1CO0FBR3pCLFVBQVE7QUFIaUIsQztrQkFuRVIsTTs7OztBQ1hyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RFQTs7Ozs7Ozs7QUFFQSxJQUFNLDBCQUEwQjtBQUM5QixZQUFVLEdBRG9CO0FBRTlCLFFBQU0sVUFGd0I7QUFHOUIsVUFBUTtBQUhzQixDQUFoQzs7SUFNcUIsSTs7O0FBQ25CLGdCQUFZLElBQVosRUFBK0M7QUFBQSxtRkFBSixFQUFJO0FBQUEsK0JBQTNCLFVBQTJCO0FBQUEsUUFBM0IsVUFBMkIsbUNBQWQsS0FBYzs7QUFBQTs7QUFBQSw0R0FDdkMsTUFEdUMsRUFDL0IsSUFEK0I7O0FBRzdDLFVBQUssU0FBTCxHQUFpQixNQUFLLEtBQUwsQ0FBVyxVQUFYLENBQWpCO0FBQ0EsVUFBSyxPQUFMLEdBQWUsTUFBSyxLQUFMLENBQVcsT0FBWCxDQUFmOztBQUVBLFVBQUssT0FBTCxHQUFlLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBQ0EsVUFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixHQUF2QixDQUEyQixtQkFBUyxNQUFLLElBQWQsRUFBb0IsUUFBcEIsQ0FBM0I7QUFDQSxVQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLFdBQXBCLENBQWdDLE1BQUssT0FBckM7O0FBRUEsUUFBSSxVQUFKLEVBQWdCO0FBQ2QsVUFBTSxZQUFZLE1BQUssT0FBTCxDQUFhLE1BQWIsQ0FBb0IsVUFBQyxNQUFELEVBQVMsSUFBVCxFQUFrQjtBQUN0RCxZQUFJLEtBQUssWUFBTCxHQUFvQixNQUF4QixFQUFnQztBQUM5QixtQkFBUyxLQUFLLFlBQWQ7QUFDRDs7QUFFRCxlQUFPLE1BQVA7QUFDRCxPQU5pQixFQU1mLENBTmUsQ0FBbEI7O0FBUUEsWUFBSyxJQUFMLENBQVUsTUFBVixFQUFrQixLQUFsQixDQUF3QixNQUF4QixHQUFvQyxTQUFwQztBQUNEOztBQUVELFVBQUssWUFBTCxHQUFvQixNQUFLLGNBQUwsQ0FBb0IsTUFBSyxJQUFMLENBQVUsVUFBVixFQUFzQixRQUF0QixDQUFwQixDQUFwQjs7QUFFQSxVQUFLLElBQUwsQ0FBVSxLQUFWLEVBQWlCLGdCQUFqQixDQUFrQyxPQUFsQyxFQUEyQyxVQUFDLENBQUQsRUFBTztBQUNoRCxVQUFNLFFBQVEsRUFBRSxNQUFGLENBQVMsT0FBVCxDQUFpQixxQkFBVyxNQUFLLElBQWhCLEVBQXNCLFVBQXRCLENBQWpCLENBQWQ7O0FBRUEsVUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsVUFBTSxVQUFVLE1BQUssY0FBTCxDQUFvQixLQUFwQixDQUFoQjs7QUFFQSxVQUFJLFlBQVksTUFBSyxZQUFyQixFQUFtQztBQUNqQztBQUNEOztBQUVELFlBQUssTUFBTCxDQUFZLE1BQUssSUFBTCxDQUFVLFVBQVYsRUFBc0IsUUFBdEIsQ0FBWixFQUE2QyxVQUE3QyxFQUF5RCxRQUF6RDtBQUNBLFlBQUssTUFBTCxDQUFZLEtBQVosRUFBbUIsVUFBbkIsRUFBK0IsUUFBL0I7O0FBRUEsWUFBSyxhQUFMLENBQW1CLE9BQW5CO0FBQ0EsWUFBSyxhQUFMLENBQW1CLE9BQW5COztBQUVBLFlBQUssWUFBTCxHQUFvQixPQUFwQjtBQUNELEtBcEJELEVBb0JHLEtBcEJIOztBQXNCQSxVQUFLLE1BQUwsQ0FBWSxNQUFLLElBQUwsQ0FBVSxVQUFWLEVBQXNCLFFBQXRCLENBQVosRUFBNkMsVUFBN0MsRUFBeUQsUUFBekQ7QUE5QzZDO0FBK0M5Qzs7OztrQ0FFYSxLLEVBQU87QUFDbkIsVUFBTSxVQUFVLEtBQUssWUFBckI7QUFDQSxVQUFNLFNBQVMsVUFBVSxLQUF6Qjs7QUFFQyxrQkFBWSxTQUFiLElBQTJCLEtBQUssT0FBTCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBOEIsQ0FDdkQsRUFBRSxXQUFXLGVBQWIsRUFBOEIsU0FBUyxDQUF2QyxFQUR1RCxFQUV2RCxFQUFFLDRCQUF5QixTQUFTLEdBQVQsR0FBZSxFQUF4QyxXQUFGLEVBQXFELFNBQVMsQ0FBOUQsRUFGdUQsQ0FBOUIsRUFHeEIsdUJBSHdCLENBQTNCOztBQUtBLFdBQUssT0FBTCxDQUFhLEtBQWIsRUFBb0IsT0FBcEIsQ0FBNEIsQ0FDMUIsRUFBRSw0QkFBeUIsU0FBUyxFQUFULEdBQWMsR0FBdkMsV0FBRixFQUFxRCxTQUFTLENBQTlELEVBRDBCLEVBRTFCLEVBQUUsV0FBVyxlQUFiLEVBQThCLFNBQVMsQ0FBdkMsRUFGMEIsQ0FBNUIsRUFHRyx1QkFISDtBQUlEOzs7a0NBRWEsSyxFQUFPO0FBQUE7O0FBQ25CLFVBQU0sVUFBVTtBQUNkLGNBQU0sS0FBSyxTQUFMLENBQWUsS0FBSyxZQUFwQixFQUFrQyxVQUQxQjtBQUVkLGVBQU8sS0FBSyxTQUFMLENBQWUsS0FBSyxZQUFwQixFQUFrQztBQUYzQixPQUFoQjs7QUFLQSxVQUFNLE9BQU8sS0FBSyxTQUFMLENBQWUsS0FBZixFQUFzQixVQUFuQztBQUNBLFVBQU0sUUFBUSxLQUFLLFNBQUwsQ0FBZSxLQUFmLEVBQXNCLFdBQXBDOztBQUVBLFVBQU0sU0FBUyxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQXFCLENBQ2xDO0FBQ0UsbUNBQXlCLFFBQVEsSUFBakMsUUFERjtBQUVFLGVBQVUsUUFBUSxLQUFsQjtBQUZGLE9BRGtDLEVBSS9CO0FBQ0QsbUNBQXlCLElBQXpCLFFBREM7QUFFRCxlQUFVLEtBQVY7QUFGQyxPQUorQixDQUFyQixlQVFSLHVCQVJRLEVBQWY7O0FBVUEsYUFBTyxRQUFQLEdBQWtCLFlBQU07QUFDdEIsZUFBSyxNQUFMLENBQVksT0FBSyxTQUFMLENBQWUsS0FBZixDQUFaLEVBQW1DLFVBQW5DLEVBQStDLFFBQS9DO0FBQ0EsOEJBQXNCO0FBQUEsaUJBQU0sT0FBTyxNQUFQLEVBQU47QUFBQSxTQUF0QjtBQUNELE9BSEQ7O0FBS0EsV0FBSyxNQUFMLENBQVksS0FBSyxTQUFMLENBQWUsS0FBSyxZQUFwQixDQUFaLEVBQStDLFVBQS9DLEVBQTJELFFBQTNEO0FBQ0Q7OzttQ0FFYyxJLEVBQU07QUFDbkIsVUFBSSxRQUFRLENBQUMsQ0FBYjs7QUFFQSxXQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTtBQUMvQixZQUFJLFNBQVMsSUFBYixFQUFtQjtBQUNqQixrQkFBUSxDQUFSO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0YsT0FMRDs7QUFPQSxhQUFPLEtBQVA7QUFDRDs7Ozs7O2tCQXZHa0IsSTs7Ozs7Ozs7O0FDUnJCLElBQU0sZ0JBQWdCLFNBQWhCLGFBQWdCLENBQUMsTUFBRDtBQUFBLFNBQ3BCLE1BQU0sT0FBTyxJQUFQLENBQVksTUFBWixFQUFvQixNQUFwQixDQUEyQixVQUFDLEdBQUQsRUFBTSxHQUFOO0FBQUEsV0FDL0IsSUFBSSxJQUFKLENBQVksR0FBWixTQUFtQixPQUFPLEdBQVAsQ0FBbkIsS0FBcUMsR0FETjtBQUFBLEdBQTNCLEVBRUgsRUFGRyxFQUVDLElBRkQsQ0FFTSxHQUZOLENBRGM7QUFBQSxDQUF0Qjs7QUFNTyxJQUFNLDhDQUFtQixTQUFuQixnQkFBbUI7QUFBQSxTQUM5QixPQUFPLE9BQVAsQ0FBZSxDQUFmLEVBQWtCLE9BQWxCLENBQTBCLHFCQUExQixFQUFpRCxLQUFqRCxFQUF3RCxLQUF4RCxDQUE4RCxHQUE5RCxFQUFtRSxDQUFuRSxDQUQ4QjtBQUFBLENBQXpCOztBQUlBLElBQU0sZ0NBQVksU0FBWixTQUFZLENBQUMsR0FBRDtBQUFBLE1BQU0sT0FBTix1RUFBZ0IsRUFBRSxRQUFRLEtBQVYsRUFBaEI7QUFBQSxTQUFzQyxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQzlGLFFBQU0sVUFBVSxJQUFJLGNBQUosRUFBaEI7O0FBRUEsUUFBSSxRQUFRLElBQVIsSUFBZ0IsUUFBUSxNQUFSLEtBQW1CLEtBQXZDLEVBQThDO0FBQzVDLGFBQU8sY0FBYyxRQUFRLElBQXRCLENBQVA7QUFDRDs7QUFFRCxZQUFRLGtCQUFSLEdBQTZCLFlBQU07QUFDakMsVUFBSSxRQUFRLFVBQVIsS0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUI7QUFDRDs7QUFFRCxjQUFRLEtBQUssS0FBTCxDQUFXLFFBQVEsWUFBbkIsQ0FBUjtBQUNELEtBTkQ7O0FBUUEsWUFBUSxPQUFSLEdBQWtCLE1BQWxCO0FBQ0EsWUFBUSxJQUFSLENBQWEsUUFBUSxNQUFSLElBQWtCLEtBQS9CLEVBQXNDLEdBQXRDO0FBQ0EsWUFBUSxJQUFSLENBQWEsUUFBUSxJQUFSLEdBQWUsS0FBSyxTQUFMLENBQWUsUUFBUSxJQUF2QixDQUFmLEdBQThDLElBQTNEO0FBQ0QsR0FsQjhELENBQXRDO0FBQUEsQ0FBbEIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cbnZhciBDaGFydCA9IHJlcXVpcmUoJy4vY29yZS9jb3JlLmpzJykoKTtcblxucmVxdWlyZSgnLi9jb3JlL2NvcmUuaGVscGVycycpKENoYXJ0KTtcbnJlcXVpcmUoJy4vcGxhdGZvcm1zL3BsYXRmb3JtLmpzJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb3JlL2NvcmUuY2FudmFzSGVscGVycycpKENoYXJ0KTtcbnJlcXVpcmUoJy4vY29yZS9jb3JlLmVsZW1lbnQnKShDaGFydCk7XG5yZXF1aXJlKCcuL2NvcmUvY29yZS5wbHVnaW4uanMnKShDaGFydCk7XG5yZXF1aXJlKCcuL2NvcmUvY29yZS5hbmltYXRpb24nKShDaGFydCk7XG5yZXF1aXJlKCcuL2NvcmUvY29yZS5jb250cm9sbGVyJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXInKShDaGFydCk7XG5yZXF1aXJlKCcuL2NvcmUvY29yZS5sYXlvdXRTZXJ2aWNlJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb3JlL2NvcmUuc2NhbGVTZXJ2aWNlJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb3JlL2NvcmUudGlja3MuanMnKShDaGFydCk7XG5yZXF1aXJlKCcuL2NvcmUvY29yZS5zY2FsZScpKENoYXJ0KTtcbnJlcXVpcmUoJy4vY29yZS9jb3JlLmludGVyYWN0aW9uJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb3JlL2NvcmUudG9vbHRpcCcpKENoYXJ0KTtcblxucmVxdWlyZSgnLi9lbGVtZW50cy9lbGVtZW50LmFyYycpKENoYXJ0KTtcbnJlcXVpcmUoJy4vZWxlbWVudHMvZWxlbWVudC5saW5lJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9lbGVtZW50cy9lbGVtZW50LnBvaW50JykoQ2hhcnQpO1xucmVxdWlyZSgnLi9lbGVtZW50cy9lbGVtZW50LnJlY3RhbmdsZScpKENoYXJ0KTtcblxucmVxdWlyZSgnLi9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcycpKENoYXJ0KTtcbnJlcXVpcmUoJy4vc2NhbGVzL3NjYWxlLmNhdGVnb3J5JykoQ2hhcnQpO1xucmVxdWlyZSgnLi9zY2FsZXMvc2NhbGUubGluZWFyJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9zY2FsZXMvc2NhbGUubG9nYXJpdGhtaWMnKShDaGFydCk7XG5yZXF1aXJlKCcuL3NjYWxlcy9zY2FsZS5yYWRpYWxMaW5lYXInKShDaGFydCk7XG5yZXF1aXJlKCcuL3NjYWxlcy9zY2FsZS50aW1lJykoQ2hhcnQpO1xuXG4vLyBDb250cm9sbGVycyBtdXN0IGJlIGxvYWRlZCBhZnRlciBlbGVtZW50c1xuLy8gU2VlIENoYXJ0LmNvcmUuZGF0YXNldENvbnRyb2xsZXIuZGF0YUVsZW1lbnRUeXBlXG5yZXF1aXJlKCcuL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYmFyJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZScpKENoYXJ0KTtcbnJlcXVpcmUoJy4vY29udHJvbGxlcnMvY29udHJvbGxlci5kb3VnaG51dCcpKENoYXJ0KTtcbnJlcXVpcmUoJy4vY29udHJvbGxlcnMvY29udHJvbGxlci5saW5lJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYScpKENoYXJ0KTtcbnJlcXVpcmUoJy4vY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhcicpKENoYXJ0KTtcblxucmVxdWlyZSgnLi9jaGFydHMvQ2hhcnQuQmFyJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jaGFydHMvQ2hhcnQuQnViYmxlJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jaGFydHMvQ2hhcnQuRG91Z2hudXQnKShDaGFydCk7XG5yZXF1aXJlKCcuL2NoYXJ0cy9DaGFydC5MaW5lJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jaGFydHMvQ2hhcnQuUG9sYXJBcmVhJykoQ2hhcnQpO1xucmVxdWlyZSgnLi9jaGFydHMvQ2hhcnQuUmFkYXInKShDaGFydCk7XG5yZXF1aXJlKCcuL2NoYXJ0cy9DaGFydC5TY2F0dGVyJykoQ2hhcnQpO1xuXG4vLyBMb2FkaW5nIGJ1aWx0LWl0IHBsdWdpbnNcbnZhciBwbHVnaW5zID0gW107XG5cbnBsdWdpbnMucHVzaChcbiAgICByZXF1aXJlKCcuL3BsdWdpbnMvcGx1Z2luLmZpbGxlci5qcycpKENoYXJ0KSxcbiAgICByZXF1aXJlKCcuL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcycpKENoYXJ0KSxcbiAgICByZXF1aXJlKCcuL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzJykoQ2hhcnQpXG4pO1xuXG5DaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IENoYXJ0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuQmFyID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG5cdFx0Y29uZmlnLnR5cGUgPSAnYmFyJztcblxuXHRcdHJldHVybiBuZXcgQ2hhcnQoY29udGV4dCwgY29uZmlnKTtcblx0fTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdENoYXJ0LkJ1YmJsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuXHRcdGNvbmZpZy50eXBlID0gJ2J1YmJsZSc7XG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuRG91Z2hudXQgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdkb3VnaG51dCc7XG5cblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5MaW5lID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG5cdFx0Y29uZmlnLnR5cGUgPSAnbGluZSc7XG5cblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHRDaGFydC5Qb2xhckFyZWEgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdwb2xhckFyZWEnO1xuXG5cdFx0cmV0dXJuIG5ldyBDaGFydChjb250ZXh0LCBjb25maWcpO1xuXHR9O1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0Q2hhcnQuUmFkYXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdyYWRhcic7XG5cblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRob3Zlcjoge1xuXHRcdFx0bW9kZTogJ3NpbmdsZSdcblx0XHR9LFxuXG5cdFx0c2NhbGVzOiB7XG5cdFx0XHR4QXhlczogW3tcblx0XHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIHNjYXR0ZXIgc2hvdWxkIG5vdCB1c2UgYSBjYXRlZ29yeSBheGlzXG5cdFx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdFx0aWQ6ICd4LWF4aXMtMScgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdFx0fV0sXG5cdFx0XHR5QXhlczogW3tcblx0XHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRcdGlkOiAneS1heGlzLTEnXG5cdFx0XHR9XVxuXHRcdH0sXG5cblx0XHR0b29sdGlwczoge1xuXHRcdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiAnKCcgKyB0b29sdGlwSXRlbS54TGFiZWwgKyAnLCAnICsgdG9vbHRpcEl0ZW0ueUxhYmVsICsgJyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhpcyB0eXBlXG5cdENoYXJ0LmRlZmF1bHRzLnNjYXR0ZXIgPSBkZWZhdWx0Q29uZmlnO1xuXG5cdC8vIFNjYXR0ZXIgY2hhcnRzIHVzZSBsaW5lIGNvbnRyb2xsZXJzXG5cdENoYXJ0LmNvbnRyb2xsZXJzLnNjYXR0ZXIgPSBDaGFydC5jb250cm9sbGVycy5saW5lO1xuXG5cdENoYXJ0LlNjYXR0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcblx0XHRjb25maWcudHlwZSA9ICdzY2F0dGVyJztcblx0XHRyZXR1cm4gbmV3IENoYXJ0KGNvbnRleHQsIGNvbmZpZyk7XG5cdH07XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0Q2hhcnQuZGVmYXVsdHMuYmFyID0ge1xuXHRcdGhvdmVyOiB7XG5cdFx0XHRtb2RlOiAnbGFiZWwnXG5cdFx0fSxcblxuXHRcdHNjYWxlczoge1xuXHRcdFx0eEF4ZXM6IFt7XG5cdFx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cblx0XHRcdFx0Ly8gU3BlY2lmaWMgdG8gQmFyIENvbnRyb2xsZXJcblx0XHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblxuXHRcdFx0XHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0XHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1dLFxuXHRcdFx0eUF4ZXM6IFt7XG5cdFx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0XHR9XVxuXHRcdH1cblx0fTtcblxuXHRDaGFydC5jb250cm9sbGVycy5iYXIgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBDaGFydC5lbGVtZW50cy5SZWN0YW5nbGUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YTtcblxuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRcdG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHRtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuXHRcdFx0bWV0YS5iYXIgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0bWUuX3J1bGVyID0gbWUuZ2V0UnVsZXIoKTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZS51cGRhdGVFbGVtZW50KGVsZW1lbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHJlY3RhbmdsZS5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgcmVjdGFuZ2xlT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucmVjdGFuZ2xlO1xuXG5cdFx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRcdHJlY3RhbmdsZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdFx0cmVjdGFuZ2xlLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcblxuXHRcdFx0cmVjdGFuZ2xlLl9tb2RlbCA9IHtcblx0XHRcdFx0ZGF0YXNldExhYmVsOiBkYXRhc2V0LmxhYmVsLFxuXHRcdFx0XHRsYWJlbDogY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdLFxuXHRcdFx0XHRib3JkZXJTa2lwcGVkOiBjdXN0b20uYm9yZGVyU2tpcHBlZCA/IGN1c3RvbS5ib3JkZXJTa2lwcGVkIDogcmVjdGFuZ2xlT3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCByZWN0YW5nbGVPcHRpb25zLmJhY2tncm91bmRDb2xvciksXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmJvcmRlckNvbG9yLCBpbmRleCwgcmVjdGFuZ2xlT3B0aW9ucy5ib3JkZXJDb2xvciksXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmJvcmRlcldpZHRoLCBpbmRleCwgcmVjdGFuZ2xlT3B0aW9ucy5ib3JkZXJXaWR0aClcblx0XHRcdH07XG5cblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnRHZW9tZXRyeShyZWN0YW5nbGUsIGluZGV4LCByZXNldCk7XG5cblx0XHRcdHJlY3RhbmdsZS5waXZvdCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZUVsZW1lbnRHZW9tZXRyeTogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xuXHRcdFx0dmFyIHZzY2FsZSA9IG1lLmdldFZhbHVlU2NhbGUoKTtcblx0XHRcdHZhciBiYXNlID0gdnNjYWxlLmdldEJhc2VQaXhlbCgpO1xuXHRcdFx0dmFyIGhvcml6b250YWwgPSB2c2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHRcdHZhciB2cGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMobWUuaW5kZXgsIGluZGV4KTtcblx0XHRcdHZhciBpcGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMobWUuaW5kZXgsIGluZGV4LCBydWxlcik7XG5cblx0XHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdFx0bW9kZWwuYmFzZSA9IHJlc2V0PyBiYXNlIDogdnBpeGVscy5iYXNlO1xuXHRcdFx0bW9kZWwueCA9IGhvcml6b250YWw/IHJlc2V0PyBiYXNlIDogdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXI7XG5cdFx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbD8gaXBpeGVscy5jZW50ZXIgOiByZXNldD8gYmFzZSA6IHZwaXhlbHMuaGVhZDtcblx0XHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWw/IGlwaXhlbHMuc2l6ZSA6IHVuZGVmaW5lZDtcblx0XHRcdG1vZGVsLndpZHRoID0gaG9yaXpvbnRhbD8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0VmFsdWVTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuZ2V0VmFsdWVTY2FsZUlkKCkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldEluZGV4U2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLmdldEluZGV4U2NhbGVJZCgpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKGxhc3QpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldEluZGV4U2NhbGUoKTtcblx0XHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdFx0dmFyIGlsZW4gPSBsYXN0ID09PSB1bmRlZmluZWQ/IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoIDogbGFzdCArIDE7XG5cdFx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0XHR2YXIgaSwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChtZXRhLmJhciAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmXG5cdFx0XHRcdFx0KHN0YWNrZWQgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgKG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpKSkpIHtcblx0XHRcdFx0XHRzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3RhY2tzLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFN0YWNrQ291bnQoZGF0YXNldEluZGV4KSAtIDE7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0UnVsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldEluZGV4U2NhbGUoKTtcblx0XHRcdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcblx0XHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdFx0dmFyIGZ1bGxTaXplID0gc2NhbGUuaXNIb3Jpem9udGFsKCk/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xuXHRcdFx0dmFyIHRpY2tTaXplID0gZnVsbFNpemUgLyBzY2FsZS50aWNrcy5sZW5ndGg7XG5cdFx0XHR2YXIgY2F0ZWdvcnlTaXplID0gdGlja1NpemUgKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblx0XHRcdHZhciBmdWxsQmFyU2l6ZSA9IGNhdGVnb3J5U2l6ZSAvIHN0YWNrQ291bnQ7XG5cdFx0XHR2YXIgYmFyU2l6ZSA9IGZ1bGxCYXJTaXplICogb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXG5cdFx0XHRiYXJTaXplID0gTWF0aC5taW4oXG5cdFx0XHRcdGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQob3B0aW9ucy5iYXJUaGlja25lc3MsIGJhclNpemUpLFxuXHRcdFx0XHRoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSkpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGFja0NvdW50OiBzdGFja0NvdW50LFxuXHRcdFx0XHR0aWNrU2l6ZTogdGlja1NpemUsXG5cdFx0XHRcdGNhdGVnb3J5U2l6ZTogY2F0ZWdvcnlTaXplLFxuXHRcdFx0XHRjYXRlZ29yeVNwYWNpbmc6IHRpY2tTaXplIC0gY2F0ZWdvcnlTaXplLFxuXHRcdFx0XHRmdWxsQmFyU2l6ZTogZnVsbEJhclNpemUsXG5cdFx0XHRcdGJhclNpemU6IGJhclNpemUsXG5cdFx0XHRcdGJhclNwYWNpbmc6IGZ1bGxCYXJTaXplIC0gYmFyU2l6ZSxcblx0XHRcdFx0c2NhbGU6IHNjYWxlXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y2FsY3VsYXRlQmFyVmFsdWVQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHNjYWxlID0gbWUuZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHRcdHZhciB2YWx1ZSA9IE51bWJlcihkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdFx0dmFyIHN0YWNrID0gbWV0YS5zdGFjaztcblx0XHRcdHZhciBzdGFydCA9IDA7XG5cdFx0XHR2YXIgaSwgaW1ldGEsIGl2YWx1ZSwgYmFzZSwgaGVhZCwgc2l6ZTtcblxuXHRcdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcblx0XHRcdFx0XHRpbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXG5cdFx0XHRcdFx0aWYgKGltZXRhLmJhciAmJlxuXHRcdFx0XHRcdFx0aW1ldGEuc3RhY2sgPT09IHN0YWNrICYmXG5cdFx0XHRcdFx0XHRpbWV0YS5jb250cm9sbGVyLmdldFZhbHVlU2NhbGVJZCgpID09PSBzY2FsZS5pZCAmJlxuXHRcdFx0XHRcdFx0Y2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXG5cdFx0XHRcdFx0XHRpdmFsdWUgPSBOdW1iZXIoZGF0YXNldHNbaV0uZGF0YVtpbmRleF0pO1xuXHRcdFx0XHRcdFx0aWYgKCh2YWx1ZSA8IDAgJiYgaXZhbHVlIDwgMCkgfHwgKHZhbHVlID49IDAgJiYgaXZhbHVlID4gMCkpIHtcblx0XHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XG5cdFx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRcdHNpemUgPSAoaGVhZCAtIGJhc2UpIC8gMjtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0YmFzZTogYmFzZSxcblx0XHRcdFx0aGVhZDogaGVhZCxcblx0XHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHNjYWxlID0gcnVsZXIuc2NhbGU7XG5cdFx0XHR2YXIgaXNDb21ibyA9IG1lLmNoYXJ0LmlzQ29tYm87XG5cdFx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciBiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpbmRleCwgZGF0YXNldEluZGV4LCBpc0NvbWJvKTtcblx0XHRcdHZhciBzaXplID0gcnVsZXIuYmFyU2l6ZTtcblxuXHRcdFx0YmFzZSAtPSBpc0NvbWJvPyBydWxlci50aWNrU2l6ZSAvIDIgOiAwO1xuXHRcdFx0YmFzZSArPSBydWxlci5mdWxsQmFyU2l6ZSAqIHN0YWNrSW5kZXg7XG5cdFx0XHRiYXNlICs9IHJ1bGVyLmNhdGVnb3J5U3BhY2luZyAvIDI7XG5cdFx0XHRiYXNlICs9IHJ1bGVyLmJhclNwYWNpbmcgLyAyO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRiYXNlOiBiYXNlLFxuXHRcdFx0XHRoZWFkOiBiYXNlICsgc2l6ZSxcblx0XHRcdFx0Y2VudGVyOiBiYXNlICsgc2l6ZSAvIDJcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIGQ7XG5cblx0XHRcdGhlbHBlcnMuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcblxuXHRcdFx0Zm9yICg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdGQgPSBkYXRhc2V0LmRhdGFbaV07XG5cdFx0XHRcdGlmIChkICE9PSBudWxsICYmIGQgIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4oZCkpIHtcblx0XHRcdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xuXHRcdH0sXG5cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihyZWN0YW5nbGUpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3JlY3RhbmdsZS5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IHJlY3RhbmdsZS5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcmVjdGFuZ2xlLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yID8gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGggPyBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgaW5kZXgsIG1vZGVsLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tyZWN0YW5nbGUuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSByZWN0YW5nbGUuX2luZGV4O1xuXHRcdFx0dmFyIGN1c3RvbSA9IHJlY3RhbmdsZS5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xuXHRcdFx0dmFyIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zID0gdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnJlY3RhbmdsZTtcblxuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmJhY2tncm91bmRDb2xvciwgaW5kZXgsIHJlY3RhbmdsZUVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyQ29sb3IsIGluZGV4LCByZWN0YW5nbGVFbGVtZW50T3B0aW9ucy5ib3JkZXJDb2xvcik7XG5cdFx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuYm9yZGVyV2lkdGgsIGluZGV4LCByZWN0YW5nbGVFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdC8vIGluY2x1ZGluZyBob3Jpem9udGFsQmFyIGluIHRoZSBiYXIgZmlsZSwgaW5zdGVhZCBvZiBhIGZpbGUgb2YgaXRzIG93blxuXHQvLyBpdCBleHRlbmRzIGJhciAobGlrZSBwaWUgZXh0ZW5kcyBkb3VnaG51dClcblx0Q2hhcnQuZGVmYXVsdHMuaG9yaXpvbnRhbEJhciA9IHtcblx0XHRob3Zlcjoge1xuXHRcdFx0bW9kZTogJ2xhYmVsJ1xuXHRcdH0sXG5cblx0XHRzY2FsZXM6IHtcblx0XHRcdHhBeGVzOiBbe1xuXHRcdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0XHR9XSxcblx0XHRcdHlBeGVzOiBbe1xuXHRcdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXG5cdFx0XHRcdC8vIFNwZWNpZmljIHRvIEhvcml6b250YWwgQmFyIENvbnRyb2xsZXJcblx0XHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblxuXHRcdFx0XHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0XHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1dXG5cdFx0fSxcblx0XHRlbGVtZW50czoge1xuXHRcdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9vbHRpcHM6IHtcblx0XHRcdGNhbGxiYWNrczoge1xuXHRcdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0XHRcdFx0Ly8gUGljayBmaXJzdCB4TGFiZWwgZm9yIG5vd1xuXHRcdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXG5cdFx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAodG9vbHRpcEl0ZW1zWzBdLnlMYWJlbCkge1xuXHRcdFx0XHRcdFx0XHR0aXRsZSA9IHRvb2x0aXBJdGVtc1swXS55TGFiZWw7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCA+IDAgJiYgdG9vbHRpcEl0ZW1zWzBdLmluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRpdGxlID0gZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW1zWzBdLmluZGV4XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGl0bGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFzZXRMYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS54TGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhcnQuY29udHJvbGxlcnMuaG9yaXpvbnRhbEJhciA9IENoYXJ0LmNvbnRyb2xsZXJzLmJhci5leHRlbmQoe1xuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Z2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGdldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0XHR9XG5cdH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHRDaGFydC5kZWZhdWx0cy5idWJibGUgPSB7XG5cdFx0aG92ZXI6IHtcblx0XHRcdG1vZGU6ICdzaW5nbGUnXG5cdFx0fSxcblxuXHRcdHNjYWxlczoge1xuXHRcdFx0eEF4ZXM6IFt7XG5cdFx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XG5cdFx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdFx0aWQ6ICd4LWF4aXMtMCcgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdFx0fV0sXG5cdFx0XHR5QXhlczogW3tcblx0XHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0XHR9XVxuXHRcdH0sXG5cblx0XHR0b29sdGlwczoge1xuXHRcdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdFx0dmFyIGRhdGFQb2ludCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyB0b29sdGlwSXRlbS54TGFiZWwgKyAnLCAnICsgdG9vbHRpcEl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmJ1YmJsZSA9IENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0XHRkYXRhRWxlbWVudFR5cGU6IENoYXJ0LmVsZW1lbnRzLlBvaW50LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcblxuXHRcdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdFx0aGVscGVycy5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHRcdHZhciBwb2ludEVsZW1lbnRPcHRpb25zID0gbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XG5cblx0XHRcdGhlbHBlcnMuZXh0ZW5kKHBvaW50LCB7XG5cdFx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdFx0X3hTY2FsZTogeFNjYWxlLFxuXHRcdFx0XHRfeVNjYWxlOiB5U2NhbGUsXG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IGRzSW5kZXgsXG5cdFx0XHRcdF9pbmRleDogaW5kZXgsXG5cblx0XHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdFx0eDogcmVzZXQgPyB4U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhIDogTmFOLCBpbmRleCwgZHNJbmRleCwgbWUuY2hhcnQuaXNDb21ibyksXG5cdFx0XHRcdFx0eTogcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCksXG5cdFx0XHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogY3VzdG9tLnJhZGl1cyA/IGN1c3RvbS5yYWRpdXMgOiBtZS5nZXRSYWRpdXMoZGF0YSksXG5cblx0XHRcdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRcdFx0aGl0UmFkaXVzOiBjdXN0b20uaGl0UmFkaXVzID8gY3VzdG9tLmhpdFJhZGl1cyA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQuaGl0UmFkaXVzLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5oaXRSYWRpdXMpXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUcmljayB0byByZXNldCB0aGUgc3R5bGVzIG9mIHRoZSBwb2ludFxuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUhvdmVyU3R5bGUuY2FsbChtZSwgcG9pbnQsIHBvaW50RWxlbWVudE9wdGlvbnMpO1xuXG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHRtb2RlbC5za2lwID0gY3VzdG9tLnNraXAgPyBjdXN0b20uc2tpcCA6IChpc05hTihtb2RlbC54KSB8fCBpc05hTihtb2RlbC55KSk7XG5cblx0XHRcdHBvaW50LnBpdm90KCk7XG5cdFx0fSxcblxuXHRcdGdldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yIHx8IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5yYWRpdXM7XG5cdFx0fSxcblxuXHRcdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnNldEhvdmVyU3R5bGUuY2FsbChtZSwgcG9pbnQpO1xuXG5cdFx0XHQvLyBSYWRpdXNcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBpbmRleCA9IHBvaW50Ll9pbmRleDtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20uaG92ZXJSYWRpdXMgPyBjdXN0b20uaG92ZXJSYWRpdXMgOiAoaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5ob3ZlclJhZGl1cywgaW5kZXgsIG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQuaG92ZXJSYWRpdXMpKSArIG1lLmdldFJhZGl1cyhkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKG1lLCBwb2ludCwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludCk7XG5cblx0XHRcdHZhciBkYXRhVmFsID0gbWUuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XS5kYXRhW3BvaW50Ll9pbmRleF07XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20ucmFkaXVzID8gY3VzdG9tLnJhZGl1cyA6IG1lLmdldFJhZGl1cyhkYXRhVmFsKTtcblx0XHR9XG5cdH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycyxcblx0XHRkZWZhdWx0cyA9IENoYXJ0LmRlZmF1bHRzO1xuXG5cdGRlZmF1bHRzLmRvdWdobnV0ID0ge1xuXHRcdGFuaW1hdGlvbjoge1xuXHRcdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcblx0XHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGFzcGVjdFJhdGlvOiAxLFxuXHRcdGhvdmVyOiB7XG5cdFx0XHRtb2RlOiAnc2luZ2xlJ1xuXHRcdH0sXG5cdFx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0bGVnZW5kOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYyAmJiBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR2YXIgZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHRcdHZhciBmaWxsID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYmFja2dyb3VuZENvbG9yLCBpLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyQ29sb3IsIGksIGFyY09wdHMuYm9yZGVyQ29sb3IpO1xuXHRcdFx0XHRcdFx0XHR2YXIgYncgPSBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyV2lkdGgsIGksIGFyY09wdHMuYm9yZGVyV2lkdGgpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cblx0XHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHRcdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG5cdFx0cm90YXRpb246IE1hdGguUEkgKiAtMC41LFxuXG5cdFx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRcdGNpcmN1bWZlcmVuY2U6IE1hdGguUEkgKiAyLjAsXG5cblx0XHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0XHR0b29sdGlwczoge1xuXHRcdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gJzogJyArIGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblxuXHRcdFx0XHRcdGlmIChoZWxwZXJzLmlzQXJyYXkoZGF0YUxhYmVsKSkge1xuXHRcdFx0XHRcdFx0Ly8gc2hvdyB2YWx1ZSBvbiBmaXJzdCBsaW5lIG9mIG11bHRpbGluZSBsYWJlbFxuXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRcdGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwgKz0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRkZWZhdWx0cy5waWUgPSBoZWxwZXJzLmNsb25lKGRlZmF1bHRzLmRvdWdobnV0KTtcblx0aGVscGVycy5leHRlbmQoZGVmYXVsdHMucGllLCB7XG5cdFx0Y3V0b3V0UGVyY2VudGFnZTogMFxuXHR9KTtcblxuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLmRvdWdobnV0ID0gQ2hhcnQuY29udHJvbGxlcnMucGllID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRcdGRhdGFFbGVtZW50VHlwZTogQ2hhcnQuZWxlbWVudHMuQXJjLFxuXG5cdFx0bGlua1NjYWxlczogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gR2V0IGluZGV4IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0XHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIHJpbmdJbmRleCA9IDA7XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YXNldEluZGV4OyArK2opIHtcblx0XHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHRcdCsrcmluZ0luZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByaW5nSW5kZXg7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydCxcblx0XHRcdFx0Y2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhLFxuXHRcdFx0XHRvcHRzID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0YXJjT3B0cyA9IG9wdHMuZWxlbWVudHMuYXJjLFxuXHRcdFx0XHRhdmFpbGFibGVXaWR0aCA9IGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0IC0gYXJjT3B0cy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0YXZhaWxhYmxlSGVpZ2h0ID0gY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3AgLSBhcmNPcHRzLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCksXG5cdFx0XHRcdG9mZnNldCA9IHtcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0bWV0YSA9IG1lLmdldE1ldGEoKSxcblx0XHRcdFx0Y3V0b3V0UGVyY2VudGFnZSA9IG9wdHMuY3V0b3V0UGVyY2VudGFnZSxcblx0XHRcdFx0Y2lyY3VtZmVyZW5jZSA9IG9wdHMuY2lyY3VtZmVyZW5jZTtcblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgbWluU2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdFx0aWYgKGNpcmN1bWZlcmVuY2UgPCBNYXRoLlBJICogMi4wKSB7XG5cdFx0XHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbiAlIChNYXRoLlBJICogMi4wKTtcblx0XHRcdFx0c3RhcnRBbmdsZSArPSBNYXRoLlBJICogMi4wICogKHN0YXJ0QW5nbGUgPj0gTWF0aC5QSSA/IC0xIDogc3RhcnRBbmdsZSA8IC1NYXRoLlBJID8gMSA6IDApO1xuXHRcdFx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcblx0XHRcdFx0dmFyIHN0YXJ0ID0ge3g6IE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBNYXRoLnNpbihzdGFydEFuZ2xlKX07XG5cdFx0XHRcdHZhciBlbmQgPSB7eDogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBNYXRoLnNpbihlbmRBbmdsZSl9O1xuXHRcdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiAwIDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi4wICYmIE1hdGguUEkgKiAyLjAgPD0gZW5kQW5nbGUpO1xuXHRcdFx0XHR2YXIgY29udGFpbnM5MCA9IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAwLjUgJiYgTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuNSAmJiBNYXRoLlBJICogMi41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgJiYgLU1hdGguUEkgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgJiYgTWF0aC5QSSA8PSBlbmRBbmdsZSk7XG5cdFx0XHRcdHZhciBjb250YWluczI3MCA9IChzdGFydEFuZ2xlIDw9IC1NYXRoLlBJICogMC41ICYmIC1NYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMS41ICYmIE1hdGguUEkgKiAxLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0XHR2YXIgY3V0b3V0ID0gY3V0b3V0UGVyY2VudGFnZSAvIDEwMC4wO1xuXHRcdFx0XHR2YXIgbWluID0ge3g6IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydC54ICogKHN0YXJ0LnggPCAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54IDwgMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnkgKiAoc3RhcnQueSA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPCAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdFx0dmFyIG1heCA9IHt4OiBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnQueCAqIChzdGFydC54ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueCAqIChlbmQueCA+IDAgPyAxIDogY3V0b3V0KSksIHk6IGNvbnRhaW5zOTAgPyAxIDogTWF0aC5tYXgoc3RhcnQueSAqIChzdGFydC55ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA+IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0XHR2YXIgc2l6ZSA9IHt3aWR0aDogKG1heC54IC0gbWluLngpICogMC41LCBoZWlnaHQ6IChtYXgueSAtIG1pbi55KSAqIDAuNX07XG5cdFx0XHRcdG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHNpemUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0XHRcdFx0b2Zmc2V0ID0ge3g6IChtYXgueCArIG1pbi54KSAqIC0wLjUsIHk6IChtYXgueSArIG1pbi55KSAqIC0wLjV9O1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC5ib3JkZXJXaWR0aCA9IG1lLmdldE1heEJvcmRlcldpZHRoKG1ldGEuZGF0YSk7XG5cdFx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gMiwgMCk7XG5cdFx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KGN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKGN1dG91dFBlcmNlbnRhZ2UpIDogMCwgMCk7XG5cdFx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cdFx0XHRjaGFydC5vZmZzZXRYID0gb2Zmc2V0LnggKiBjaGFydC5vdXRlclJhZGl1cztcblx0XHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXQueSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXG5cdFx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcblxuXHRcdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIChjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5nZXRSaW5nSW5kZXgobWUuaW5kZXgpKTtcblx0XHRcdG1lLmlubmVyUmFkaXVzID0gTWF0aC5tYXgobWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGgsIDApO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjLCBpbmRleCwgcmVzZXQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG5cdFx0XHRcdGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYSxcblx0XHRcdFx0b3B0cyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRcdGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbixcblx0XHRcdFx0Y2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyLFxuXHRcdFx0XHRjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIsXG5cdFx0XHRcdHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uLCAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0XHRcdGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbiwgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdFx0XHRkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpLFxuXHRcdFx0XHRjaXJjdW1mZXJlbmNlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gMCA6IGFyYy5oaWRkZW4gPyAwIDogbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKSAqIChvcHRzLmNpcmN1bWZlcmVuY2UgLyAoMi4wICogTWF0aC5QSSkpLFxuXHRcdFx0XHRpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzLFxuXHRcdFx0XHRvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzLFxuXHRcdFx0XHR2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuXHRcdFx0aGVscGVycy5leHRlbmQoYXJjLCB7XG5cdFx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRcdF9pbmRleDogaW5kZXgsXG5cblx0XHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdFx0eDogY2VudGVyWCArIGNoYXJ0Lm9mZnNldFgsXG5cdFx0XHRcdFx0eTogY2VudGVyWSArIGNoYXJ0Lm9mZnNldFksXG5cdFx0XHRcdFx0c3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcblx0XHRcdFx0XHRlbmRBbmdsZTogZW5kQW5nbGUsXG5cdFx0XHRcdFx0Y2lyY3VtZmVyZW5jZTogY2lyY3VtZmVyZW5jZSxcblx0XHRcdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0XHRcdGxhYmVsOiB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5sYWJlbCwgaW5kZXgsIGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSlcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0XHQvLyBSZXNldHMgdGhlIHZpc3VhbCBzdHlsZXNcblx0XHRcdHRoaXMucmVtb3ZlSG92ZXJTdHlsZShhcmMpO1xuXG5cdFx0XHQvLyBTZXQgY29ycmVjdCBhbmdsZXMgaWYgbm90IHJlc2V0dGluZ1xuXHRcdFx0aWYgKCFyZXNldCB8fCAhYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG5cdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1vZGVsLmVuZEFuZ2xlID0gbW9kZWwuc3RhcnRBbmdsZSArIG1vZGVsLmNpcmN1bWZlcmVuY2U7XG5cdFx0XHR9XG5cblx0XHRcdGFyYy5waXZvdCgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHRcdENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVIb3ZlclN0eWxlLmNhbGwodGhpcywgYXJjLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjKTtcblx0XHR9LFxuXG5cdFx0Y2FsY3VsYXRlVG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdFx0dmFyIHZhbHVlO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0XHR2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHRcdGlmICghaXNOYU4odmFsdWUpICYmICFlbGVtZW50LmhpZGRlbikge1xuXHRcdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8qIGlmICh0b3RhbCA9PT0gMCkge1xuXHRcdFx0XHR0b3RhbCA9IE5hTjtcblx0XHRcdH0qL1xuXG5cdFx0XHRyZXR1cm4gdG90YWw7XG5cdFx0fSxcblxuXHRcdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcblx0XHRcdGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gKE1hdGguUEkgKiAyLjApICogKHZhbHVlIC8gdG90YWwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdC8vIGdldHMgdGhlIG1heCBib3JkZXIgb3IgaG92ZXIgd2lkdGggdG8gcHJvcGVybHkgc2NhbGUgcGllIGNoYXJ0c1xuXHRcdGdldE1heEJvcmRlcldpZHRoOiBmdW5jdGlvbihlbGVtZW50cykge1xuXHRcdFx0dmFyIG1heCA9IDAsXG5cdFx0XHRcdGluZGV4ID0gdGhpcy5pbmRleCxcblx0XHRcdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRib3JkZXJXaWR0aCxcblx0XHRcdFx0aG92ZXJXaWR0aDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRib3JkZXJXaWR0aCA9IGVsZW1lbnRzW2ldLl9tb2RlbCA/IGVsZW1lbnRzW2ldLl9tb2RlbC5ib3JkZXJXaWR0aCA6IDA7XG5cdFx0XHRcdGhvdmVyV2lkdGggPSBlbGVtZW50c1tpXS5fY2hhcnQgPyBlbGVtZW50c1tpXS5fY2hhcnQuY29uZmlnLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhvdmVyQm9yZGVyV2lkdGggOiAwO1xuXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XG5cdFx0XHRcdG1heCA9IGhvdmVyV2lkdGggPiBtYXggPyBob3ZlcldpZHRoIDogbWF4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heDtcblx0XHR9XG5cdH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHRDaGFydC5kZWZhdWx0cy5saW5lID0ge1xuXHRcdHNob3dMaW5lczogdHJ1ZSxcblx0XHRzcGFuR2FwczogZmFsc2UsXG5cblx0XHRob3Zlcjoge1xuXHRcdFx0bW9kZTogJ2xhYmVsJ1xuXHRcdH0sXG5cblx0XHRzY2FsZXM6IHtcblx0XHRcdHhBeGVzOiBbe1xuXHRcdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0XHRpZDogJ3gtYXhpcy0wJ1xuXHRcdFx0fV0sXG5cdFx0XHR5QXhlczogW3tcblx0XHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0XHR9XVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBsaW5lRW5hYmxlZChkYXRhc2V0LCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQoZGF0YXNldC5zaG93TGluZSwgb3B0aW9ucy5zaG93TGluZXMpO1xuXHR9XG5cblx0Q2hhcnQuY29udHJvbGxlcnMubGluZSA9IENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0XHRkYXRhc2V0RWxlbWVudFR5cGU6IENoYXJ0LmVsZW1lbnRzLkxpbmUsXG5cblx0XHRkYXRhRWxlbWVudFR5cGU6IENoYXJ0LmVsZW1lbnRzLlBvaW50LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zO1xuXHRcdFx0dmFyIGxpbmVFbGVtZW50T3B0aW9ucyA9IG9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRcdHZhciBpLCBpbGVuLCBjdXN0b207XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBzaG93TGluZSA9IGxpbmVFbmFibGVkKGRhdGFzZXQsIG9wdGlvbnMpO1xuXG5cdFx0XHQvLyBVcGRhdGUgTGluZVxuXHRcdFx0aWYgKHNob3dMaW5lKSB7XG5cdFx0XHRcdGN1c3RvbSA9IGxpbmUuY3VzdG9tIHx8IHt9O1xuXG5cdFx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRsaW5lLl9zY2FsZSA9IHNjYWxlO1xuXHRcdFx0XHRsaW5lLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRcdFx0Ly8gRGF0YVxuXHRcdFx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcblx0XHRcdFx0Ly8gTW9kZWxcblx0XHRcdFx0bGluZS5fbW9kZWwgPSB7XG5cdFx0XHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0XHRcdC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGxpbmVzIGlzIHRvIGJyZWFrIGF0IG51bGwgdmFsdWVzLCBhY2NvcmRpbmdcblx0XHRcdFx0XHQvLyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQzNSNpc3N1ZWNvbW1lbnQtMjE2NzE4MTU4XG5cdFx0XHRcdFx0Ly8gVGhpcyBvcHRpb24gZ2l2ZXMgbGluZXMgdGhlIGFiaWxpdHkgdG8gc3BhbiBnYXBzXG5cdFx0XHRcdFx0c3BhbkdhcHM6IGRhdGFzZXQuc3BhbkdhcHMgPyBkYXRhc2V0LnNwYW5HYXBzIDogb3B0aW9ucy5zcGFuR2Fwcyxcblx0XHRcdFx0XHR0ZW5zaW9uOiBjdXN0b20udGVuc2lvbiA/IGN1c3RvbS50ZW5zaW9uIDogaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChkYXRhc2V0LmxpbmVUZW5zaW9uLCBsaW5lRWxlbWVudE9wdGlvbnMudGVuc2lvbiksXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IChkYXRhc2V0LmJhY2tncm91bmRDb2xvciB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSxcblx0XHRcdFx0XHRib3JkZXJXaWR0aDogY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogKGRhdGFzZXQuYm9yZGVyV2lkdGggfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKSxcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogKGRhdGFzZXQuYm9yZGVyQ29sb3IgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKSxcblx0XHRcdFx0XHRib3JkZXJDYXBTdHlsZTogY3VzdG9tLmJvcmRlckNhcFN0eWxlID8gY3VzdG9tLmJvcmRlckNhcFN0eWxlIDogKGRhdGFzZXQuYm9yZGVyQ2FwU3R5bGUgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckNhcFN0eWxlKSxcblx0XHRcdFx0XHRib3JkZXJEYXNoOiBjdXN0b20uYm9yZGVyRGFzaCA/IGN1c3RvbS5ib3JkZXJEYXNoIDogKGRhdGFzZXQuYm9yZGVyRGFzaCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyRGFzaCksXG5cdFx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogY3VzdG9tLmJvcmRlckRhc2hPZmZzZXQgPyBjdXN0b20uYm9yZGVyRGFzaE9mZnNldCA6IChkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpLFxuXHRcdFx0XHRcdGJvcmRlckpvaW5TdHlsZTogY3VzdG9tLmJvcmRlckpvaW5TdHlsZSA/IGN1c3RvbS5ib3JkZXJKb2luU3R5bGUgOiAoZGF0YXNldC5ib3JkZXJKb2luU3R5bGUgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckpvaW5TdHlsZSksXG5cdFx0XHRcdFx0ZmlsbDogY3VzdG9tLmZpbGwgPyBjdXN0b20uZmlsbCA6IChkYXRhc2V0LmZpbGwgIT09IHVuZGVmaW5lZCA/IGRhdGFzZXQuZmlsbCA6IGxpbmVFbGVtZW50T3B0aW9ucy5maWxsKSxcblx0XHRcdFx0XHRzdGVwcGVkTGluZTogY3VzdG9tLnN0ZXBwZWRMaW5lID8gY3VzdG9tLnN0ZXBwZWRMaW5lIDogaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChkYXRhc2V0LnN0ZXBwZWRMaW5lLCBsaW5lRWxlbWVudE9wdGlvbnMuc3RlcHBlZCksXG5cdFx0XHRcdFx0Y3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogY3VzdG9tLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPyBjdXN0b20uY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA6IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQoZGF0YXNldC5jdWJpY0ludGVycG9sYXRpb25Nb2RlLCBsaW5lRWxlbWVudE9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSksXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bGluZS5waXZvdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0XHRmb3IgKGk9MCwgaWxlbj1wb2ludHMubGVuZ3RoOyBpPGlsZW47ICsraSkge1xuXHRcdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvd0xpbmUgJiYgbGluZS5fbW9kZWwudGVuc2lvbiAhPT0gMCkge1xuXHRcdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxuXHRcdFx0Zm9yIChpPTAsIGlsZW49cG9pbnRzLmxlbmd0aDsgaTxpbGVuOyArK2kpIHtcblx0XHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFBvaW50QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQuYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cblx0XHRcdGlmIChjdXN0b20uYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGFzZXQucG9pbnRCYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJhY2tncm91bmRDb2xvciwgaW5kZXgsIGJhY2tncm91bmRDb2xvcik7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGFzZXQuYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYmFja2dyb3VuZENvbG9yO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludEJvcmRlckNvbG9yOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdHZhciBib3JkZXJDb2xvciA9IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ib3JkZXJDb2xvcjtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXG5cdFx0XHRpZiAoY3VzdG9tLmJvcmRlckNvbG9yKSB7XG5cdFx0XHRcdGJvcmRlckNvbG9yID0gY3VzdG9tLmJvcmRlckNvbG9yO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhc2V0LnBvaW50Qm9yZGVyQ29sb3IpIHtcblx0XHRcdFx0Ym9yZGVyQ29sb3IgPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyQ29sb3IsIGluZGV4LCBib3JkZXJDb2xvcik7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGFzZXQuYm9yZGVyQ29sb3IpIHtcblx0XHRcdFx0Ym9yZGVyQ29sb3IgPSBkYXRhc2V0LmJvcmRlckNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm9yZGVyQ29sb3I7XG5cdFx0fSxcblxuXHRcdGdldFBvaW50Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdFx0dmFyIGJvcmRlcldpZHRoID0gdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cblx0XHRcdGlmICghaXNOYU4oY3VzdG9tLmJvcmRlcldpZHRoKSkge1xuXHRcdFx0XHRib3JkZXJXaWR0aCA9IGN1c3RvbS5ib3JkZXJXaWR0aDtcblx0XHRcdH0gZWxzZSBpZiAoIWlzTmFOKGRhdGFzZXQucG9pbnRCb3JkZXJXaWR0aCkpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyV2lkdGgsIGluZGV4LCBib3JkZXJXaWR0aCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFpc05hTihkYXRhc2V0LmJvcmRlcldpZHRoKSkge1xuXHRcdFx0XHRib3JkZXJXaWR0aCA9IGRhdGFzZXQuYm9yZGVyV2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBib3JkZXJXaWR0aDtcblx0XHR9LFxuXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0dmFyIHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdFx0dmFyIHBvaW50T3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0XHR2YXIgeCwgeTtcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcblx0XHRcdHZhciBpbmNsdWRlT2Zmc2V0ID0gKGxhYmVscy5sZW5ndGggPT09IDEgfHwgZGF0YXNldC5kYXRhLmxlbmd0aCA9PT0gMSkgfHwgbWUuY2hhcnQuaXNDb21ibztcblxuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnJhZGl1cyAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5wb2ludFJhZGl1cyA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LnBvaW50UmFkaXVzID0gZGF0YXNldC5yYWRpdXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGRhdGFzZXQuaGl0UmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50SGl0UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRIaXRSYWRpdXMgPSBkYXRhc2V0LmhpdFJhZGl1cztcblx0XHRcdH1cblxuXHRcdFx0eCA9IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IE5hTiwgaW5kZXgsIGRhdGFzZXRJbmRleCwgaW5jbHVkZU9mZnNldCk7XG5cdFx0XHR5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiBtZS5jYWxjdWxhdGVQb2ludFkodmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcblx0XHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeSxcblx0XHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0cmFkaXVzOiBjdXN0b20ucmFkaXVzIHx8IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRSYWRpdXMsIGluZGV4LCBwb2ludE9wdGlvbnMucmFkaXVzKSxcblx0XHRcdFx0cG9pbnRTdHlsZTogY3VzdG9tLnBvaW50U3R5bGUgfHwgaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludFN0eWxlLCBpbmRleCwgcG9pbnRPcHRpb25zLnBvaW50U3R5bGUpLFxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1lLmdldFBvaW50QmFja2dyb3VuZENvbG9yKHBvaW50LCBpbmRleCksXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBtZS5nZXRQb2ludEJvcmRlckNvbG9yKHBvaW50LCBpbmRleCksXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBtZS5nZXRQb2ludEJvcmRlcldpZHRoKHBvaW50LCBpbmRleCksXG5cdFx0XHRcdHRlbnNpb246IG1ldGEuZGF0YXNldC5fbW9kZWwgPyBtZXRhLmRhdGFzZXQuX21vZGVsLnRlbnNpb24gOiAwLFxuXHRcdFx0XHRzdGVwcGVkTGluZTogbWV0YS5kYXRhc2V0Ll9tb2RlbCA/IG1ldGEuZGF0YXNldC5fbW9kZWwuc3RlcHBlZExpbmUgOiBmYWxzZSxcblx0XHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0XHRoaXRSYWRpdXM6IGN1c3RvbS5oaXRSYWRpdXMgfHwgaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhpdFJhZGl1cywgaW5kZXgsIHBvaW50T3B0aW9ucy5oaXRSYWRpdXMpXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0XHR2YXIgc3VtUG9zID0gMDtcblx0XHRcdHZhciBzdW1OZWcgPSAwO1xuXHRcdFx0dmFyIGksIGRzLCBkc01ldGE7XG5cblx0XHRcdGlmICh5U2NhbGUub3B0aW9ucy5zdGFja2VkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7IGkrKykge1xuXHRcdFx0XHRcdGRzID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXTtcblx0XHRcdFx0XHRkc01ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRcdHZhciBzdGFja2VkUmlnaHRWYWx1ZSA9IE51bWJlcih5U2NhbGUuZ2V0UmlnaHRWYWx1ZShkcy5kYXRhW2luZGV4XSkpO1xuXHRcdFx0XHRcdFx0aWYgKHN0YWNrZWRSaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN1bVBvcyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciByaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cdFx0XHRcdGlmIChyaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1OZWcgKyByaWdodFZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtUG9zICsgcmlnaHRWYWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgcG9pbnRzID0gKG1ldGEuZGF0YSB8fCBbXSk7XG5cdFx0XHR2YXIgaSwgaWxlbiwgcG9pbnQsIG1vZGVsLCBjb250cm9sUG9pbnRzO1xuXG5cdFx0XHQvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuXHRcdFx0aWYgKG1ldGEuZGF0YXNldC5fbW9kZWwuc3BhbkdhcHMpIHtcblx0XHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1ldGEuZGF0YXNldC5fbW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0XHRoZWxwZXJzLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdFx0bW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdFx0XHRoZWxwZXJzLnByZXZpb3VzSXRlbShwb2ludHMsIGkpLl9tb2RlbCxcblx0XHRcdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRcdFx0aGVscGVycy5uZXh0SXRlbShwb2ludHMsIGkpLl9tb2RlbCxcblx0XHRcdFx0XHRcdG1ldGEuZGF0YXNldC5fbW9kZWwudGVuc2lvblxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZS5jYXBCZXppZXJQb2ludHMpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdFx0dmFyIGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdENoYXJ0LmNhbnZhc0hlbHBlcnMuY2xpcEFyZWEoY2hhcnQuY3R4LCBhcmVhKTtcblxuXHRcdFx0aWYgKGxpbmVFbmFibGVkKG1lLmdldERhdGFzZXQoKSwgY2hhcnQub3B0aW9ucykpIHtcblx0XHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblx0XHRcdH1cblxuXHRcdFx0Q2hhcnQuY2FudmFzSGVscGVycy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cblx0XHRcdC8vIERyYXcgdGhlIHBvaW50c1xuXHRcdFx0Zm9yICg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0Ly8gUG9pbnRcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3BvaW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdFx0dmFyIGluZGV4ID0gcG9pbnQuX2luZGV4O1xuXHRcdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLmhvdmVyUmFkaXVzIHx8IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlclJhZGl1cywgaW5kZXgsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ob3ZlclJhZGl1cyk7XG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgfHwgaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQmFja2dyb3VuZENvbG9yLCBpbmRleCwgaGVscGVycy5nZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciB8fCBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCB8fCBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJXaWR0aCwgaW5kZXgsIG1vZGVsLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQucmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRSYWRpdXMgPSBkYXRhc2V0LnJhZGl1cztcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLnJhZGl1cyB8fCBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5yYWRpdXMpO1xuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gbWUuZ2V0UG9pbnRCYWNrZ3JvdW5kQ29sb3IocG9pbnQsIGluZGV4KTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gbWUuZ2V0UG9pbnRCb3JkZXJDb2xvcihwb2ludCwgaW5kZXgpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBtZS5nZXRQb2ludEJvcmRlcldpZHRoKHBvaW50LCBpbmRleCk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0Q2hhcnQuZGVmYXVsdHMucG9sYXJBcmVhID0ge1xuXG5cdFx0c2NhbGU6IHtcblx0XHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdFx0YW5nbGVMaW5lczoge1xuXHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0fSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHBvaW50TGFiZWxzOiB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9LFxuXHRcdFx0dGlja3M6IHtcblx0XHRcdFx0YmVnaW5BdFplcm86IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XG5cdFx0YW5pbWF0aW9uOiB7XG5cdFx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXG5cdFx0fSxcblxuXHRcdHN0YXJ0QW5nbGU6IC0wLjUgKiBNYXRoLlBJLFxuXHRcdGFzcGVjdFJhdGlvOiAxLFxuXHRcdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIHRleHQgPSBbXTtcblx0XHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0XHR9LFxuXHRcdGxlZ2VuZDoge1xuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR2YXIgZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHRcdHZhciBmaWxsID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYmFja2dyb3VuZENvbG9yLCBpLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcik7XG5cdFx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyQ29sb3IsIGksIGFyY09wdHMuYm9yZGVyQ29sb3IpO1xuXHRcdFx0XHRcdFx0XHR2YXIgYncgPSBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyV2lkdGgsIGksIGFyY09wdHMuYm9yZGVyV2lkdGgpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0XHR0b29sdGlwczoge1xuXHRcdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF0gKyAnOiAnICsgdG9vbHRpcEl0ZW0ueUxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYXJ0LmNvbnRyb2xsZXJzLnBvbGFyQXJlYSA9IENoYXJ0LkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0XHRkYXRhRWxlbWVudFR5cGU6IENoYXJ0LmVsZW1lbnRzLkFyYyxcblxuXHRcdGxpbmtTY2FsZXM6IGhlbHBlcnMubm9vcCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHRcdHZhciBhcmNPcHRzID0gb3B0cy5lbGVtZW50cy5hcmM7XG5cdFx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cdFx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gYXJjT3B0cy5ib3JkZXJXaWR0aCAvIDIpIC8gMiwgMCk7XG5cdFx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuXHRcdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG5cdFx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gKGNoYXJ0LnJhZGl1c0xlbmd0aCAqIG1lLmluZGV4KTtcblx0XHRcdG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGg7XG5cblx0XHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjLCBpbmRleCwgcmVzZXQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG5cdFx0XHR2YXIgc2NhbGUgPSBjaGFydC5zY2FsZTtcblx0XHRcdHZhciBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblx0XHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcblxuXHRcdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdFx0dmFyIGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuXHRcdFx0dmFyIGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBOYU4gZGF0YSBiZWZvcmUgdXMsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBzdGFydGluZyBhbmdsZSBjb3JyZWN0bHkuXG5cdFx0XHQvLyBXZSBjb3VsZCBiZSB3YXkgbW9yZSBlZmZpY2llbnQgaGVyZSwgYnV0IGl0cyB1bmxpa2VseSB0aGF0IHRoZSBwb2xhciBhcmVhIGNoYXJ0IHdpbGwgaGF2ZSBhIGxvdCBvZiBkYXRhXG5cdFx0XHR2YXIgdmlzaWJsZUNvdW50ID0gMDtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgKytpKSB7XG5cdFx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2ldKSAmJiAhbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuXHRcdFx0XHRcdCsrdmlzaWJsZUNvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHZhciBuZWdIYWxmUEkgPSAtMC41ICogTWF0aC5QSTtcblx0XHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcblx0XHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgKiB2aXNpYmxlQ291bnQpO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IGNpcmN1bWZlcmVuY2UpO1xuXG5cdFx0XHR2YXIgcmVzZXRSYWRpdXMgPSBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblxuXHRcdFx0aGVscGVycy5leHRlbmQoYXJjLCB7XG5cdFx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRcdF9pbmRleDogaW5kZXgsXG5cdFx0XHRcdF9zY2FsZTogc2NhbGUsXG5cblx0XHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdFx0eDogY2VudGVyWCxcblx0XHRcdFx0XHR5OiBjZW50ZXJZLFxuXHRcdFx0XHRcdGlubmVyUmFkaXVzOiAwLFxuXHRcdFx0XHRcdG91dGVyUmFkaXVzOiByZXNldCA/IHJlc2V0UmFkaXVzIDogZGlzdGFuY2UsXG5cdFx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRcdGVuZEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IGVuZEFuZ2xlLFxuXHRcdFx0XHRcdGxhYmVsOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGJvcmRlciBhbmQgZmlsbCBzdHlsZVxuXHRcdFx0bWUucmVtb3ZlSG92ZXJTdHlsZShhcmMpO1xuXG5cdFx0XHRhcmMucGl2b3QoKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKHRoaXMsIGFyYywgdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYyk7XG5cdFx0fSxcblxuXHRcdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdFx0aWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRjYWxjdWxhdGVDaXJjdW1mZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIGNvdW50ID0gdGhpcy5nZXRNZXRhKCkuY291bnQ7XG5cdFx0XHRpZiAoY291bnQgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuICgyICogTWF0aC5QSSkgLyBjb3VudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXG5cdENoYXJ0LmRlZmF1bHRzLnJhZGFyID0ge1xuXHRcdGFzcGVjdFJhdGlvOiAxLFxuXHRcdHNjYWxlOiB7XG5cdFx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xuXHRcdH0sXG5cdFx0ZWxlbWVudHM6IHtcblx0XHRcdGxpbmU6IHtcblx0XHRcdFx0dGVuc2lvbjogMCAvLyBubyBiZXppZXIgaW4gcmFkYXJcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhcnQuY29udHJvbGxlcnMucmFkYXIgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdFx0ZGF0YXNldEVsZW1lbnRUeXBlOiBDaGFydC5lbGVtZW50cy5MaW5lLFxuXG5cdFx0ZGF0YUVsZW1lbnRUeXBlOiBDaGFydC5lbGVtZW50cy5Qb2ludCxcblxuXHRcdGxpbmtTY2FsZXM6IGhlbHBlcnMubm9vcCxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcblx0XHRcdHZhciBjdXN0b20gPSBsaW5lLmN1c3RvbSB8fCB7fTtcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdFx0dmFyIGxpbmVFbGVtZW50T3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChtZXRhLmRhdGFzZXQsIHtcblx0XHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X3NjYWxlOiBzY2FsZSxcblx0XHRcdFx0Ly8gRGF0YVxuXHRcdFx0XHRfY2hpbGRyZW46IHBvaW50cyxcblx0XHRcdFx0X2xvb3A6IHRydWUsXG5cdFx0XHRcdC8vIE1vZGVsXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0XHR0ZW5zaW9uOiBjdXN0b20udGVuc2lvbiA/IGN1c3RvbS50ZW5zaW9uIDogaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChkYXRhc2V0LmxpbmVUZW5zaW9uLCBsaW5lRWxlbWVudE9wdGlvbnMudGVuc2lvbiksXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IChkYXRhc2V0LmJhY2tncm91bmRDb2xvciB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSxcblx0XHRcdFx0XHRib3JkZXJXaWR0aDogY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogKGRhdGFzZXQuYm9yZGVyV2lkdGggfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKSxcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogKGRhdGFzZXQuYm9yZGVyQ29sb3IgfHwgbGluZUVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKSxcblx0XHRcdFx0XHRmaWxsOiBjdXN0b20uZmlsbCA/IGN1c3RvbS5maWxsIDogKGRhdGFzZXQuZmlsbCAhPT0gdW5kZWZpbmVkID8gZGF0YXNldC5maWxsIDogbGluZUVsZW1lbnRPcHRpb25zLmZpbGwpLFxuXHRcdFx0XHRcdGJvcmRlckNhcFN0eWxlOiBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgPyBjdXN0b20uYm9yZGVyQ2FwU3R5bGUgOiAoZGF0YXNldC5ib3JkZXJDYXBTdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpLFxuXHRcdFx0XHRcdGJvcmRlckRhc2g6IGN1c3RvbS5ib3JkZXJEYXNoID8gY3VzdG9tLmJvcmRlckRhc2ggOiAoZGF0YXNldC5ib3JkZXJEYXNoIHx8IGxpbmVFbGVtZW50T3B0aW9ucy5ib3JkZXJEYXNoKSxcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0OiBjdXN0b20uYm9yZGVyRGFzaE9mZnNldCA/IGN1c3RvbS5ib3JkZXJEYXNoT2Zmc2V0IDogKGRhdGFzZXQuYm9yZGVyRGFzaE9mZnNldCB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCksXG5cdFx0XHRcdFx0Ym9yZGVySm9pblN0eWxlOiBjdXN0b20uYm9yZGVySm9pblN0eWxlID8gY3VzdG9tLmJvcmRlckpvaW5TdHlsZSA6IChkYXRhc2V0LmJvcmRlckpvaW5TdHlsZSB8fCBsaW5lRWxlbWVudE9wdGlvbnMuYm9yZGVySm9pblN0eWxlKSxcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1ldGEuZGF0YXNldC5waXZvdCgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0XHRoZWxwZXJzLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGJlemllciBjb250cm9sIHBvaW50c1xuXHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXHRcdFx0dmFyIHBvaW50RWxlbWVudE9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQucmFkaXVzICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LnBvaW50UmFkaXVzID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQucG9pbnRSYWRpdXMgPSBkYXRhc2V0LnJhZGl1cztcblx0XHRcdH1cblx0XHRcdGlmICgoZGF0YXNldC5oaXRSYWRpdXMgIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQucG9pbnRIaXRSYWRpdXMgPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5wb2ludEhpdFJhZGl1cyA9IGRhdGFzZXQuaGl0UmFkaXVzO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChwb2ludCwge1xuXHRcdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0XHRfc2NhbGU6IHNjYWxlLFxuXG5cdFx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRcdHg6IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xuXHRcdFx0XHRcdHk6IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueSxcblxuXHRcdFx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdFx0XHR0ZW5zaW9uOiBjdXN0b20udGVuc2lvbiA/IGN1c3RvbS50ZW5zaW9uIDogaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChkYXRhc2V0LmxpbmVUZW5zaW9uLCBtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUudGVuc2lvbiksXG5cdFx0XHRcdFx0cmFkaXVzOiBjdXN0b20ucmFkaXVzID8gY3VzdG9tLnJhZGl1cyA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRSYWRpdXMsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLnJhZGl1cyksXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJhY2tncm91bmRDb2xvciksXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IGN1c3RvbS5ib3JkZXJDb2xvciA/IGN1c3RvbS5ib3JkZXJDb2xvciA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRCb3JkZXJDb2xvciwgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuYm9yZGVyQ29sb3IpLFxuXHRcdFx0XHRcdGJvcmRlcldpZHRoOiBjdXN0b20uYm9yZGVyV2lkdGggPyBjdXN0b20uYm9yZGVyV2lkdGggOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyV2lkdGgsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJvcmRlcldpZHRoKSxcblx0XHRcdFx0XHRwb2ludFN0eWxlOiBjdXN0b20ucG9pbnRTdHlsZSA/IGN1c3RvbS5wb2ludFN0eWxlIDogaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludFN0eWxlLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5wb2ludFN0eWxlKSxcblxuXHRcdFx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdFx0XHRoaXRSYWRpdXM6IGN1c3RvbS5oaXRSYWRpdXMgPyBjdXN0b20uaGl0UmFkaXVzIDogaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhpdFJhZGl1cywgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuaGl0UmFkaXVzKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cG9pbnQuX21vZGVsLnNraXAgPSBjdXN0b20uc2tpcCA/IGN1c3RvbS5za2lwIDogKGlzTmFOKHBvaW50Ll9tb2RlbC54KSB8fCBpc05hTihwb2ludC5fbW9kZWwueSkpO1xuXHRcdH0sXG5cdFx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2hhcnRBcmVhID0gdGhpcy5jaGFydC5jaGFydEFyZWE7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdFx0XHR2YXIgY29udHJvbFBvaW50cyA9IGhlbHBlcnMuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdFx0aGVscGVycy5wcmV2aW91c0l0ZW0obWV0YS5kYXRhLCBpbmRleCwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRcdGhlbHBlcnMubmV4dEl0ZW0obWV0YS5kYXRhLCBpbmRleCwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IHRoZSBiZXppZXIgZ29pbmcgb3V0c2lkZSBvZiB0aGUgYm91bmRzIG9mIHRoZSBncmFwaFxuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBNYXRoLm1heChNYXRoLm1pbihjb250cm9sUG9pbnRzLnByZXZpb3VzLngsIGNoYXJ0QXJlYS5yaWdodCksIGNoYXJ0QXJlYS5sZWZ0KTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gTWF0aC5tYXgoTWF0aC5taW4oY29udHJvbFBvaW50cy5wcmV2aW91cy55LCBjaGFydEFyZWEuYm90dG9tKSwgY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBNYXRoLm1heChNYXRoLm1pbihjb250cm9sUG9pbnRzLm5leHQueCwgY2hhcnRBcmVhLnJpZ2h0KSwgY2hhcnRBcmVhLmxlZnQpO1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IE1hdGgubWF4KE1hdGgubWluKGNvbnRyb2xQb2ludHMubmV4dC55LCBjaGFydEFyZWEuYm90dG9tKSwgY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRcdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0XHRcdHBvaW50LnBpdm90KCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdC8vIFBvaW50XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLnJhZGl1cyA9IGN1c3RvbS5ob3ZlclJhZGl1cyA/IGN1c3RvbS5ob3ZlclJhZGl1cyA6IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQucG9pbnRIb3ZlclJhZGl1cywgaW5kZXgsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ob3ZlclJhZGl1cyk7XG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBoZWxwZXJzLmdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yID8gY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50SG92ZXJCb3JkZXJDb2xvciwgaW5kZXgsIGhlbHBlcnMuZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA/IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIDogaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEhvdmVyQm9yZGVyV2lkdGgsIGluZGV4LCBtb2RlbC5ib3JkZXJXaWR0aCk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcblx0XHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0XHR2YXIgaW5kZXggPSBwb2ludC5faW5kZXg7XG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0XHR2YXIgcG9pbnRFbGVtZW50T3B0aW9ucyA9IHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblxuXHRcdFx0bW9kZWwucmFkaXVzID0gY3VzdG9tLnJhZGl1cyA/IGN1c3RvbS5yYWRpdXMgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50UmFkaXVzLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5yYWRpdXMpO1xuXHRcdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gY3VzdG9tLmJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50QmFja2dyb3VuZENvbG9yLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LnBvaW50Qm9yZGVyQ29sb3IsIGluZGV4LCBwb2ludEVsZW1lbnRPcHRpb25zLmJvcmRlckNvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5wb2ludEJvcmRlcldpZHRoLCBpbmRleCwgcG9pbnRFbGVtZW50T3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCIvKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXG5cdENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5hbmltYXRpb24gPSB7XG5cdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0Jyxcblx0XHRvblByb2dyZXNzOiBoZWxwZXJzLm5vb3AsXG5cdFx0b25Db21wbGV0ZTogaGVscGVycy5ub29wXG5cdH07XG5cblx0Q2hhcnQuQW5pbWF0aW9uID0gQ2hhcnQuRWxlbWVudC5leHRlbmQoe1xuXHRcdGNoYXJ0OiBudWxsLCAvLyB0aGUgYW5pbWF0aW9uIGFzc29jaWF0ZWQgY2hhcnQgaW5zdGFuY2Vcblx0XHRjdXJyZW50U3RlcDogMCwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXBcblx0XHRudW1TdGVwczogNjAsIC8vIGRlZmF1bHQgbnVtYmVyIG9mIHN0ZXBzXG5cdFx0ZWFzaW5nOiAnJywgLy8gdGhlIGVhc2luZyB0byB1c2UgZm9yIHRoaXMgYW5pbWF0aW9uXG5cdFx0cmVuZGVyOiBudWxsLCAvLyByZW5kZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgYW5pbWF0aW9uIHNlcnZpY2VcblxuXHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgb24gZWFjaCBzdGVwIG9mIHRoZSBhbmltYXRpb25cblx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlc1xuXHR9KTtcblxuXHRDaGFydC5hbmltYXRpb25TZXJ2aWNlID0ge1xuXHRcdGZyYW1lRHVyYXRpb246IDE3LFxuXHRcdGFuaW1hdGlvbnM6IFtdLFxuXHRcdGRyb3BGcmFtZXM6IDAsXG5cdFx0cmVxdWVzdDogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXG5cdFx0ICogQHBhcmFtIHtDaGFydC5BbmltYXRpb259IGFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdGhhdCB3ZSB3aWxsIGFuaW1hdGUuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtcy5cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcblx0XHQgKi9cblx0XHRhZGRBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb24sIGR1cmF0aW9uLCBsYXp5KSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0XHRhbmltYXRpb24uY2hhcnQgPSBjaGFydDtcblxuXHRcdFx0aWYgKCFsYXp5KSB7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaT0wLCBpbGVuPWFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBxdWV1ZWQsIG1hbnVhbGx5IGtpY2tzdGFydCBhIGRpZ2VzdCwgZm9yIGxhY2sgb2YgYSBiZXR0ZXIgd29yZFxuXHRcdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdHZhciBpbmRleCA9IGhlbHBlcnMuZmluZEluZGV4KHRoaXMuYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBhbmltYXRpb24uY2hhcnQgPT09IGNoYXJ0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dGhpcy5hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGlmIChtZS5yZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xuXHRcdFx0XHQvLyBhbmQgJ21vdXNlb3V0JyBldmVudHMgd2lsbCB0cmlnZ2VyIG11bHRpcGxlIHJlbmRlcnMuXG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRcdG1lLnN0YXJ0RGlnZXN0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHN0YXJ0RGlnZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdHZhciBmcmFtZXNUb0Ryb3AgPSAwO1xuXG5cdFx0XHRpZiAobWUuZHJvcEZyYW1lcyA+IDEpIHtcblx0XHRcdFx0ZnJhbWVzVG9Ecm9wID0gTWF0aC5mbG9vcihtZS5kcm9wRnJhbWVzKTtcblx0XHRcdFx0bWUuZHJvcEZyYW1lcyA9IG1lLmRyb3BGcmFtZXMgJSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5hZHZhbmNlKDEgKyBmcmFtZXNUb0Ryb3ApO1xuXG5cdFx0XHR2YXIgZW5kVGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdG1lLmRyb3BGcmFtZXMgKz0gKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gbWUuZnJhbWVEdXJhdGlvbjtcblxuXHRcdFx0Ly8gRG8gd2UgaGF2ZSBtb3JlIHN0dWZmIHRvIGFuaW1hdGU/XG5cdFx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGFkdmFuY2U6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHRcdHZhciBhbmltYXRpb24sIGNoYXJ0O1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG5cdFx0XHRcdGNoYXJ0ID0gYW5pbWF0aW9uLmNoYXJ0O1xuXG5cdFx0XHRcdGFuaW1hdGlvbi5jdXJyZW50U3RlcCA9IChhbmltYXRpb24uY3VycmVudFN0ZXAgfHwgMCkgKyBjb3VudDtcblx0XHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gTWF0aC5taW4oYW5pbWF0aW9uLmN1cnJlbnRTdGVwLCBhbmltYXRpb24ubnVtU3RlcHMpO1xuXG5cdFx0XHRcdGhlbHBlcnMuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdGhlbHBlcnMuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBhbmltYXRpb24ubnVtU3RlcHMpIHtcblx0XHRcdFx0XHRoZWxwZXJzLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCsraTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5BbmltYXRpb24gaW5zdGVhZFxuXHQgKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0LkFuaW1hdGlvbi5wcm90b3R5cGUsICdhbmltYXRpb25PYmplY3QnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcblx0ICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0SW5zdGFuY2Vcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhcnQuQW5pbWF0aW9uLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5jaGFydCA9IHZhbHVlO1xuXHRcdH1cblx0fSk7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblx0Ly8gR2xvYmFsIENoYXJ0IGNhbnZhcyBoZWxwZXJzIG9iamVjdCBmb3IgZHJhd2luZyBpdGVtcyB0byBjYW52YXNcblx0dmFyIGhlbHBlcnMgPSBDaGFydC5jYW52YXNIZWxwZXJzID0ge307XG5cblx0aGVscGVycy5kcmF3UG9pbnQgPSBmdW5jdGlvbihjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSkge1xuXHRcdHZhciB0eXBlLCBlZGdlTGVuZ3RoLCB4T2Zmc2V0LCB5T2Zmc2V0LCBoZWlnaHQsIHNpemU7XG5cblx0XHRpZiAodHlwZW9mIHBvaW50U3R5bGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0eXBlID0gcG9pbnRTdHlsZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UocG9pbnRTdHlsZSwgeCAtIHBvaW50U3R5bGUud2lkdGggLyAyLCB5IC0gcG9pbnRTdHlsZS5oZWlnaHQgLyAyLCBwb2ludFN0eWxlLndpZHRoLCBwb2ludFN0eWxlLmhlaWdodCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAocG9pbnRTdHlsZSkge1xuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndHJpYW5nbGUnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZWRnZUxlbmd0aCA9IDMgKiByYWRpdXMgLyBNYXRoLnNxcnQoMyk7XG5cdFx0XHRoZWlnaHQgPSBlZGdlTGVuZ3RoICogTWF0aC5zcXJ0KDMpIC8gMjtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIGVkZ2VMZW5ndGggLyAyLCB5ICsgaGVpZ2h0IC8gMyk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBlZGdlTGVuZ3RoIC8gMiwgeSArIGhlaWdodCAvIDMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gMiAqIGhlaWdodCAvIDMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0c2l6ZSA9IDEgLyBNYXRoLlNRUlQyICogcmFkaXVzO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdGN0eC5zdHJva2VSZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3RSb3VuZGVkJzpcblx0XHRcdHZhciBvZmZzZXQgPSByYWRpdXMgLyBNYXRoLlNRUlQyO1xuXHRcdFx0dmFyIGxlZnRYID0geCAtIG9mZnNldDtcblx0XHRcdHZhciB0b3BZID0geSAtIG9mZnNldDtcblx0XHRcdHZhciBzaWRlU2l6ZSA9IE1hdGguU1FSVDIgKiByYWRpdXM7XG5cdFx0XHRDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlKGN0eCwgbGVmdFgsIHRvcFksIHNpZGVTaXplLCBzaWRlU2l6ZSwgcmFkaXVzIC8gMik7XG5cdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdCc6XG5cdFx0XHRzaXplID0gMSAvIE1hdGguU1FSVDIgKiByYWRpdXM7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSBzaXplLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCwgeSArIHNpemUpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgc2l6ZSwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgLSBzaXplKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdjcm9zcyc6XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gcmFkaXVzKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHJhZGl1cywgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY3Jvc3NSb3QnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKE1hdGguUEkgLyA0KSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihNYXRoLlBJIC8gNCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgLSByYWRpdXMpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MoTWF0aC5QSSAvIDQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKE1hdGguUEkgLyA0KSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHR9O1xuXG5cdGhlbHBlcnMuY2xpcEFyZWEgPSBmdW5jdGlvbihjdHgsIGNsaXBBcmVhKSB7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QoY2xpcEFyZWEubGVmdCwgY2xpcEFyZWEudG9wLCBjbGlwQXJlYS5yaWdodCAtIGNsaXBBcmVhLmxlZnQsIGNsaXBBcmVhLmJvdHRvbSAtIGNsaXBBcmVhLnRvcCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0fTtcblxuXHRoZWxwZXJzLnVuY2xpcEFyZWEgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9O1xuXG5cdGhlbHBlcnMubGluZVRvID0gZnVuY3Rpb24oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG5cdFx0aWYgKHRhcmdldC5zdGVwcGVkTGluZSkge1xuXHRcdFx0aWYgKHRhcmdldC5zdGVwcGVkTGluZSA9PT0gJ2FmdGVyJykge1xuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGFyZ2V0LnRlbnNpb24pIHtcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmV6aWVyQ3VydmVUbyhcblx0XHRcdGZsaXA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWCA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRYLFxuXHRcdFx0ZmxpcD8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNZIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFksXG5cdFx0XHRmbGlwPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFggOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNYLFxuXHRcdFx0ZmxpcD8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRZIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWSxcblx0XHRcdHRhcmdldC54LFxuXHRcdFx0dGFyZ2V0LnkpO1xuXHR9O1xuXG5cdENoYXJ0LmhlbHBlcnMuY2FudmFzID0gaGVscGVycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cdHZhciBwbHVnaW5zID0gQ2hhcnQucGx1Z2lucztcblx0dmFyIHBsYXRmb3JtID0gQ2hhcnQucGxhdGZvcm07XG5cblx0Ly8gQ3JlYXRlIGEgZGljdGlvbmFyeSBvZiBjaGFydCB0eXBlcywgdG8gYWxsb3cgZm9yIGV4dGVuc2lvbiBvZiBleGlzdGluZyB0eXBlc1xuXHRDaGFydC50eXBlcyA9IHt9O1xuXG5cdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIGVhY2ggaW5zdGFuY2UgLSBhbGxvd2luZyB1cyB0byBnbG9iYWxseSByZXNpemUgY2hhcnQgaW5zdGFuY2VzIG9uIHdpbmRvdyByZXNpemUuXG5cdC8vIERlc3Ryb3kgbWV0aG9kIG9uIHRoZSBjaGFydCB3aWxsIHJlbW92ZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIGNoYXJ0IGZyb20gdGhpcyByZWZlcmVuY2UuXG5cdENoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG5cdC8vIENvbnRyb2xsZXJzIGF2YWlsYWJsZSBmb3IgZGF0YXNldCB2aXN1YWxpemF0aW9uIGVnLiBiYXIsIGxpbmUsIHNsaWNlLCBldGMuXG5cdENoYXJ0LmNvbnRyb2xsZXJzID0ge307XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBnaXZlbiBjb25maWcgd2l0aCBnbG9iYWwgYW5kIGNoYXJ0IGRlZmF1bHQgdmFsdWVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0XHQvLyBEbyBOT1QgdXNlIGNvbmZpZ01lcmdlKCkgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcblx0XHQvLyBhbmQgc28gd291bGQgY2hhbmdlIHJlZmVyZW5jZXMgdG8gbGFiZWxzIGFuZCBkYXRhc2V0cywgcHJldmVudGluZyBkYXRhIHVwZGF0ZXMuXG5cdFx0dmFyIGRhdGEgPSBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuXHRcdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXHRcdGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG5cblx0XHRjb25maWcub3B0aW9ucyA9IGhlbHBlcnMuY29uZmlnTWVyZ2UoXG5cdFx0XHRDaGFydC5kZWZhdWx0cy5nbG9iYWwsXG5cdFx0XHRDaGFydC5kZWZhdWx0c1tjb25maWcudHlwZV0sXG5cdFx0XHRjb25maWcub3B0aW9ucyB8fCB7fSk7XG5cblx0XHRyZXR1cm4gY29uZmlnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbmZpZyBvZiB0aGUgY2hhcnRcblx0ICogQHBhcmFtIGNoYXJ0IHtDaGFydH0gY2hhcnQgdG8gdXBkYXRlIHRoZSBvcHRpb25zIGZvclxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlQ29uZmlnKGNoYXJ0KSB7XG5cdFx0dmFyIG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xuXG5cdFx0Ly8gVXBkYXRlIFNjYWxlKHMpIHdpdGggb3B0aW9uc1xuXHRcdGlmIChuZXdPcHRpb25zLnNjYWxlKSB7XG5cdFx0XHRjaGFydC5zY2FsZS5vcHRpb25zID0gbmV3T3B0aW9ucy5zY2FsZTtcblx0XHR9IGVsc2UgaWYgKG5ld09wdGlvbnMuc2NhbGVzKSB7XG5cdFx0XHRuZXdPcHRpb25zLnNjYWxlcy54QXhlcy5jb25jYXQobmV3T3B0aW9ucy5zY2FsZXMueUF4ZXMpLmZvckVhY2goZnVuY3Rpb24oc2NhbGVPcHRpb25zKSB7XG5cdFx0XHRcdGNoYXJ0LnNjYWxlc1tzY2FsZU9wdGlvbnMuaWRdLm9wdGlvbnMgPSBzY2FsZU9wdGlvbnM7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBUb29sdGlwXG5cdFx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRcdHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9XG5cblx0aGVscGVycy5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCAvKiogQGxlbmRzIENoYXJ0ICovIHtcblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRjb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG5cblx0XHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHRcdHZhciBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuXHRcdFx0dmFyIGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuXHRcdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdFx0bWUuaWQgPSBoZWxwZXJzLnVpZCgpO1xuXHRcdFx0bWUuY3R4ID0gY29udGV4dDtcblx0XHRcdG1lLmNhbnZhcyA9IGNhbnZhcztcblx0XHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRcdG1lLndpZHRoID0gd2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodD8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuXHRcdFx0bWUub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIENoYXJ0IGFuZCBDaGFydC5Db250cm9sbGVyIGhhdmUgYmVlbiBtZXJnZWQsXG5cdFx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdFx0ICogQHByb3AgQ2hhcnQjY2hhcnRcblx0XHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0XHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0XHRtZS5jb250cm9sbGVyID0gbWU7ICAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cblxuXHRcdFx0Ly8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuXHRcdFx0Q2hhcnQuaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xuXG5cdFx0XHQvLyBEZWZpbmUgYWxpYXMgdG8gdGhlIGNvbmZpZyBkYXRhOiBgY2hhcnQuZGF0YSA9PT0gY2hhcnQuY29uZmlnLmRhdGFgXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdkYXRhJywge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBtZS5jb25maWcuZGF0YTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdG1lLmNvbmZpZy5kYXRhID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuXHRcdFx0XHQvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcblx0XHRcdFx0Ly8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcblx0XHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bWUuaW5pdGlhbGl6ZSgpO1xuXHRcdFx0bWUudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUluaXQnKTtcblxuXHRcdFx0aGVscGVycy5yZXRpbmFTY2FsZShtZSk7XG5cblx0XHRcdG1lLmJpbmRFdmVudHMoKTtcblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRcdG1lLnJlc2l6ZSh0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0XHRtZS5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdFx0XHRtZS5idWlsZFNjYWxlcygpO1xuXHRcdFx0bWUuaW5pdFRvb2xUaXAoKTtcblxuXHRcdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fSxcblxuXHRcdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2xlYXIodGhpcyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBTdG9wcyBhbnkgY3VycmVudCBhbmltYXRpb24gbG9vcCBvY2N1cnJpbmdcblx0XHRcdENoYXJ0LmFuaW1hdGlvblNlcnZpY2UuY2FuY2VsQW5pbWF0aW9uKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlc2l6ZTogZnVuY3Rpb24oc2lsZW50KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcblx0XHRcdHZhciBhc3BlY3RSYXRpbyA9IChvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbWUuYXNwZWN0UmF0aW8pIHx8IG51bGw7XG5cblx0XHRcdC8vIHRoZSBjYW52YXMgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBjYXN0ZWQgdG8gaW50ZWdlcnMgc28gbWFrZSBzdXJlIHRoYXRcblx0XHRcdC8vIHRoZSBjYW52YXMgZGlzcGxheSBzdHlsZSB1c2VzIHRoZSBzYW1lIGludGVnZXIgdmFsdWVzIHRvIGF2b2lkIGJsdXJyaW5nIGVmZmVjdC5cblx0XHRcdHZhciBuZXdXaWR0aCA9IE1hdGguZmxvb3IoaGVscGVycy5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSk7XG5cdFx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5mbG9vcihhc3BlY3RSYXRpbz8gbmV3V2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlbHBlcnMuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKTtcblxuXHRcdFx0aWYgKG1lLndpZHRoID09PSBuZXdXaWR0aCAmJiBtZS5oZWlnaHQgPT09IG5ld0hlaWdodCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNhbnZhcy53aWR0aCA9IG1lLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRcdGhlbHBlcnMucmV0aW5hU2NhbGUobWUpO1xuXG5cdFx0XHRpZiAoIXNpbGVudCkge1xuXHRcdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0XHR2YXIgbmV3U2l6ZSA9IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fTtcblx0XHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xuXG5cdFx0XHRcdC8vIE5vdGlmeSBvZiByZXNpemVcblx0XHRcdFx0aWYgKG1lLm9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0XHRtZS5vcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdFx0bWUudXBkYXRlKG1lLm9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZW5zdXJlU2NhbGVzSGF2ZUlEczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gb3B0aW9ucy5zY2FsZTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdFx0eEF4aXNPcHRpb25zLmlkID0geEF4aXNPcHRpb25zLmlkIHx8ICgneC1heGlzLScgKyBpbmRleCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdFx0eUF4aXNPcHRpb25zLmlkID0geUF4aXNPcHRpb25zLmlkIHx8ICgneS1heGlzLScgKyBpbmRleCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0XHRzY2FsZU9wdGlvbnMuaWQgPSBzY2FsZU9wdGlvbnMuaWQgfHwgJ3NjYWxlJztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0XHQgKi9cblx0XHRidWlsZFNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyA9IHt9O1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cblx0XHRcdGlmIChvcHRpb25zLnNjYWxlcykge1xuXHRcdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeEF4aXNPcHRpb25zLCBkdHlwZTogJ2NhdGVnb3J5JywgZHBvc2l0aW9uOiAnYm90dG9tJ307XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHlBeGlzT3B0aW9ucywgZHR5cGU6ICdsaW5lYXInLCBkcG9zaXRpb246ICdsZWZ0J307XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdFx0b3B0aW9uczogb3B0aW9ucy5zY2FsZSxcblx0XHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxuXHRcdFx0XHRcdGRwb3NpdGlvbjogJ2NoYXJ0QXJlYSdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuXHRcdFx0XHR2YXIgc2NhbGVUeXBlID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cdFx0XHRcdHZhciBzY2FsZUNsYXNzID0gQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlQ29uc3RydWN0b3Ioc2NhbGVUeXBlKTtcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuXHRcdFx0XHRcdHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuXHRcdFx0XHRcdGlkOiBzY2FsZU9wdGlvbnMuaWQsXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxuXHRcdFx0XHRcdGNoYXJ0OiBtZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG5cblx0XHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXG5cdFx0XHRcdC8vIG1ha2UgdGhlIGxvZ2ljIGVhc2llciBhbmQgcmVtb3ZlIHNvbWUgdXNlbGVzcz8gY3VzdG9tIGNvZGUuXG5cdFx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRDaGFydC5zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdFx0fSxcblxuXHRcdGJ1aWxkT3JVcGRhdGVDb250cm9sbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHR5cGVzID0gW107XG5cdFx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBbXTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmICghbWV0YS50eXBlKSB7XG5cdFx0XHRcdFx0bWV0YS50eXBlID0gZGF0YXNldC50eXBlIHx8IG1lLmNvbmZpZy50eXBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHlwZXMucHVzaChtZXRhLnR5cGUpO1xuXG5cdFx0XHRcdGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgQ29udHJvbGxlckNsYXNzID0gQ2hhcnQuY29udHJvbGxlcnNbbWV0YS50eXBlXTtcblx0XHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbWV0YS50eXBlICsgJ1wiIGlzIG5vdCBhIGNoYXJ0IHR5cGUuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0aWYgKHR5cGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh0eXBlc1tpXSAhPT0gdHlwZXNbaSAtIDFdKSB7XG5cdFx0XHRcdFx0XHRtZS5pc0NvbWJvID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3Q29udHJvbGxlcnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGhlbHBlcnMuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9LCBtZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0J3Mgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHRcdCovXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldEVsZW1lbnRzKCk7XG5cdFx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGFuaW1hdGlvbkR1cmF0aW9uLCBsYXp5KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHR1cGRhdGVDb25maWcobWUpO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG5cdFx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMoKTtcblx0XHRcdH0sIG1lKTtcblxuXHRcdFx0bWUudXBkYXRlTGF5b3V0KCk7XG5cblx0XHRcdC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdFx0aGVscGVycy5lYWNoKG5ld0NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cdFx0XHRcdGNvbnRyb2xsZXIucmVzZXQoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRcdGlmIChtZS5fYnVmZmVyZWRSZW5kZXIpIHtcblx0XHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IHtcblx0XHRcdFx0XHRsYXp5OiBsYXp5LFxuXHRcdFx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUucmVuZGVyKGFuaW1hdGlvbkR1cmF0aW9uLCBsYXp5KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRDaGFydC5sYXlvdXRTZXJ2aWNlLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXG5cdFx0XHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJTY2FsZVVwZGF0ZVxuXHRcdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0XHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c1VwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzVXBkYXRlJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0XHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVwZGF0ZURhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0XHR2YXIgYXJncyA9IHtcblx0XHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlKCk7XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKTtcblx0XHR9LFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbihkdXJhdGlvbiwgbGF6eSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0aWYgKHBsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlUmVuZGVyJykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcblx0XHRcdFx0aGVscGVycy5jYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIG1lKTtcblx0XHRcdH07XG5cblx0XHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmICgodHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBkdXJhdGlvbiAhPT0gMCkgfHwgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgJiYgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbiAhPT0gMCkpKSB7XG5cdFx0XHRcdHZhciBhbmltYXRpb24gPSBuZXcgQ2hhcnQuQW5pbWF0aW9uKHtcblx0XHRcdFx0XHRudW1TdGVwczogKGR1cmF0aW9uIHx8IGFuaW1hdGlvbk9wdGlvbnMuZHVyYXRpb24pIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRcdGVhc2luZzogYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb25PYmplY3QpIHtcblx0XHRcdFx0XHRcdHZhciBlYXNpbmdGdW5jdGlvbiA9IGhlbHBlcnMuZWFzaW5nRWZmZWN0c1thbmltYXRpb25PYmplY3QuZWFzaW5nXTtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xuXG5cdFx0XHRcdFx0XHRjaGFydC5kcmF3KGVhc2luZ0Z1bmN0aW9uKHN0ZXBEZWNpbWFsKSwgc3RlcERlY2ltYWwsIGN1cnJlbnRTdGVwKTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0b25BbmltYXRpb25Qcm9ncmVzczogYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLFxuXHRcdFx0XHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG9uQ29tcGxldGVcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Q2hhcnQuYW5pbWF0aW9uU2VydmljZS5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuZHJhdygpO1xuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0XHRvbkNvbXBsZXRlKG5ldyBDaGFydC5BbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZTtcblx0XHR9LFxuXG5cdFx0ZHJhdzogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdG1lLmNsZWFyKCk7XG5cblx0XHRcdGlmIChlYXNpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGVhc2luZ1ZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdGVhc2luZ1ZhbHVlID0gMTtcblx0XHRcdH1cblxuXHRcdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IGFsbCB0aGUgc2NhbGVzXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdFx0fSwgbWUpO1xuXG5cdFx0XHRpZiAobWUuc2NhbGUpIHtcblx0XHRcdFx0bWUuc2NhbGUuZHJhdygpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5kcmF3RGF0YXNldHMoZWFzaW5nVmFsdWUpO1xuXG5cdFx0XHQvLyBGaW5hbGx5IGRyYXcgdGhlIHRvb2x0aXBcblx0XHRcdG1lLnRvb2x0aXAuZHJhdygpO1xuXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRmb3IgKHZhciBpPTAsIGlsZW49KG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaTxpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRtZS5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG1lLnRvb2x0aXAudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHRcdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRkcmF3RGF0YXNldHM6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRcdGZvciAodmFyIGk9KG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWUuZHJhd0RhdGFzZXQoaSwgZWFzaW5nVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdFx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZHJhd0RhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4LCBlYXNpbmdWYWx1ZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAocGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRyYXcoZWFzaW5nVmFsdWUpO1xuXG5cdFx0XHRwbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgdGhlIHNpbmdsZSBlbGVtZW50IHRoYXQgd2FzIGNsaWNrZWQgb25cblx0XHQvLyBAcmV0dXJuIDogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XG5cdFx0Z2V0RWxlbWVudEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5zaW5nbGUodGhpcywgZSk7XG5cdFx0fSxcblxuXHRcdGdldEVsZW1lbnRzQXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0cmV0dXJuIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0XHR9LFxuXG5cdFx0Z2V0RWxlbWVudHNBdFhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0XHR9LFxuXG5cdFx0Z2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZTogZnVuY3Rpb24oZSwgbW9kZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIG1ldGhvZCA9IENoYXJ0LkludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0sXG5cblx0XHRnZXREYXRhc2V0QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdFx0cmV0dXJuIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXQodGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHRcdH0sXG5cblx0XHRnZXREYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0XHRpZiAoIWRhdGFzZXQuX21ldGEpIHtcblx0XHRcdFx0ZGF0YXNldC5fbWV0YSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xuXHRcdFx0aWYgKCFtZXRhKSB7XG5cdFx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcblx0XHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHRcdGRhdGFzZXQ6IG51bGwsXG5cdFx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcblx0XHRcdFx0XHRoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG5cdFx0XHRcdFx0eEF4aXNJRDogbnVsbCxcblx0XHRcdFx0XHR5QXhpc0lEOiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZXRhO1xuXHRcdH0sXG5cblx0XHRnZXRWaXNpYmxlRGF0YXNldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb3VudCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdGlzRGF0YXNldFZpc2libGU6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHRcdC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcblx0XHRcdC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cblx0XHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJz8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sZWdlbmRDYWxsYmFjayh0aGlzKTtcblx0XHR9LFxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcblx0XHRcdHZhciBtZXRhLCBpLCBpbGVuO1xuXG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIGRhdGFzZXQgY29udHJvbGxlcnMgbmVlZCB0byBjbGVhbnVwIGFzc29jaWF0ZWQgZGF0YVxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRcdG1ldGEuY29udHJvbGxlci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRcdG1lLnVuYmluZEV2ZW50cygpO1xuXHRcdFx0XHRoZWxwZXJzLmNsZWFyKG1lKTtcblx0XHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcblx0XHRcdFx0bWUuY2FudmFzID0gbnVsbDtcblx0XHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XG5cblx0XHRcdGRlbGV0ZSBDaGFydC5pbnN0YW5jZXNbbWUuaWRdO1xuXHRcdH0sXG5cblx0XHR0b0Jhc2U2NEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRtZS50b29sdGlwID0gbmV3IENoYXJ0LlRvb2x0aXAoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRfZGF0YTogbWUuZGF0YSxcblx0XHRcdFx0X29wdGlvbnM6IG1lLm9wdGlvbnMudG9vbHRpcHNcblx0XHRcdH0sIG1lKTtcblx0XHRcdG1lLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XG5cdFx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblxuXHRcdFx0aGVscGVycy5lYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmVzcG9uc2l2ZW5lc3MgaXMgY3VycmVudGx5IGJhc2VkIG9uIHRoZSB1c2Ugb2YgYW4gaWZyYW1lLCBob3dldmVyIHRoaXMgbWV0aG9kIGNhdXNlc1xuXHRcdFx0Ly8gcGVyZm9ybWFuY2UgaXNzdWVzIGFuZCBjb3VsZCBiZSB0cm91Ymxlc29tZSB3aGVuIHVzZWQgd2l0aCBhZCBibG9ja2Vycy4gU28gbWFrZSBzdXJlXG5cdFx0XHQvLyB0aGF0IHRoZSB1c2VyIGlzIHN0aWxsIGFibGUgdG8gY3JlYXRlIGEgY2hhcnQgd2l0aG91dCBpZnJhbWUgd2hlbiByZXNwb25zaXZlIGlzIGZhbHNlLlxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblx0XHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IG1lLl9saXN0ZW5lcnM7XG5cdFx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdFx0aGVscGVycy5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnRzLCBtb2RlLCBlbmFibGVkKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gZW5hYmxlZD8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdFx0dmFyIGVsZW1lbnQsIGksIGlsZW47XG5cblx0XHRcdGZvciAoaT0wLCBpbGVuPWVsZW1lbnRzLmxlbmd0aDsgaTxpbGVuOyArK2kpIHtcblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudC5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyW21ldGhvZF0oZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cblx0XHRcdGlmIChwbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUV2ZW50JywgW2VdKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdWZmZXIgYW55IHVwZGF0ZSBjYWxscyBzbyB0aGF0IHJlbmRlcnMgZG8gbm90IG9jY3VyXG5cdFx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRcdHZhciBjaGFuZ2VkID0gbWUuaGFuZGxlRXZlbnQoZSk7XG5cdFx0XHRjaGFuZ2VkIHw9IHRvb2x0aXAgJiYgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblxuXHRcdFx0cGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcblxuXHRcdFx0dmFyIGJ1ZmZlcmVkUmVxdWVzdCA9IG1lLl9idWZmZXJlZFJlcXVlc3Q7XG5cdFx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYW4gdXBkYXRlIHRoYXQgd2FzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBkbyBhIG5vcm1hbCByZW5kZXJcblx0XHRcdFx0bWUucmVuZGVyKGJ1ZmZlcmVkUmVxdWVzdC5kdXJhdGlvbiwgYnVmZmVyZWRSZXF1ZXN0LmxhenkpO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFuZ2VkICYmICFtZS5hbmltYXRpbmcpIHtcblx0XHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRcdG1lLnN0b3AoKTtcblxuXHRcdFx0XHQvLyBXZSBvbmx5IG5lZWQgdG8gcmVuZGVyIGF0IHRoaXMgcG9pbnQuIFVwZGF0aW5nIHdpbGwgY2F1c2Ugc2NhbGVzIHRvIGJlXG5cdFx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRcdG1lLnJlbmRlcihtZS5vcHRpb25zLmhvdmVyLmFuaW1hdGlvbkR1cmF0aW9uLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3Zlcjtcblx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgaG92ZXIgYW5kIHRvb2x0aXBzXG5cdFx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuYWN0aXZlID0gbWUuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT24gSG92ZXIgaG9va1xuXHRcdFx0aWYgKGhvdmVyT3B0aW9ucy5vbkhvdmVyKSB7XG5cdFx0XHRcdC8vIE5lZWQgdG8gY2FsbCB3aXRoIG5hdGl2ZSBldmVudCBoZXJlIHRvIG5vdCBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRob3Zlck9wdGlvbnMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuYWN0aXZlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdFx0Ly8gVXNlIGUubmF0aXZlIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0b3B0aW9ucy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBtZS5hY3RpdmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBzdHlsaW5nIGZvciBsYXN0IGFjdGl2ZSAoZXZlbiBpZiBpdCBtYXkgc3RpbGwgYmUgYWN0aXZlKVxuXHRcdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUubGFzdEFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdFx0aWYgKG1lLmFjdGl2ZS5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcblx0XHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5hY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Y2hhbmdlZCA9ICFoZWxwZXJzLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmFjdGl2ZTtcblxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydCBpbnN0ZWFkLlxuXHQgKiBAY2xhc3MgQ2hhcnQuQ29udHJvbGxlclxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdENoYXJ0LkNvbnRyb2xsZXIgPSBDaGFydDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0dmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuXG5cdC8qKlxuXHQgKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuXHQgKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG5cdCAqIGNhbGxlZCBvbiB0aGUgJ29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBvbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdFx0aWYgKGFycmF5Ll9jaGFydGpzKSB7XG5cdFx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdGxpc3RlbmVyczogW2xpc3RlbmVyXVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciBtZXRob2QgPSAnb25EYXRhJyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblx0XHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRvYmplY3RbbWV0aG9kXS5hcHBseShvYmplY3QsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuXHQgKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRcdGlmICghc3R1Yikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcblx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlbGV0ZSBhcnJheVtrZXldO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xuXHR9XG5cblx0Ly8gQmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgKGxpbmUsIGJhciwgZXRjKVxuXHRDaGFydC5EYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR0aGlzLmluaXRpYWxpemUoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cdH07XG5cblx0aGVscGVycy5leHRlbmQoQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0XHQvKipcblx0XHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmUpLlxuXHRcdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdFx0ICovXG5cdFx0ZGF0YXNldEVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXG5cdFx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0XHQgKi9cblx0XHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0bWUuY2hhcnQgPSBjaGFydDtcblx0XHRcdG1lLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdFx0bWUuYWRkRWxlbWVudHMoKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHR9LFxuXG5cdFx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgbWUuY2hhcnQub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uaWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsKSB7XG5cdFx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuXHRcdH0sXG5cblx0XHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuXHRcdH0sXG5cblx0XHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudXBkYXRlKHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX2RhdGEpIHtcblx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0eXBlID0gbWUuZGF0YXNldEVsZW1lbnRUeXBlO1xuXHRcdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZU1ldGFEYXRhOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0eXBlID0gbWUuZGF0YUVsZW1lbnRUeXBlO1xuXHRcdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdFx0X2luZGV4OiBpbmRleFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGFkZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdFx0Zm9yIChpPTAsIGlsZW49ZGF0YS5sZW5ndGg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuZGF0YXNldCA9IG1ldGEuZGF0YXNldCB8fCBtZS5jcmVhdGVNZXRhRGF0YXNldCgpO1xuXHRcdH0sXG5cblx0XHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlTWV0YURhdGEoaW5kZXgpO1xuXHRcdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHRcdC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuIHRodXMgc2ltdWxhdGVcblx0XHRcdC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuXHRcdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRcdGlmIChtZS5fZGF0YSAhPT0gZGF0YSkge1xuXHRcdFx0XHRpZiAobWUuX2RhdGEpIHtcblx0XHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHMobWUuX2RhdGEsIG1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIG1lKTtcblx0XHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuXHRcdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogaGVscGVycy5ub29wLFxuXG5cdFx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0Zm9yICg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdGVsZW1lbnRzW2ldLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRcdG1ldGEuZGF0YXNldC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICg7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCwgZWxlbWVudE9wdHMpIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF0sXG5cdFx0XHRcdGluZGV4ID0gZWxlbWVudC5faW5kZXgsXG5cdFx0XHRcdGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9LFxuXHRcdFx0XHR2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0LFxuXHRcdFx0XHRtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXG5cdFx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXN0b20uYmFja2dyb3VuZENvbG9yID8gY3VzdG9tLmJhY2tncm91bmRDb2xvciA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yLCBpbmRleCwgZWxlbWVudE9wdHMuYmFja2dyb3VuZENvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlckNvbG9yID0gY3VzdG9tLmJvcmRlckNvbG9yID8gY3VzdG9tLmJvcmRlckNvbG9yIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJDb2xvciwgaW5kZXgsIGVsZW1lbnRPcHRzLmJvcmRlckNvbG9yKTtcblx0XHRcdG1vZGVsLmJvcmRlcldpZHRoID0gY3VzdG9tLmJvcmRlcldpZHRoID8gY3VzdG9tLmJvcmRlcldpZHRoIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ib3JkZXJXaWR0aCwgaW5kZXgsIGVsZW1lbnRPcHRzLmJvcmRlcldpZHRoKTtcblx0XHR9LFxuXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZWxlbWVudC5fZGF0YXNldEluZGV4XSxcblx0XHRcdFx0aW5kZXggPSBlbGVtZW50Ll9pbmRleCxcblx0XHRcdFx0Y3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge30sXG5cdFx0XHRcdHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQsXG5cdFx0XHRcdGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzLmdldEhvdmVyQ29sb3IsXG5cdFx0XHRcdG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XG5cblx0XHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA/IGN1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciA6IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGluZGV4LCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSBjdXN0b20uaG92ZXJCb3JkZXJDb2xvciA/IGN1c3RvbS5ob3ZlckJvcmRlckNvbG9yIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBpbmRleCwgZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcikpO1xuXHRcdFx0bW9kZWwuYm9yZGVyV2lkdGggPSBjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCA/IGN1c3RvbS5ob3ZlckJvcmRlcldpZHRoIDogdmFsdWVPckRlZmF1bHQoZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBpbmRleCwgbW9kZWwuYm9yZGVyV2lkdGgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XG5cdFx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuXG5cdFx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdFx0bWV0YS5kYXRhLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG5cdFx0XHR9IGVsc2UgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG5cdFx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8Y291bnQ7ICsraSkge1xuXHRcdFx0XHR0aGlzLmFkZEVsZW1lbnRBbmRSZXNldChzdGFydCArIGkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pbnNlcnRFbGVtZW50cyh0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aC0xLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5wb3AoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNoaWZ0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG5cdFx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0b25EYXRhVW5zaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmluc2VydEVsZW1lbnRzKDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoJ2NoYXJ0anMtY29sb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcblx0XHR2YXIgaSwgaWxlbiwga2V5LCBhY3R1YWwsIG9yaWdpbiwgdGFyZ2V0LCB0eXBlLCBjMCwgYzE7XG5cblx0XHRmb3IgKGk9MCwgaWxlbj1rZXlzLmxlbmd0aDsgaTxpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cblx0XHRcdHRhcmdldCA9IG1vZGVsW2tleV07XG5cblx0XHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xuXHRcdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXG5cdFx0XHRpZiAoIXZpZXcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGFjdHVhbCA9IHZpZXdba2V5XTtcblxuXHRcdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcblx0XHRcdH1cblxuXHRcdFx0b3JpZ2luID0gc3RhcnRba2V5XTtcblxuXHRcdFx0dHlwZSA9IHR5cGVvZih0YXJnZXQpO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gdHlwZW9mKG9yaWdpbikpIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0YzAgPSBjb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRcdGlmIChjMC52YWxpZCkge1xuXHRcdFx0XHRcdFx0YzEgPSBjb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XG5cdFx0XHRcdFx0XHRcdHZpZXdba2V5XSA9IGMxLm1peChjMCwgZWFzZSkucmdiU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShvcmlnaW4pICYmIGlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHRcdH1cblx0fVxuXG5cdENoYXJ0LmVsZW1lbnRzID0ge307XG5cblx0Q2hhcnQuRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0XHRoZWxwZXJzLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcblx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRoZWxwZXJzLmV4dGVuZChDaGFydC5FbGVtZW50LnByb3RvdHlwZSwge1xuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKCFtZS5fdmlldykge1xuXHRcdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMuY2xvbmUobWUuX21vZGVsKTtcblx0XHRcdH1cblx0XHRcdG1lLl9zdGFydCA9IHt9O1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH0sXG5cblx0XHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNlKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdFx0dmFyIHN0YXJ0ID0gbWUuX3N0YXJ0O1xuXHRcdFx0dmFyIHZpZXcgPSBtZS5fdmlldztcblxuXHRcdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRcdGlmICghbW9kZWwgfHwgZWFzZSA9PT0gMSkge1xuXHRcdFx0XHRtZS5fdmlldyA9IG1vZGVsO1xuXHRcdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdmlldykge1xuXHRcdFx0XHR2aWV3ID0gbWUuX3ZpZXcgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fSxcblxuXHRcdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB0aGlzLl9tb2RlbC54LFxuXHRcdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzLmlzTnVtYmVyKHRoaXMuX21vZGVsLnkpO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuRWxlbWVudC5leHRlbmQgPSBoZWxwZXJzLmluaGVyaXRzO1xufTtcbiIsIi8qIGdsb2JhbCB3aW5kb3c6IGZhbHNlICovXG4vKiBnbG9iYWwgZG9jdW1lbnQ6IGZhbHNlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoJ2NoYXJ0anMtY29sb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXHQvLyBHbG9iYWwgQ2hhcnQgaGVscGVycyBvYmplY3QgZm9yIHV0aWxpdHkgbWV0aG9kcyBhbmQgY2xhc3Nlc1xuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnMgPSB7fTtcblxuXHQvLyAtLSBCYXNpYyBqcyB1dGlsaXR5IG1ldGhvZHNcblx0aGVscGVycy5lYWNoID0gZnVuY3Rpb24obG9vcGFibGUsIGNhbGxiYWNrLCBzZWxmLCByZXZlcnNlKSB7XG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIG51bGwgb3IgdW5kZWZpbmVkIGZpcnN0bHkuXG5cdFx0dmFyIGksIGxlbjtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBsb29wYWJsZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIG9iakNsb25lID0ge307XG5cdFx0aGVscGVycy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0b2JqQ2xvbmVba2V5XSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRcdG9iakNsb25lW2tleV0gPSBoZWxwZXJzLmNsb25lKHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9iakNsb25lW2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gb2JqQ2xvbmU7XG5cdH07XG5cdGhlbHBlcnMuZXh0ZW5kID0gZnVuY3Rpb24oYmFzZSkge1xuXHRcdHZhciBzZXRGbiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdGJhc2Vba2V5XSA9IHZhbHVlO1xuXHRcdH07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGlsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRoZWxwZXJzLmVhY2goYXJndW1lbnRzW2ldLCBzZXRGbik7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9O1xuXHQvLyBOZWVkIGEgc3BlY2lhbCBtZXJnZSBmdW5jdGlvbiB0byBjaGFydCBjb25maWdzIHNpbmNlIHRoZXkgYXJlIG5vdyBncm91cGVkXG5cdGhlbHBlcnMuY29uZmlnTWVyZ2UgPSBmdW5jdGlvbihfYmFzZSkge1xuXHRcdHZhciBiYXNlID0gaGVscGVycy5jbG9uZShfYmFzZSk7XG5cdFx0aGVscGVycy5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuXHRcdFx0aGVscGVycy5lYWNoKGV4dGVuc2lvbiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR2YXIgYmFzZUhhc1Byb3BlcnR5ID0gYmFzZS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHRcdFx0XHR2YXIgYmFzZVZhbCA9IGJhc2VIYXNQcm9wZXJ0eSA/IGJhc2Vba2V5XSA6IHt9O1xuXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzY2FsZXMnKSB7XG5cdFx0XHRcdFx0Ly8gU2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHRcdGJhc2Vba2V5XSA9IGhlbHBlcnMuc2NhbGVNZXJnZShiYXNlVmFsLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdFx0Ly8gVXNlZCBpbiBwb2xhciBhcmVhICYgcmFkYXIgY2hhcnRzIHNpbmNlIHRoZXJlIGlzIG9ubHkgb25lIHNjYWxlXG5cdFx0XHRcdFx0YmFzZVtrZXldID0gaGVscGVycy5jb25maWdNZXJnZShiYXNlVmFsLCBDaGFydC5zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyh2YWx1ZS50eXBlKSwgdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGJhc2VIYXNQcm9wZXJ0eVxuXHRcdFx0XHRcdFx0JiYgdHlwZW9mIGJhc2VWYWwgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0XHQmJiAhaGVscGVycy5pc0FycmF5KGJhc2VWYWwpXG5cdFx0XHRcdFx0XHQmJiBiYXNlVmFsICE9PSBudWxsXG5cdFx0XHRcdFx0XHQmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0XHQmJiAhaGVscGVycy5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBvdmVyd3JpdGluZyBhbiBvYmplY3Qgd2l0aCBhbiBvYmplY3QsIGRvIGEgbWVyZ2Ugb2YgdGhlIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0YmFzZVtrZXldID0gaGVscGVycy5jb25maWdNZXJnZShiYXNlVmFsLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY2FuIGp1c3Qgb3ZlcndyaXRlIHRoZSB2YWx1ZSBpbiB0aGlzIGNhc2Vcblx0XHRcdFx0XHRiYXNlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gYmFzZTtcblx0fTtcblx0aGVscGVycy5zY2FsZU1lcmdlID0gZnVuY3Rpb24oX2Jhc2UsIGV4dGVuc2lvbikge1xuXHRcdHZhciBiYXNlID0gaGVscGVycy5jbG9uZShfYmFzZSk7XG5cblx0XHRoZWxwZXJzLmVhY2goZXh0ZW5zaW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRpZiAoa2V5ID09PSAneEF4ZXMnIHx8IGtleSA9PT0gJ3lBeGVzJykge1xuXHRcdFx0XHQvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgaXRlbXNcblx0XHRcdFx0aWYgKGJhc2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaCh2YWx1ZSwgZnVuY3Rpb24odmFsdWVPYmosIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgYXhpc1R5cGUgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHZhbHVlT2JqLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XG5cdFx0XHRcdFx0XHR2YXIgYXhpc0RlZmF1bHRzID0gQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoYXhpc1R5cGUpO1xuXHRcdFx0XHRcdFx0aWYgKGluZGV4ID49IGJhc2Vba2V5XS5sZW5ndGggfHwgIWJhc2Vba2V5XVtpbmRleF0udHlwZSkge1xuXHRcdFx0XHRcdFx0XHRiYXNlW2tleV0ucHVzaChoZWxwZXJzLmNvbmZpZ01lcmdlKGF4aXNEZWZhdWx0cywgdmFsdWVPYmopKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWVPYmoudHlwZSAmJiB2YWx1ZU9iai50eXBlICE9PSBiYXNlW2tleV1baW5kZXhdLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Ly8gVHlwZSBjaGFuZ2VkLiBCcmluZyBpbiB0aGUgbmV3IGRlZmF1bHRzIGJlZm9yZSB3ZSBicmluZyBpbiB2YWx1ZU9iaiBzbyB0aGF0IHZhbHVlT2JqIGNhbiBvdmVycmlkZSB0aGUgY29ycmVjdCBzY2FsZSBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0XHRiYXNlW2tleV1baW5kZXhdID0gaGVscGVycy5jb25maWdNZXJnZShiYXNlW2tleV1baW5kZXhdLCBheGlzRGVmYXVsdHMsIHZhbHVlT2JqKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFR5cGUgaXMgdGhlIHNhbWVcblx0XHRcdFx0XHRcdFx0YmFzZVtrZXldW2luZGV4XSA9IGhlbHBlcnMuY29uZmlnTWVyZ2UoYmFzZVtrZXldW2luZGV4XSwgdmFsdWVPYmopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJhc2Vba2V5XSA9IFtdO1xuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaCh2YWx1ZSwgZnVuY3Rpb24odmFsdWVPYmopIHtcblx0XHRcdFx0XHRcdHZhciBheGlzVHlwZSA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQodmFsdWVPYmoudHlwZSwga2V5ID09PSAneEF4ZXMnID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInKTtcblx0XHRcdFx0XHRcdGJhc2Vba2V5XS5wdXNoKGhlbHBlcnMuY29uZmlnTWVyZ2UoQ2hhcnQuc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoYXhpc1R5cGUpLCB2YWx1ZU9iaikpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGJhc2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgYmFzZVtrZXldID09PSAnb2JqZWN0JyAmJiBiYXNlW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyBJZiB3ZSBhcmUgb3ZlcndyaXRpbmcgYW4gb2JqZWN0IHdpdGggYW4gb2JqZWN0LCBkbyBhIG1lcmdlIG9mIHRoZSBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRiYXNlW2tleV0gPSBoZWxwZXJzLmNvbmZpZ01lcmdlKGJhc2Vba2V5XSwgdmFsdWUpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjYW4ganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlIGluIHRoaXMgY2FzZVxuXHRcdFx0XHRiYXNlW2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBiYXNlO1xuXHR9O1xuXHRoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiBpbmRleCA8IHZhbHVlLmxlbmd0aCA/IHZhbHVlW2luZGV4XSA6IGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cdGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQgPSBmdW5jdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcblx0fTtcblx0aGVscGVycy5pbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y/XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHtcblx0XHRcdHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pO1xuXHRcdH06XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0aGVscGVycy53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShjb2xsZWN0aW9uKSAmJiBBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoZmlsdGVyQ2FsbGJhY2spO1xuXHRcdH1cblx0XHR2YXIgZmlsdGVyZWQgPSBbXTtcblxuXHRcdGhlbHBlcnMuZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soaXRlbSkpIHtcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBmaWx0ZXJlZDtcblx0fTtcblx0aGVscGVycy5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4P1xuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2ssIHNjb3BlKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRzY29wZSA9IHNjb3BlID09PSB1bmRlZmluZWQ/IGFycmF5IDogc2NvcGU7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2suY2FsbChzY29wZSwgYXJyYXlbaV0sIGksIGFycmF5KSkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0aGVscGVycy5maW5kTmV4dFdoZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIHN0YXJ0IG9mIHRoZSBhcnJheVxuXHRcdGlmIChzdGFydEluZGV4ID09PSB1bmRlZmluZWQgfHwgc3RhcnRJbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0c3RhcnRJbmRleCA9IC0xO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0SW5kZXggPT09IG51bGwpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycy5pbmhlcml0cyA9IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHQvLyBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgQ2hhcnRFbGVtZW50ID0gKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkgPyBleHRlbnNpb25zLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0dmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IENoYXJ0RWxlbWVudDtcblx0XHR9O1xuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XG5cdFx0Q2hhcnRFbGVtZW50LnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblxuXHRcdENoYXJ0RWxlbWVudC5leHRlbmQgPSBoZWxwZXJzLmluaGVyaXRzO1xuXG5cdFx0aWYgKGV4dGVuc2lvbnMpIHtcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKENoYXJ0RWxlbWVudC5wcm90b3R5cGUsIGV4dGVuc2lvbnMpO1xuXHRcdH1cblxuXHRcdENoYXJ0RWxlbWVudC5fX3N1cGVyX18gPSBtZS5wcm90b3R5cGU7XG5cblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9O1xuXHRoZWxwZXJzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHRoZWxwZXJzLnVpZCA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpZCsrO1xuXHRcdH07XG5cdH0oKSk7XG5cdC8vIC0tIE1hdGggbWV0aG9kc1xuXHRoZWxwZXJzLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24oeCwgeSwgZXBzaWxvbikge1xuXHRcdHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xuXHR9O1xuXHRoZWxwZXJzLmFsbW9zdFdob2xlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuXHRcdHZhciByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcblx0XHRyZXR1cm4gKCgocm91bmRlZCAtIGVwc2lsb24pIDwgeCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPiB4KSk7XG5cdH07XG5cdGhlbHBlcnMubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycy5taW4gPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWluLCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWluKG1pbiwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1pbjtcblx0XHR9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXHR9O1xuXHRoZWxwZXJzLnNpZ24gPSBNYXRoLnNpZ24/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc2lnbih4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHR4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcblx0XHRcdGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHggPiAwID8gMSA6IC0xO1xuXHRcdH07XG5cdGhlbHBlcnMubG9nMTAgPSBNYXRoLmxvZzEwP1xuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZzEwKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcblx0XHR9O1xuXHRoZWxwZXJzLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcblx0fTtcblx0aGVscGVycy50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5cdGhlbHBlcnMuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueCxcblx0XHRcdGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55LFxuXHRcdFx0cmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuXHRcdGlmIChhbmdsZSA8ICgtMC41ICogTWF0aC5QSSkpIHtcblx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFuZ2xlOiBhbmdsZSxcblx0XHRcdGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcblx0fTtcblx0aGVscGVycy5hbGlhc1BpeGVsID0gZnVuY3Rpb24ocGl4ZWxXaWR0aCkge1xuXHRcdHJldHVybiAocGl4ZWxXaWR0aCAlIDIgPT09IDApID8gMCA6IDAuNTtcblx0fTtcblx0aGVscGVycy5zcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG5cdFx0Ly8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG5cdFx0dmFyIHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50LFxuXHRcdFx0Y3VycmVudCA9IG1pZGRsZVBvaW50LFxuXHRcdFx0bmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcblxuXHRcdHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudC54IC0gcHJldmlvdXMueCwgMikgKyBNYXRoLnBvdyhjdXJyZW50LnkgLSBwcmV2aW91cy55LCAyKSk7XG5cdFx0dmFyIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyhuZXh0LnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmV4dC55IC0gY3VycmVudC55LCAyKSk7XG5cblx0XHR2YXIgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG5cdFx0dmFyIHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG5cdFx0Ly8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuXHRcdHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuXHRcdHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG5cdFx0dmFyIGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG5cdFx0dmFyIGZiID0gdCAqIHMxMjtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRwcmV2aW91czoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH0sXG5cdFx0XHRuZXh0OiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGhlbHBlcnMuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXHRoZWxwZXJzLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzLmFsbW9zdEVxdWFscyhwb2ludEN1cnJlbnQuZGVsdGFLLCAwLCB0aGlzLkVQU0lMT04pKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QWZ0ZXIubUsgPSAwO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0YWxwaGFLID0gcG9pbnRDdXJyZW50Lm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdGJldGFLID0gcG9pbnRBZnRlci5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcblx0XHRcdGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuXHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gYWxwaGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRwb2ludEFmdGVyLm1LID0gYmV0YUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlIGNvbnRyb2wgcG9pbnRzXG5cdFx0dmFyIGRlbHRhWDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRCZWZvcmUgJiYgIXBvaW50QmVmb3JlLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50Q3VycmVudC5tb2RlbC54IC0gcG9pbnRCZWZvcmUubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggLSBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBwb2ludEN1cnJlbnQubW9kZWwueSAtIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IHBvaW50Q3VycmVudC5tb2RlbC54ICsgZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBwb2ludEN1cnJlbnQubW9kZWwueSArIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0fTtcblx0aGVscGVycy5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzLm5pY2VOdW0gPSBmdW5jdGlvbihyYW5nZSwgcm91bmQpIHtcblx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGhlbHBlcnMubG9nMTAocmFuZ2UpKTtcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcblxuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDUpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuaWNlRnJhY3Rpb24gKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHR9O1xuXHQvLyBFYXNpbmcgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBSb2JlcnQgUGVubmVyJ3MgZWFzaW5nIGVxdWF0aW9uc1xuXHQvLyBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuXHR2YXIgZWFzaW5nRWZmZWN0cyA9IGhlbHBlcnMuZWFzaW5nRWZmZWN0cyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH0sXG5cdFx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIHQgKiB0O1xuXHRcdH0sXG5cdFx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAtMSAqIHQgKiAodCAtIDIpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0IC89IDEgLyAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDEgLyAyICogdCAqIHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTEgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdFx0fSxcblx0XHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxICogKCh0ID0gdCAvIDEgLSAxKSAqIHQgKiB0ICsgMSk7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0IC89IDEgLyAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDEgLyAyICogdCAqIHQgKiB0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDEgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcblx0XHR9LFxuXHRcdGVhc2VJblF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0XHR9LFxuXHRcdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIC0xICogKCh0ID0gdCAvIDEgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCAvPSAxIC8gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAxIC8gMiAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTEgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMik7XG5cdFx0fSxcblx0XHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEgKiAodCAvPSAxKSAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fSxcblx0XHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxICogKCh0ID0gdCAvIDEgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMSAvIDIgKiB0ICogdCAqIHQgKiB0ICogdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAxIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcblx0XHR9LFxuXHRcdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAtMSAqIE1hdGguY29zKHQgLyAxICogKE1hdGguUEkgLyAyKSkgKyAxO1xuXHRcdH0sXG5cdFx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxICogTWF0aC5zaW4odCAvIDEgKiAoTWF0aC5QSSAvIDIpKTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAtMSAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyAxKSAtIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZUluRXhwbzogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICh0ID09PSAwKSA/IDEgOiAxICogTWF0aC5wb3coMiwgMTAgKiAodCAvIDEgLSAxKSk7XG5cdFx0fSxcblx0XHRlYXNlT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAxICogKC1NYXRoLnBvdygyLCAtMTAgKiB0IC8gMSkgKyAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMSAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDEgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdFx0fSxcblx0XHRlYXNlSW5DaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xICogKE1hdGguc3FydCgxIC0gKHQgLz0gMSkgKiB0KSAtIDEpO1xuXHRcdH0sXG5cdFx0ZWFzZU91dENpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyAxIC0gMSkgKiB0KTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCAvPSAxIC8gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtMSAvIDIgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAxIC8gMiAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHZhciBwID0gMDtcblx0XHRcdHZhciBhID0gMTtcblx0XHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCh0IC89IDEpID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFwKSB7XG5cdFx0XHRcdHAgPSAxICogMC4zO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGEgPCBNYXRoLmFicygxKSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHR9LFxuXHRcdGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHR2YXIgcCA9IDA7XG5cdFx0XHR2YXIgYSA9IDE7XG5cdFx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmICgodCAvPSAxKSA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghcCkge1xuXHRcdFx0XHRwID0gMSAqIDAuMztcblx0XHRcdH1cblx0XHRcdGlmIChhIDwgTWF0aC5hYnMoMSkpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiAxIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0dmFyIHAgPSAwO1xuXHRcdFx0dmFyIGEgPSAxO1xuXHRcdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKHQgLz0gMSAvIDIpID09PSAyKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFwKSB7XG5cdFx0XHRcdHAgPSAxICogKDAuMyAqIDEuNSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYSA8IE1hdGguYWJzKDEpKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHQgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiAxIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHRcdH0sXG5cdFx0ZWFzZUluQmFjazogZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIDEgKiAodCAvPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcblx0XHR9LFxuXHRcdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gMSAqICgodCA9IHQgLyAxIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdGlmICgodCAvPSAxIC8gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAxIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMSAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG5cdFx0fSxcblx0XHRlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiAxIC0gZWFzaW5nRWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0XHR9LFxuXHRcdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCAvPSAxKSA8ICgxIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDEgKiAoNy41NjI1ICogdCAqIHQpO1xuXHRcdFx0fSBlbHNlIGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gMSAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpO1xuXHRcdFx0fSBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiAxICogKDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMSAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpO1xuXHRcdH0sXG5cdFx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodCA8IDEgLyAyKSB7XG5cdFx0XHRcdHJldHVybiBlYXNpbmdFZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWFzaW5nRWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAxICogMC41O1xuXHRcdH1cblx0fTtcblx0Ly8gUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGwgLSBodHRwOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cblx0aGVscGVycy5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSgpKTtcblx0Ly8gLS0gRE9NIG1ldGhvZHNcblx0aGVscGVycy5nZXRSZWxhdGl2ZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0LCBjaGFydCkge1xuXHRcdHZhciBtb3VzZVgsIG1vdXNlWTtcblx0XHR2YXIgZSA9IGV2dC5vcmlnaW5hbEV2ZW50IHx8IGV2dCxcblx0XHRcdGNhbnZhcyA9IGV2dC5jdXJyZW50VGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50LFxuXHRcdFx0Ym91bmRpbmdSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0dmFyIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cdFx0aWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtb3VzZVggPSB0b3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bW91c2VYID0gZS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gZS5jbGllbnRZO1xuXHRcdH1cblxuXHRcdC8vIFNjYWxlIG1vdXNlIGNvb3JkaW5hdGVzIGludG8gY2FudmFzIGNvb3JkaW5hdGVzXG5cdFx0Ly8gYnkgZm9sbG93aW5nIHRoZSBwYXR0ZXJuIGxhaWQgb3V0IGJ5ICdqZXJyeWonIGluIHRoZSBjb21tZW50cyBvZlxuXHRcdC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1sZWZ0JykpO1xuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChoZWxwZXJzLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctdG9wJykpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycy5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWJvdHRvbScpKTtcblx0XHR2YXIgd2lkdGggPSBib3VuZGluZ1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBoZWlnaHQgPSBib3VuZGluZ1JlY3QuYm90dG9tIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuXG5cdFx0Ly8gV2UgZGl2aWRlIGJ5IHRoZSBjdXJyZW50IGRldmljZSBwaXhlbCByYXRpbywgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHNjYWxlZCB1cCBieSB0aGF0IGFtb3VudCBpbiBlYWNoIGRpcmVjdGlvbi4gSG93ZXZlclxuXHRcdC8vIHRoZSBiYWNrZW5kIG1vZGVsIGlzIGluIHVuc2NhbGVkIGNvb3JkaW5hdGVzLiBTaW5jZSB3ZSBhcmUgZ29pbmcgdG8gZGVhbCB3aXRoIG91ciBtb2RlbCBjb29yZGluYXRlcywgd2UgZ28gYmFjayBoZXJlXG5cdFx0bW91c2VYID0gTWF0aC5yb3VuZCgobW91c2VYIC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCkgLyAod2lkdGgpICogY2FudmFzLndpZHRoIC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXHRcdG1vdXNlWSA9IE1hdGgucm91bmQoKG1vdXNlWSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wKSAvIChoZWlnaHQpICogY2FudmFzLmhlaWdodCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBtb3VzZVgsXG5cdFx0XHR5OiBtb3VzZVlcblx0XHR9O1xuXG5cdH07XG5cdGhlbHBlcnMuYWRkRXZlbnQgPSBmdW5jdGlvbihub2RlLCBldmVudFR5cGUsIG1ldGhvZCkge1xuXHRcdGlmIChub2RlLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG1ldGhvZCk7XG5cdFx0fSBlbHNlIGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIG1ldGhvZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGVbJ29uJyArIGV2ZW50VHlwZV0gPSBtZXRob2Q7XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24obm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0aWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAobm9kZS5kZXRhY2hFdmVudCkge1xuXHRcdFx0bm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBoYW5kbGVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZVsnb24nICsgZXZlbnRUeXBlXSA9IGhlbHBlcnMubm9vcDtcblx0XHR9XG5cdH07XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuXHRmdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG5cdFx0dmFyIHZhbHVlSW5QaXhlbHM7XG5cdFx0aWYgKHR5cGVvZihzdHlsZVZhbHVlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cblx0XHRcdGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcblx0XHRcdFx0Ly8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY29udGFpbnMgYW4gZWZmZWN0aXZlIGNvbnN0cmFpbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0NvbnN0cmFpbmVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJ25vbmUnO1xuXHR9XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGEgY29uc3RyYWludCBkaW1lbnNpb25cblx0Ly8gQHBhcmFtIGRvbU5vZGUgOiB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxuXHQvLyBAcGFyYW0gbWF4U3R5bGUgOiB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAobWF4V2lkdGggLyBtYXhIZWlnaHQpXG5cdC8vIEBwYXJhbSBwZXJjZW50YWdlUHJvcGVydHkgOiBwcm9wZXJ0eSBvZiBwYXJlbnQgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgd2lkdGggYXMgYSBwZXJjZW50YWdlXG5cdC8vIEBzZWUgaHR0cDovL3d3dy5uYXRoYW5hZWxqb25lcy5jb20vYmxvZy8yMDEzL3JlYWRpbmctbWF4LXdpZHRoLWNyb3NzLWJyb3dzZXJcblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XG5cdFx0dmFyIHZpZXcgPSBkb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgY29uc3RyYWluZWRDb250YWluZXIgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBoYXNDTm9kZSA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZE5vZGUpO1xuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcblx0XHR2YXIgaW5maW5pdHkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIE1hdGgubWluKFxuXHRcdFx0XHRoYXNDTm9kZT8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZE5vZGUsIGRvbU5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSxcblx0XHRcdFx0aGFzQ0NvbnRhaW5lcj8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMuZ2V0Q29uc3RyYWludFdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtd2lkdGgnLCAnY2xpZW50V2lkdGgnKTtcblx0fTtcblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycy5nZXRDb25zdHJhaW50SGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xuXHR9O1xuXHRoZWxwZXJzLmdldE1heGltdW1XaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KGhlbHBlcnMuZ2V0U3R5bGUoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JyksIDEwKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoaGVscGVycy5nZXRTdHlsZShjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JyksIDEwKTtcblx0XHR2YXIgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBjdyA9IGhlbHBlcnMuZ2V0Q29uc3RyYWludFdpZHRoKGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjdyk/IHcgOiBNYXRoLm1pbih3LCBjdyk7XG5cdH07XG5cdGhlbHBlcnMuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VJbnQoaGVscGVycy5nZXRTdHlsZShjb250YWluZXIsICdwYWRkaW5nLXRvcCcpLCAxMCk7XG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUludChoZWxwZXJzLmdldFN0eWxlKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJyksIDEwKTtcblx0XHR2YXIgaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblx0XHR2YXIgY2ggPSBoZWxwZXJzLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGNoKT8gaCA6IE1hdGgubWluKGgsIGNoKTtcblx0fTtcblx0aGVscGVycy5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycy5yZXRpbmFTY2FsZSA9IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0aWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2hhcnQud2lkdGg7XG5cblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuXHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0fTtcblx0Ly8gLS0gQ2FudmFzIG1ldGhvZHNcblx0aGVscGVycy5jbGVhciA9IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fTtcblx0aGVscGVycy5mb250U3RyaW5nID0gZnVuY3Rpb24ocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXHR9O1xuXHRoZWxwZXJzLmxvbmdlc3RUZXh0ID0gZnVuY3Rpb24oY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuXHRcdGNhY2hlID0gY2FjaGUgfHwge307XG5cdFx0dmFyIGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcblx0XHR2YXIgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuXG5cdFx0aWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcblx0XHRcdGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG5cdFx0XHRnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG5cdFx0XHRjYWNoZS5mb250ID0gZm9udDtcblx0XHR9XG5cblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0dmFyIGxvbmdlc3QgPSAwO1xuXHRcdGhlbHBlcnMuZWFjaChhcnJheU9mVGhpbmdzLCBmdW5jdGlvbih0aGluZykge1xuXHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBoZWxwZXJzLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycy5pc0FycmF5KHRoaW5nKSkge1xuXHRcdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG5cdFx0XHRcdC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cblx0XHRcdFx0aGVscGVycy5lYWNoKHRoaW5nLCBmdW5jdGlvbihuZXN0ZWRUaGluZykge1xuXHRcdFx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzLmlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG5cdFx0XHRcdFx0XHRsb25nZXN0ID0gaGVscGVycy5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG5cdFx0aWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuXHRcdFx0XHRkZWxldGUgZGF0YVtnY1tpXV07XG5cdFx0XHR9XG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycy5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG5cdFx0aWYgKCF0ZXh0V2lkdGgpIHtcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMubnVtYmVyT2ZMYWJlbExpbmVzID0gZnVuY3Rpb24oYXJyYXlPZlRoaW5ncykge1xuXHRcdHZhciBudW1iZXJPZkxpbmVzID0gMTtcblx0XHRoZWxwZXJzLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdGlmIChoZWxwZXJzLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXHRoZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0fTtcblxuXHRoZWxwZXJzLmNvbG9yID0gIWNvbG9yP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBDaGFydC5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheT9cblx0XHRmdW5jdGlvbihvYmopIHtcblx0XHRcdHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdFx0fTtcblx0Ly8gISBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XG5cdGhlbHBlcnMuYXJyYXlFcXVhbHMgPSBmdW5jdGlvbihhMCwgYTEpIHtcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xuXG5cdFx0aWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuPWEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0aGVscGVycy5jYWxsYmFjayA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG5cdFx0aWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHR9XG5cdH07XG5cdGhlbHBlcnMuZ2V0SG92ZXJDb2xvciA9IGZ1bmN0aW9uKGNvbG9yVmFsdWUpIHtcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xuXHRcdHJldHVybiAoY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm4pID9cblx0XHRcdGNvbG9yVmFsdWUgOlxuXHRcdFx0aGVscGVycy5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMjY2FsbGJhY2sgaW5zdGVhZC5cblx0ICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMjY2FsbENhbGxiYWNrXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0aGVscGVycy5jYWxsQ2FsbGJhY2sgPSBoZWxwZXJzLmNhbGxiYWNrO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydFxuXHQgKiBAcmV0dXJucyB7UG9pbnR9IHRoZSBldmVudCBwb3NpdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuXHRcdGlmIChlLm5hdGl2ZSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogZS54LFxuXHRcdFx0XHR5OiBlLnlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhlbHBlcnMuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIHRyYXZlcnNlIGFsbCBvZiB0aGUgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgY2hhcnRcblx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSBoYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2pdO1xuXHRcdFx0XHRpZiAoIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBpdGVtcyB7Q2hhcnRFbGVtZW50W119IGVsZW1lbnRzIHRvIGZpbHRlclxuXHQgKiBAcGFyYW0gcG9zaXRpb24ge1BvaW50fSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuXHQgKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcblx0ICovXG5cdGZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikge1xuXHRcdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBlbGVtZW50cztcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0ZWggY2hhcnRcblx0ICogQHBhcmFtIGNoYXJ0IHtDaGFydH0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuXHQgKiBAcGFyYW0gcG9zaXRpb24ge1BvaW50fSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuXHQgKiBAcGFyYW0gaW50ZXJzZWN0IHtCb29sZWFufSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuXHQgKiBAcGFyYW0gZGlzdGFuY2VNZXRyaWMge0Z1bmN0aW9ufSBPcHRpb25hbCBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG5cdCAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0XHRpZiAoIWRpc3RhbmNlTWV0cmljKSB7XG5cdFx0XHRkaXN0YW5jZU1ldHJpYyA9IGhlbHBlcnMuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzO1xuXHRcdH1cblxuXHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG5cblx0XHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdG5lYXJlc3RJdGVtcyA9IFtlbGVtZW50XTtcblx0XHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG5cdFx0XHRcdG5lYXJlc3RJdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG5lYXJlc3RJdGVtcztcblx0fVxuXG5cdGZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMocHQxLnggLSBwdDIueCk7XG5cdFx0fTtcblx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHRcdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdFx0aWYgKCFpdGVtcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSxcblx0XHRcdFx0XHRlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XG5cblx0XHRcdFx0Ly8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuXHRcdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbnRlcmZhY2UgSUludGVyYWN0aW9uT3B0aW9uc1xuXHQgKi9cblx0LyoqXG5cdCAqIElmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvaW50XG5cdCAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cblx0ICogQHR5cGUgQm9vbGVhblxuXHQgKi9cblxuXHQvKipcblx0ICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcblx0ICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuXHQgKi9cblx0Q2hhcnQuSW50ZXJhY3Rpb24gPSB7XG5cdFx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcblx0XHRtb2Rlczoge1xuXHRcdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdFx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0XHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzLnNsaWNlKDAsIDEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcblx0XHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcblx0IFx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdFx0XHRsYWJlbDogaW5kZXhNb2RlLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0XHQgKiBAcGFyYW0gb3B0aW9ucyB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0XHQgKi9cblx0XHRcdGluZGV4OiBpbmRleE1vZGUsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0ICovXG5cdFx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdFx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UpO1xuXG5cdFx0XHRcdGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0aXRlbXMgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5fZGF0YXNldEluZGV4KS5kYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXG5cdFx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcblx0XHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0XHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0XHQgKiBAcGFyYW0gY2hhcnQge2NoYXJ0fSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0XHQgKiBAcGFyYW0gZSB7RXZlbnR9IHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHRcdCAqL1xuXHRcdFx0cG9pbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0XHRyZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlXG5cdFx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0XHQgKi9cblx0XHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0XHR2YXIgbmVhcmVzdEl0ZW1zID0gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgb3B0aW9ucy5pbnRlcnNlY3QpO1xuXG5cdFx0XHRcdC8vIFdlIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSB0aGUgZXZlbnQuIE5vdyBzb3J0IGJ5IHNtYWxsZXN0XG5cdFx0XHRcdGlmIChuZWFyZXN0SXRlbXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdG5lYXJlc3RJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRcdHZhciBzaXplQSA9IGEuZ2V0QXJlYSgpO1xuXHRcdFx0XHRcdFx0dmFyIHNpemVCID0gYi5nZXRBcmVhKCk7XG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gc2l6ZUEgLSBzaXplQjtcblxuXHRcdFx0XHRcdFx0aWYgKHJldCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBpZiBlcXVhbCBzb3J0IGJ5IGRhdGFzZXQgaW5kZXhcblx0XHRcdFx0XHRcdFx0cmV0ID0gYS5fZGF0YXNldEluZGV4IC0gYi5fZGF0YXNldEluZGV4O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG9ubHkgMSBpdGVtXG5cdFx0XHRcdHJldHVybiBuZWFyZXN0SXRlbXMuc2xpY2UoMCwgMSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHRcdCAqIEBwYXJhbSBjaGFydCB7Y2hhcnR9IHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHRcdCAqIEBwYXJhbSBlIHtFdmVudH0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdFx0ICogQHBhcmFtIG9wdGlvbnMge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgdG8gdXNlXG5cdFx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0XHQgKi9cblx0XHRcdHg6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xuXHRcdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpdGVtcztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdFx0ICogQHBhcmFtIGNoYXJ0IHtjaGFydH0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdFx0ICogQHBhcmFtIGUge0V2ZW50fSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0XHQgKiBAcGFyYW0gb3B0aW9ucyB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyB0byB1c2Vcblx0XHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHRcdCAqL1xuXHRcdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRcdGlmIChlbGVtZW50LmluWVJhbmdlKHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gT2NjdXB5IHRoZSBnbG9iYWwgdmFyaWFibGUgb2YgQ2hhcnQsIGFuZCBjcmVhdGUgYSBzaW1wbGUgYmFzZSBjbGFzc1xuXHR2YXIgQ2hhcnQgPSBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHR0aGlzLmNvbnN0cnVjdChpdGVtLCBjb25maWcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vIEdsb2JhbGx5IGV4cG9zZSB0aGUgZGVmYXVsdHMgdG8gYWxsb3cgZm9yIHVzZXIgdXBkYXRpbmcvY2hhbmdpbmdcblx0Q2hhcnQuZGVmYXVsdHMgPSB7XG5cdFx0Z2xvYmFsOiB7XG5cdFx0XHRyZXNwb25zaXZlOiB0cnVlLFxuXHRcdFx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwLFxuXHRcdFx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0XHRcdGV2ZW50czogWydtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXSxcblx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0XHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRcdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdFx0XHRhbmltYXRpb25EdXJhdGlvbjogNDAwXG5cdFx0XHR9LFxuXHRcdFx0b25DbGljazogbnVsbCxcblx0XHRcdGRlZmF1bHRDb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXG5cdFx0XHRkZWZhdWx0Rm9udENvbG9yOiAnIzY2NicsXG5cdFx0XHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRcdFx0ZGVmYXVsdEZvbnRTaXplOiAxMixcblx0XHRcdGRlZmF1bHRGb250U3R5bGU6ICdub3JtYWwnLFxuXHRcdFx0c2hvd0xpbmVzOiB0cnVlLFxuXG5cdFx0XHQvLyBFbGVtZW50IGRlZmF1bHRzIGRlZmluZWQgaW4gZWxlbWVudCBleHRlbnNpb25zXG5cdFx0XHRlbGVtZW50czoge30sXG5cblx0XHRcdC8vIExlZ2VuZCBjYWxsYmFjayBzdHJpbmdcblx0XHRcdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdFx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3IgKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRcdGlmIChjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmxhYmVsKSB7XG5cdFx0XHRcdFx0XHR0ZXh0LnB1c2goY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cblx0XHRcdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYXJ0LkNoYXJ0ID0gQ2hhcnQ7XG5cblx0cmV0dXJuIENoYXJ0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHRmdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuXHRcdHJldHVybiBoZWxwZXJzLndoZXJlKGFycmF5LCBmdW5jdGlvbih2KSB7XG5cdFx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0XHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcblx0XHRcdHYuX3RtcEluZGV4XyA9IGk7XG5cdFx0XHRyZXR1cm4gdjtcblx0XHR9KTtcblx0XHRhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcblx0XHRcdHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG5cdFx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdFx0djAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuXHRcdH0pO1xuXHRcdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdFx0ZGVsZXRlIHYuX3RtcEluZGV4Xztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG5cdCAqIEBwcm9wIHtTdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcblx0ICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuXHQgKiBAcHJvcCB7TnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG5cdCAqIEBwcm9wIHtCb29sZWFufSBmdWxsV2lkdGggLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cblx0ICogQHByb3Age0Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuXHQgKiBAcHJvcCB7RnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuXHQgKiBAcHJvcCB7RnVuY3Rpb259IGdldFBhZGRpbmcgLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuXHQgKiBAcHJvcCB7TnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcblx0ICogQHByb3Age051bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcblx0ICogQHByb3Age051bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuXHQgKiBAcHJvcCB7TnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuXHQgKiBAcHJvcCB7TnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICogQHByb3Age051bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcblx0ICovXG5cblx0Ly8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG5cdC8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuXHQvLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5cdENoYXJ0LmxheW91dFNlcnZpY2UgPSB7XG5cdFx0ZGVmYXVsdHM6IHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0XHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdFx0ICovXG5cdFx0YWRkQm94OiBmdW5jdGlvbihjaGFydCwgaXRlbSkge1xuXHRcdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdFx0aXRlbS5mdWxsV2lkdGggPSBpdGVtLmZ1bGxXaWR0aCB8fCBmYWxzZTtcblx0XHRcdGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuXHRcdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0XHQgKi9cblx0XHRyZW1vdmVCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBjaGFydC5ib3hlcz8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdFx0ICovXG5cdFx0Y29uZmlndXJlOiBmdW5jdGlvbihjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHByb3BzID0gWydmdWxsV2lkdGgnLCAncG9zaXRpb24nLCAnd2VpZ2h0J107XG5cdFx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRmb3IgKDsgaTxpbGVuOyArK2kpIHtcblx0XHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRcdGl0ZW1bcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdFx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0aWYgKCFjaGFydCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYXlvdXRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5sYXlvdXQ7XG5cdFx0XHR2YXIgcGFkZGluZyA9IGxheW91dE9wdGlvbnMgPyBsYXlvdXRPcHRpb25zLnBhZGRpbmcgOiBudWxsO1xuXG5cdFx0XHR2YXIgbGVmdFBhZGRpbmcgPSAwO1xuXHRcdFx0dmFyIHJpZ2h0UGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgdG9wUGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgYm90dG9tUGFkZGluZyA9IDA7XG5cblx0XHRcdGlmICghaXNOYU4ocGFkZGluZykpIHtcblx0XHRcdFx0Ly8gb3B0aW9ucy5sYXlvdXQucGFkZGluZyBpcyBhIG51bWJlci4gYXNzaWduIHRvIGFsbFxuXHRcdFx0XHRsZWZ0UGFkZGluZyA9IHBhZGRpbmc7XG5cdFx0XHRcdHJpZ2h0UGFkZGluZyA9IHBhZGRpbmc7XG5cdFx0XHRcdHRvcFBhZGRpbmcgPSBwYWRkaW5nO1xuXHRcdFx0XHRib3R0b21QYWRkaW5nID0gcGFkZGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxlZnRQYWRkaW5nID0gcGFkZGluZy5sZWZ0IHx8IDA7XG5cdFx0XHRcdHJpZ2h0UGFkZGluZyA9IHBhZGRpbmcucmlnaHQgfHwgMDtcblx0XHRcdFx0dG9wUGFkZGluZyA9IHBhZGRpbmcudG9wIHx8IDA7XG5cdFx0XHRcdGJvdHRvbVBhZGRpbmcgPSBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHRcdHZhciByaWdodEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3JpZ2h0Jyk7XG5cdFx0XHR2YXIgdG9wQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAndG9wJyk7XG5cdFx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0XHR2YXIgY2hhcnRBcmVhQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnY2hhcnRBcmVhJyk7XG5cblx0XHRcdC8vIFNvcnQgYm94ZXMgYnkgd2VpZ2h0LiBBIGhpZ2hlciB3ZWlnaHQgaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcblx0XHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdFx0c29ydEJ5V2VpZ2h0KHJpZ2h0Qm94ZXMsIGZhbHNlKTtcblx0XHRcdHNvcnRCeVdlaWdodCh0b3BCb3hlcywgdHJ1ZSk7XG5cdFx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdFx0Ly8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuXHRcdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuXHRcdFx0Ly8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG5cdFx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuXHRcdFx0Ly8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0XHQvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcblx0XHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcblx0XHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHRcdC8vXG5cdFx0XHQvLyBXaGF0IHdlIGRvIHRvIGZpbmQgdGhlIGJlc3Qgc2l6aW5nLCB3ZSBkbyB0aGUgZm9sbG93aW5nXG5cdFx0XHQvLyAxLiBEZXRlcm1pbmUgdGhlIG1pbmltdW0gc2l6ZSBvZiB0aGUgY2hhcnQgYXJlYS5cblx0XHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdFx0Ly8gMy4gU3BsaXQgdGhlIHJlbWFpbmluZyBoZWlnaHQgZXF1YWxseSBiZXR3ZWVuIGVhY2ggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHQvLyA0LiBHaXZlIGVhY2ggbGF5b3V0IHRoZSBtYXhpbXVtIHNpemUgaXQgY2FuIGJlLiBUaGUgbGF5b3V0IHdpbGwgcmV0dXJuIGl0J3MgbWluaW11bSBzaXplXG5cdFx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHRcdC8vIDYuIFJlZml0IGVhY2ggYXhpc1xuXHRcdFx0Ly8gNy4gUG9zaXRpb24gZWFjaCBheGlzIGluIHRoZSBmaW5hbCBsb2NhdGlvblxuXHRcdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0XHQvLyA5LiBUZWxsIGFueSBheGVzIHRoYXQgb3ZlcmxheSB0aGUgY2hhcnQgYXJlYSB0aGUgcG9zaXRpb25zIG9mIHRoZSBjaGFydCBhcmVhXG5cblx0XHRcdC8vIFN0ZXAgMVxuXHRcdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdFx0dmFyIGNoYXJ0SGVpZ2h0ID0gaGVpZ2h0IC0gdG9wUGFkZGluZyAtIGJvdHRvbVBhZGRpbmc7XG5cdFx0XHR2YXIgY2hhcnRBcmVhV2lkdGggPSBjaGFydFdpZHRoIC8gMjsgLy8gbWluIDUwJVxuXHRcdFx0dmFyIGNoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0IC8gMjsgLy8gbWluIDUwJVxuXG5cdFx0XHQvLyBTdGVwIDJcblx0XHRcdHZhciB2ZXJ0aWNhbEJveFdpZHRoID0gKHdpZHRoIC0gY2hhcnRBcmVhV2lkdGgpIC8gKGxlZnRCb3hlcy5sZW5ndGggKyByaWdodEJveGVzLmxlbmd0aCk7XG5cblx0XHRcdC8vIFN0ZXAgM1xuXHRcdFx0dmFyIGhvcml6b250YWxCb3hIZWlnaHQgPSAoaGVpZ2h0IC0gY2hhcnRBcmVhSGVpZ2h0KSAvICh0b3BCb3hlcy5sZW5ndGggKyBib3R0b21Cb3hlcy5sZW5ndGgpO1xuXG5cdFx0XHQvLyBTdGVwIDRcblx0XHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0XHR2YXIgbWF4Q2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnRIZWlnaHQ7XG5cdFx0XHR2YXIgbWluQm94U2l6ZXMgPSBbXTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0TWluaW11bUJveFNpemUoYm94KSB7XG5cdFx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gYm94LmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBob3Jpem9udGFsQm94SGVpZ2h0KTtcblx0XHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWluU2l6ZSA9IGJveC51cGRhdGUodmVydGljYWxCb3hXaWR0aCwgY2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWluQm94U2l6ZXMucHVzaCh7XG5cdFx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHRcdG1pblNpemU6IG1pblNpemUsXG5cdFx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzLCB0b3BCb3hlcywgYm90dG9tQm94ZXMpLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHRcdC8vIElmIGEgaG9yaXpvbnRhbCBib3ggaGFzIHBhZGRpbmcsIHdlIG1vdmUgdGhlIGxlZnQgYm94ZXMgb3ZlciB0byBhdm9pZCB1Z2x5IGNoYXJ0cyAoc2VlIGlzc3VlICMyNDc4KVxuXHRcdFx0dmFyIG1heEhvcml6b250YWxMZWZ0UGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgbWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgbWF4VmVydGljYWxUb3BQYWRkaW5nID0gMDtcblx0XHRcdHZhciBtYXhWZXJ0aWNhbEJvdHRvbVBhZGRpbmcgPSAwO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKSwgZnVuY3Rpb24oaG9yaXpvbnRhbEJveCkge1xuXHRcdFx0XHRpZiAoaG9yaXpvbnRhbEJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHRcdFx0dmFyIGJveFBhZGRpbmcgPSBob3Jpem9udGFsQm94LmdldFBhZGRpbmcoKTtcblx0XHRcdFx0XHRtYXhIb3Jpem9udGFsTGVmdFBhZGRpbmcgPSBNYXRoLm1heChtYXhIb3Jpem9udGFsTGVmdFBhZGRpbmcsIGJveFBhZGRpbmcubGVmdCk7XG5cdFx0XHRcdFx0bWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyA9IE1hdGgubWF4KG1heEhvcml6b250YWxSaWdodFBhZGRpbmcsIGJveFBhZGRpbmcucmlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKGxlZnRCb3hlcy5jb25jYXQocmlnaHRCb3hlcyksIGZ1bmN0aW9uKHZlcnRpY2FsQm94KSB7XG5cdFx0XHRcdGlmICh2ZXJ0aWNhbEJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHRcdFx0dmFyIGJveFBhZGRpbmcgPSB2ZXJ0aWNhbEJveC5nZXRQYWRkaW5nKCk7XG5cdFx0XHRcdFx0bWF4VmVydGljYWxUb3BQYWRkaW5nID0gTWF0aC5tYXgobWF4VmVydGljYWxUb3BQYWRkaW5nLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRcdFx0bWF4VmVydGljYWxCb3R0b21QYWRkaW5nID0gTWF0aC5tYXgobWF4VmVydGljYWxCb3R0b21QYWRkaW5nLCBib3hQYWRkaW5nLmJvdHRvbSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdFx0Ly8gYmUgaWYgdGhlIGF4ZXMgYXJlIGRyYXduIGF0IHRoZWlyIG1pbmltdW0gc2l6ZXMuXG5cdFx0XHQvLyBTdGVwcyA1ICYgNlxuXHRcdFx0dmFyIHRvdGFsTGVmdEJveGVzV2lkdGggPSBsZWZ0UGFkZGluZztcblx0XHRcdHZhciB0b3RhbFJpZ2h0Qm94ZXNXaWR0aCA9IHJpZ2h0UGFkZGluZztcblx0XHRcdHZhciB0b3RhbFRvcEJveGVzSGVpZ2h0ID0gdG9wUGFkZGluZztcblx0XHRcdHZhciB0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ID0gYm90dG9tUGFkZGluZztcblxuXHRcdFx0Ly8gRnVuY3Rpb24gdG8gZml0IGEgYm94XG5cdFx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycy5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWluQm94LmJveCA9PT0gYm94O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0XHRcdHZhciBzY2FsZU1hcmdpbiA9IHtcblx0XHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgodG90YWxMZWZ0Qm94ZXNXaWR0aCwgbWF4SG9yaXpvbnRhbExlZnRQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KHRvdGFsUmlnaHRCb3hlc1dpZHRoLCBtYXhIb3Jpem9udGFsUmlnaHRQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0XHRib3R0b206IDBcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHRcdC8vIG9uIHRoZSBtYXJnaW4uIFNvbWV0aW1lcyB0aGV5IG5lZWQgdG8gaW5jcmVhc2UgaW4gc2l6ZSBzbGlnaHRseVxuXHRcdFx0XHRcdFx0Ym94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIsIHNjYWxlTWFyZ2luKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLm1pblNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRcdGhlbHBlcnMuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMpLCBmaXRCb3gpO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLmNvbmNhdChib3R0b21Cb3hlcyksIGZpdEJveCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgaG93IG11Y2ggbWFyZ2luIGlzIG9uIHRoZSB0b3AgYW5kIGJvdHRvbSBvZiB0aGUgdmVydGljYWwgYm94ZXNcblx0XHRcdGhlbHBlcnMuZWFjaCh0b3BCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdHRvdGFsVG9wQm94ZXNIZWlnaHQgKz0gYm94LmhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IGJveC5oZWlnaHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWluU2l6ZS5ib3ggPT09IGJveDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdFx0dG9wOiB0b3RhbFRvcEJveGVzSGVpZ2h0LFxuXHRcdFx0XHRcdGJvdHRvbTogdG90YWxCb3R0b21Cb3hlc0hlaWdodFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLm1pblNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExldCB0aGUgbGVmdCBsYXlvdXQga25vdyB0aGUgZmluYWwgbWFyZ2luXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKSwgZmluYWxGaXRWZXJ0aWNhbEJveCk7XG5cblx0XHRcdC8vIFJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHNpemUgb2YgZWFjaCBsYXlvdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNsaWdodGx5IGR1ZSB0byB0aGUgbWFyZ2lucyAobGFiZWwgcm90YXRpb24gZm9yIGluc3RhbmNlKVxuXHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCA9IGxlZnRQYWRkaW5nO1xuXHRcdFx0dG90YWxSaWdodEJveGVzV2lkdGggPSByaWdodFBhZGRpbmc7XG5cdFx0XHR0b3RhbFRvcEJveGVzSGVpZ2h0ID0gdG9wUGFkZGluZztcblx0XHRcdHRvdGFsQm90dG9tQm94ZXNIZWlnaHQgPSBib3R0b21QYWRkaW5nO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbFJpZ2h0Qm94ZXNXaWR0aCArPSBib3gud2lkdGg7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKHRvcEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0dG90YWxUb3BCb3hlc0hlaWdodCArPSBib3guaGVpZ2h0O1xuXHRcdFx0fSk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IGJveC5oZWlnaHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0XHR2YXIgbGVmdFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heEhvcml6b250YWxMZWZ0UGFkZGluZyAtIHRvdGFsTGVmdEJveGVzV2lkdGgsIDApO1xuXHRcdFx0dG90YWxMZWZ0Qm94ZXNXaWR0aCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdFx0dG90YWxSaWdodEJveGVzV2lkdGggKz0gTWF0aC5tYXgobWF4SG9yaXpvbnRhbFJpZ2h0UGFkZGluZyAtIHRvdGFsUmlnaHRCb3hlc1dpZHRoLCAwKTtcblxuXHRcdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFZlcnRpY2FsVG9wUGFkZGluZyAtIHRvdGFsVG9wQm94ZXNIZWlnaHQsIDApO1xuXHRcdFx0dG90YWxUb3BCb3hlc0hlaWdodCArPSB0b3BQYWRkaW5nQWRkaXRpb247XG5cdFx0XHR0b3RhbEJvdHRvbUJveGVzSGVpZ2h0ICs9IE1hdGgubWF4KG1heFZlcnRpY2FsQm90dG9tUGFkZGluZyAtIHRvdGFsQm90dG9tQm94ZXNIZWlnaHQsIDApO1xuXG5cdFx0XHQvLyBGaWd1cmUgb3V0IGlmIG91ciBjaGFydCBhcmVhIGNoYW5nZWQuIFRoaXMgd291bGQgb2NjdXIgaWYgdGhlIGRhdGFzZXQgbGF5b3V0IGxhYmVsIHJvdGF0aW9uXG5cdFx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHRcdC8vIHdpdGhvdXQgY2FsbGluZyBgZml0YCBhZ2FpblxuXHRcdFx0dmFyIG5ld01heENoYXJ0QXJlYUhlaWdodCA9IGhlaWdodCAtIHRvdGFsVG9wQm94ZXNIZWlnaHQgLSB0b3RhbEJvdHRvbUJveGVzSGVpZ2h0O1xuXHRcdFx0dmFyIG5ld01heENoYXJ0QXJlYVdpZHRoID0gd2lkdGggLSB0b3RhbExlZnRCb3hlc1dpZHRoIC0gdG90YWxSaWdodEJveGVzV2lkdGg7XG5cblx0XHRcdGlmIChuZXdNYXhDaGFydEFyZWFXaWR0aCAhPT0gbWF4Q2hhcnRBcmVhV2lkdGggfHwgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ICE9PSBtYXhDaGFydEFyZWFIZWlnaHQpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGxlZnRCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKHJpZ2h0Qm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRcdGJveC5oZWlnaHQgPSBuZXdNYXhDaGFydEFyZWFIZWlnaHQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaCh0b3BCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChib3R0b21Cb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdFx0bWF4Q2hhcnRBcmVhV2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0XHR2YXIgbGVmdCA9IGxlZnRQYWRkaW5nICsgbGVmdFBhZGRpbmdBZGRpdGlvbjtcblx0XHRcdHZhciB0b3AgPSB0b3BQYWRkaW5nICsgdG9wUGFkZGluZ0FkZGl0aW9uO1xuXG5cdFx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdFx0aWYgKGJveC5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdGJveC5sZWZ0ID0gYm94LmZ1bGxXaWR0aCA/IGxlZnRQYWRkaW5nIDogdG90YWxMZWZ0Qm94ZXNXaWR0aDtcblx0XHRcdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gd2lkdGggLSByaWdodFBhZGRpbmcgOiB0b3RhbExlZnRCb3hlc1dpZHRoICsgbWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0XHRcdFx0Ym94LnRvcCA9IHRvcDtcblx0XHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdHRvcCA9IGJveC5ib3R0b207XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJveC5sZWZ0ID0gbGVmdDtcblx0XHRcdFx0XHRib3gucmlnaHQgPSBsZWZ0ICsgYm94LndpZHRoO1xuXHRcdFx0XHRcdGJveC50b3AgPSB0b3RhbFRvcEJveGVzSGVpZ2h0O1xuXHRcdFx0XHRcdGJveC5ib3R0b20gPSB0b3RhbFRvcEJveGVzSGVpZ2h0ICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0bGVmdCA9IGJveC5yaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzLmVhY2gobGVmdEJveGVzLmNvbmNhdCh0b3BCb3hlcyksIHBsYWNlQm94KTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgY2hhcnQgd2lkdGggYW5kIGhlaWdodFxuXHRcdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdHRvcCArPSBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChyaWdodEJveGVzLCBwbGFjZUJveCk7XG5cdFx0XHRoZWxwZXJzLmVhY2goYm90dG9tQm94ZXMsIHBsYWNlQm94KTtcblxuXHRcdFx0Ly8gU3RlcCA4XG5cdFx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRcdGxlZnQ6IHRvdGFsTGVmdEJveGVzV2lkdGgsXG5cdFx0XHRcdHRvcDogdG90YWxUb3BCb3hlc0hlaWdodCxcblx0XHRcdFx0cmlnaHQ6IHRvdGFsTGVmdEJveGVzV2lkdGggKyBtYXhDaGFydEFyZWFXaWR0aCxcblx0XHRcdFx0Ym90dG9tOiB0b3RhbFRvcEJveGVzSGVpZ2h0ICsgbWF4Q2hhcnRBcmVhSGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTdGVwIDlcblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGJveC5sZWZ0ID0gY2hhcnQuY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRcdGJveC50b3AgPSBjaGFydC5jaGFydEFyZWEudG9wO1xuXHRcdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdGJveC5ib3R0b20gPSBjaGFydC5jaGFydEFyZWEuYm90dG9tO1xuXG5cdFx0XHRcdGJveC51cGRhdGUobWF4Q2hhcnRBcmVhV2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXG5cdENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5wbHVnaW5zID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSBwbHVnaW4gc2VydmljZSBzaW5nbGV0b25cblx0ICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5zXG5cdCAqIEBzaW5jZSAyLjEuMFxuXHQgKi9cblx0Q2hhcnQucGx1Z2lucyA9IHtcblx0XHQvKipcblx0XHQgKiBHbG9iYWxseSByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfcGx1Z2luczogW10sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdFx0ICogd2hlbiBhIGdsb2JhbCBwbHVnaW4gaXMgcmVnaXN0ZXJlZCBvciB1bnJlZ2lzdGVyZWQuIEluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIElEIGlzXG5cdFx0ICogaW5jcmVtZW50ZWQgYW5kIGRlc2NyaXB0b3JzIGFyZSByZWdlbmVyYXRlZCBkdXJpbmcgZm9sbG93aW5nIEFQSSBjYWxscy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9jYWNoZUlkOiAwLFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdFx0ICovXG5cdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRwLnB1c2gocGx1Z2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2NhY2hlSWQrKztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXG5cdFx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHRcdCAqL1xuXHRcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0XHRwLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0XHQgKiBAc2luY2UgMi4xLjVcblx0XHQgKi9cblx0XHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiByZWdpc3RlcmVkIHBsdWdpbnM/XG5cdFx0ICogQHJldHVybnMge051bWJlcn1cblx0XHQgKiBAc2luY2UgMi4xLjVcblx0XHQgKi9cblx0XHRjb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHBsdWdpbiBvYmplY3RzLlxuXHRcdCAqIEBzaW5jZSAyLjEuNVxuXHRcdCAqL1xuXHRcdGdldEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0XHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0XHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHRcdCAqL1xuXHRcdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcblx0XHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xuXHRcdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcblxuXHRcdFx0Zm9yIChpPTA7IGk8aWxlbjsgKytpKSB7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcblx0XHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG5cdFx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcblx0XHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9IFt7IHBsdWdpbiwgb3B0aW9ucyB9XVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0ZGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBjaGFydC5fcGx1Z2lucyB8fCAoY2hhcnQuX3BsdWdpbnMgPSB7fSk7XG5cdFx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XG5cdFx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSBDaGFydC5kZWZhdWx0cy5nbG9iYWwucGx1Z2lucztcblx0XHRcdHZhciBvcHRpb25zID0gKGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMpIHx8IHt9O1xuXG5cdFx0XHR0aGlzLl9wbHVnaW5zLmNvbmNhdChjb25maWcucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpZCA9IHBsdWdpbi5pZDtcblx0XHRcdFx0dmFyIG9wdHMgPSBvcHRpb25zW2lkXTtcblx0XHRcdFx0aWYgKG9wdHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRvcHRzID0gaGVscGVycy5jbG9uZShkZWZhdWx0c1tpZF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goe1xuXHRcdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxuXHRcdFx0XHRcdG9wdGlvbnM6IG9wdHMgfHwge31cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2FjaGUuZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcblx0XHRcdGNhY2hlLmlkID0gdGhpcy5fY2FjaGVJZDtcblx0XHRcdHJldHVybiBkZXNjcmlwdG9ycztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBsdWdpbiBleHRlbnNpb24gaG9va3MuXG5cdCAqIEBpbnRlcmZhY2UgSVBsdWdpblxuXHQgKiBAc2luY2UgMi4xLjBcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlSW5pdFxuXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyBgY2hhcnRgLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJJbml0XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciBgY2hhcnRgIGhhcyBiZWVuIGluaXRpYWxpemVkIGFuZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZS5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZVVwZGF0ZVxuXHQgKiBAZGVzYyBDYWxsZWQgYmVmb3JlIHVwZGF0aW5nIGBjaGFydGAuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLCB0aGUgdXBkYXRlXG5cdCAqIGlzIGNhbmNlbGxlZCAoYW5kIHRodXMgc3Vic2VxdWVudCByZW5kZXIocykpIHVudGlsIGFub3RoZXIgYHVwZGF0ZWAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCB1cGRhdGUuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyVXBkYXRlXG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciBgY2hhcnRgIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIGJlZm9yZSByZW5kZXJpbmcuIE5vdGUgdGhhdCB0aGlzXG5cdCAqIGhvb2sgd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBjaGFydCB1cGRhdGUgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVEYXRhc2V0c1VwZGF0ZVxuIFx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSB1cGRhdGluZyB0aGUgYGNoYXJ0YCBkYXRhc2V0cy4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXG5cdCAqIHRoZSBkYXRhc2V0cyB1cGRhdGUgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHVwZGF0ZWAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGZhbHNlIHRvIGNhbmNlbCB0aGUgZGF0YXNldHMgdXBkYXRlLlxuXHQgKiBAc2luY2UgdmVyc2lvbiAyLjEuNVxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckRhdGFzZXRzVXBkYXRlXG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBkYXRhc2V0cyBoYXZlIGJlZW4gdXBkYXRlZC4gTm90ZSB0aGF0IHRoaXMgaG9va1xuXHQgKiB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGRhdGFzZXRzIHVwZGF0ZSBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEBzaW5jZSB2ZXJzaW9uIDIuMS41XG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZURhdGFzZXRVcGRhdGVcbiBcdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGBjaGFydGAgZGF0YXNldCBhdCB0aGUgZ2l2ZW4gYGFyZ3MuaW5kZXhgLiBJZiBhbnkgcGx1Z2luXG5cdCAqIHJldHVybnMgYGZhbHNlYCwgdGhlIGRhdGFzZXRzIHVwZGF0ZSBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgdXBkYXRlYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBjYWxsIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuaW5kZXggLSBUaGUgZGF0YXNldCBpbmRleC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubWV0YSAtIFRoZSBkYXRhc2V0IG1ldGFkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCBkYXRhc2V0cyBkcmF3aW5nLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckRhdGFzZXRVcGRhdGVcbiBcdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBkYXRhc2V0cyBhdCB0aGUgZ2l2ZW4gYGFyZ3MuaW5kZXhgIGhhcyBiZWVuIHVwZGF0ZWQuIE5vdGVcblx0ICogdGhhdCB0aGlzIGhvb2sgd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBkYXRhc2V0cyB1cGRhdGUgaGFzIGJlZW4gcHJldmlvdXNseSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBjYWxsIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuaW5kZXggLSBUaGUgZGF0YXNldCBpbmRleC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubWV0YSAtIFRoZSBkYXRhc2V0IG1ldGFkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlTGF5b3V0XG5cdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgbGF5aW5nIG91dCBgY2hhcnRgLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCxcblx0ICogdGhlIGxheW91dCB1cGRhdGUgaXMgY2FuY2VsbGVkIHVudGlsIGFub3RoZXIgYHVwZGF0ZWAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCBsYXlvdXQuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyTGF5b3V0XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGNoYXJ0YCBoYXMgYmVlbiBsYXllZCBvdXQuIE5vdGUgdGhhdCB0aGlzIGhvb2sgd2lsbCBub3Rcblx0ICogYmUgY2FsbGVkIGlmIHRoZSBsYXlvdXQgdXBkYXRlIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlUmVuZGVyXG5cdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGBjaGFydGAuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxuXHQgKiB0aGUgcmVuZGVyaW5nIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGByZW5kZXJgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgcmVuZGVyaW5nLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclJlbmRlclxuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgaGFzIGJlZW4gZnVsbHkgcmVuZGVyZWQgKGFuZCBhbmltYXRpb24gY29tcGxldGVkKS4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgaG9vayB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIHJlbmRlcmluZyBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2JlZm9yZURyYXdcblx0ICogQGRlc2MgQ2FsbGVkIGJlZm9yZSBkcmF3aW5nIGBjaGFydGAgYXQgZXZlcnkgYW5pbWF0aW9uIGZyYW1lIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW5cblx0ICogZWFzaW5nIHZhbHVlLiBJZiBhbnkgcGx1Z2luIHJldHVybnMgYGZhbHNlYCwgdGhlIGZyYW1lIGRyYXdpbmcgaXMgY2FuY2VsbGVkIHVudGlsXG5cdCAqIGFub3RoZXIgYHJlbmRlcmAgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCB0byBjYW5jZWwgdGhlIGNoYXJ0IGRyYXdpbmcuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyRHJhd1xuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgaGFzIGJlZW4gZHJhd24gZm9yIHRoZSBzcGVjaWZpYyBlYXNpbmcgdmFsdWUuIE5vdGVcblx0ICogdGhhdCB0aGlzIGhvb2sgd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBkcmF3aW5nIGhhcyBiZWVuIHByZXZpb3VzbHkgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkNvbnRyb2xsZXJ9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZWFzaW5nVmFsdWUgLSBUaGUgY3VycmVudCBhbmltYXRpb24gdmFsdWUsIGJldHdlZW4gMC4wIGFuZCAxLjAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNiZWZvcmVEYXRhc2V0c0RyYXdcbiBcdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgZHJhd2luZyB0aGUgYGNoYXJ0YCBkYXRhc2V0cy4gSWYgYW55IHBsdWdpbiByZXR1cm5zIGBmYWxzZWAsXG5cdCAqIHRoZSBkYXRhc2V0cyBkcmF3aW5nIGlzIGNhbmNlbGxlZCB1bnRpbCBhbm90aGVyIGByZW5kZXJgIGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgdG8gY2FuY2VsIHRoZSBjaGFydCBkYXRhc2V0cyBkcmF3aW5nLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckRhdGFzZXRzRHJhd1xuXHQgKiBAZGVzYyBDYWxsZWQgYWZ0ZXIgdGhlIGBjaGFydGAgZGF0YXNldHMgaGF2ZSBiZWVuIGRyYXduLiBOb3RlIHRoYXQgdGhpcyBob29rXG5cdCAqIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZGF0YXNldHMgZHJhd2luZyBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRGF0YXNldERyYXdcbiBcdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgZHJhd2luZyB0aGUgYGNoYXJ0YCBkYXRhc2V0IGF0IHRoZSBnaXZlbiBgYXJncy5pbmRleGAgKGRhdGFzZXRzXG5cdCAqIGFyZSBkcmF3biBpbiB0aGUgcmV2ZXJzZSBvcmRlcikuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLCB0aGUgZGF0YXNldHMgZHJhd2luZ1xuXHQgKiBpcyBjYW5jZWxsZWQgdW50aWwgYW5vdGhlciBgcmVuZGVyYCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBjYWxsIGFyZ3VtZW50cy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuaW5kZXggLSBUaGUgZGF0YXNldCBpbmRleC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFyZ3MubWV0YSAtIFRoZSBkYXRhc2V0IG1ldGFkYXRhLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5lYXNpbmdWYWx1ZSAtIFRoZSBjdXJyZW50IGFuaW1hdGlvbiB2YWx1ZSwgYmV0d2VlbiAwLjAgYW5kIDEuMC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgY2hhcnQgZGF0YXNldHMgZHJhd2luZy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJEYXRhc2V0RHJhd1xuIFx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBgY2hhcnRgIGRhdGFzZXRzIGF0IHRoZSBnaXZlbiBgYXJncy5pbmRleGAgaGF2ZSBiZWVuIGRyYXduXG5cdCAqIChkYXRhc2V0cyBhcmUgZHJhd24gaW4gdGhlIHJldmVyc2Ugb3JkZXIpLiBOb3RlIHRoYXQgdGhpcyBob29rIHdpbGwgbm90IGJlIGNhbGxlZFxuXHQgKiBpZiB0aGUgZGF0YXNldHMgZHJhd2luZyBoYXMgYmVlbiBwcmV2aW91c2x5IGNhbmNlbGxlZC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gVGhlIGNhbGwgYXJndW1lbnRzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncy5pbmRleCAtIFRoZSBkYXRhc2V0IGluZGV4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYXJncy5tZXRhIC0gVGhlIGRhdGFzZXQgbWV0YWRhdGEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhcmdzLmVhc2luZ1ZhbHVlIC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHZhbHVlLCBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbHVnaW4gb3B0aW9ucy5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIElQbHVnaW4jYmVmb3JlRXZlbnRcbiBcdCAqIEBkZXNjIENhbGxlZCBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgc3BlY2lmaWVkIGBldmVudGAuIElmIGFueSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgLFxuXHQgKiB0aGUgZXZlbnQgd2lsbCBiZSBkaXNjYXJkZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlckV2ZW50XG5cdCAqIEBkZXNjIENhbGxlZCBhZnRlciB0aGUgYGV2ZW50YCBoYXMgYmVlbiBjb25zdW1lZC4gTm90ZSB0aGF0IHRoaXMgaG9va1xuXHQgKiB3aWxsIG5vdCBiZSBjYWxsZWQgaWYgdGhlIGBldmVudGAgaGFzIGJlZW4gcHJldmlvdXNseSBkaXNjYXJkZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBsdWdpbiBvcHRpb25zLlxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgSVBsdWdpbiNyZXNpemVcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBjaGFydCBhcyBiZWVuIHJlc2l6ZWQuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQ29udHJvbGxlcn0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIG5ldyBjYW52YXMgZGlzcGxheSBzaXplIChlcS4gY2FudmFzLnN0eWxlIHdpZHRoICYgaGVpZ2h0KS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBJUGx1Z2luI2Rlc3Ryb3lcblx0ICogQGRlc2MgQ2FsbGVkIGFmdGVyIHRoZSBjaGFydCBhcyBiZWVuIGRlc3Ryb3llZC5cblx0ICogQHBhcmFtIHtDaGFydC5Db250cm9sbGVyfSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGx1Z2luIG9wdGlvbnMuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpblNlcnZpY2Vcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRDaGFydC5wbHVnaW5TZXJ2aWNlID0gQ2hhcnQucGx1Z2lucztcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluaGVyaXRpbmcgZnJvbSBDaGFydC5QbHVnaW5nQmFzZSBoYXMgbm9cblx0ICogZWZmZWN0LCBpbnN0ZWFkIHNpbXBseSBjcmVhdGUvcmVnaXN0ZXIgcGx1Z2lucyB2aWEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuXHQgKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2Vcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRDaGFydC5QbHVnaW5CYXNlID0gQ2hhcnQuRWxlbWVudC5leHRlbmQoe30pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHRDaGFydC5kZWZhdWx0cy5zY2FsZSA9IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0XHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxuXHRcdFx0ZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuXHRcdFx0ZHJhd1RpY2tzOiB0cnVlLFxuXHRcdFx0dGlja01hcmtMZW5ndGg6IDEwLFxuXHRcdFx0emVyb0xpbmVXaWR0aDogMSxcblx0XHRcdHplcm9MaW5lQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMjUpJyxcblx0XHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXG5cdFx0XHR6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRcdG9mZnNldEdyaWRMaW5lczogZmFsc2UsXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHRcdH0sXG5cblx0XHQvLyBzY2FsZSBsYWJlbFxuXHRcdHNjYWxlTGFiZWw6IHtcblx0XHRcdC8vIGFjdHVhbCBsYWJlbFxuXHRcdFx0bGFiZWxTdHJpbmc6ICcnLFxuXG5cdFx0XHQvLyBkaXNwbGF5IHByb3BlcnR5XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cblx0XHQvLyBsYWJlbCBzZXR0aW5nc1xuXHRcdHRpY2tzOiB7XG5cdFx0XHRiZWdpbkF0WmVybzogZmFsc2UsXG5cdFx0XHRtaW5Sb3RhdGlvbjogMCxcblx0XHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRcdG1pcnJvcjogZmFsc2UsXG5cdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdFx0YXV0b1NraXA6IHRydWUsXG5cdFx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0XHRsYWJlbE9mZnNldDogMCxcblx0XHRcdC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuXHRcdFx0Y2FsbGJhY2s6IENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbXB1dGVUZXh0U2l6ZShjb250ZXh0LCB0aWNrLCBmb250KSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMuaXNBcnJheSh0aWNrKSA/XG5cdFx0XHRoZWxwZXJzLmxvbmdlc3RUZXh0KGNvbnRleHQsIGZvbnQsIHRpY2spIDpcblx0XHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHR2YXIgZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IENoYXJ0LmRlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgc2l6ZSA9IGdldFZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0dmFyIHN0eWxlID0gZ2V0VmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdHZhciBmYW1pbHkgPSBnZXRWYWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0c3R5bGU6IHN0eWxlLFxuXHRcdFx0ZmFtaWx5OiBmYW1pbHksXG5cdFx0XHRmb250OiBoZWxwZXJzLmZvbnRTdHJpbmcoc2l6ZSwgc3R5bGUsIGZhbWlseSlcblx0XHR9O1xuXHR9XG5cblx0Q2hhcnQuU2NhbGUgPSBDaGFydC5FbGVtZW50LmV4dGVuZCh7XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdFx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJucyB7UGFkZGluZ30gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdFx0ICovXG5cdFx0Z2V0UGFkZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bGVmdDogbWUucGFkZGluZ0xlZnQgfHwgMCxcblx0XHRcdFx0dG9wOiBtZS5wYWRkaW5nVG9wIHx8IDAsXG5cdFx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcblx0XHRcdFx0Ym90dG9tOiBtZS5wYWRkaW5nQm90dG9tIHx8IDBcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0XHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG5cdFx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdFx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0XHRtZS5tYXJnaW5zID0gaGVscGVycy5leHRlbmQoe1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRib3R0b206IDBcblx0XHRcdH0sIG1hcmdpbnMpO1xuXHRcdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHRcdC8vIERpbWVuc2lvbnNcblx0XHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0XHQvLyBEYXRhIG1pbi9tYXhcblx0XHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcblx0XHRcdG1lLmFmdGVyRGF0YUxpbWl0cygpO1xuXG5cdFx0XHQvLyBUaWNrc1xuXHRcdFx0bWUuYmVmb3JlQnVpbGRUaWNrcygpO1xuXHRcdFx0bWUuYnVpbGRUaWNrcygpO1xuXHRcdFx0bWUuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cblx0XHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXHRcdFx0bWUuY29udmVydFRpY2tzVG9MYWJlbHMoKTtcblx0XHRcdG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHRcdC8vIFRpY2sgUm90YXRpb25cblx0XHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdFx0Ly8gRml0XG5cdFx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRcdG1lLmZpdCgpO1xuXHRcdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHRcdC8vXG5cdFx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblxuXHRcdH0sXG5cdFx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUudG9wID0gMDtcblx0XHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0XHR9LFxuXHRcdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vIERhdGEgbGltaXRzXG5cdFx0YmVmb3JlRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycy5ub29wLFxuXHRcdGFmdGVyRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckRhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cdFx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVCdWlsZFRpY2tzLCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0YnVpbGRUaWNrczogaGVscGVycy5ub29wLFxuXHRcdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRoZWxwZXJzLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdFx0fSxcblx0XHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gQ29udmVydCB0aWNrcyB0byBzdHJpbmdzXG5cdFx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAodGlja09wdHMudXNlckNhbGxiYWNrIHx8IHRpY2tPcHRzLmNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHRcdH0sXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0XHR9LFxuXHRcdGNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXG5cdFx0XHQvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBieSBjYWxjdWxhdGluZyB0aGUgZGlmZmVyZW5jZVxuXHRcdFx0Ly8gYmV0d2VlbiB4IG9mZnNldHMgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250T3B0aW9ucyh0aWNrT3B0cyk7XG5cdFx0XHRjb250ZXh0LmZvbnQgPSB0aWNrRm9udC5mb250O1xuXG5cdFx0XHR2YXIgbGFiZWxSb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLmRpc3BsYXkgJiYgbWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dmFyIG9yaWdpbmFsTGFiZWxXaWR0aCA9IGhlbHBlcnMubG9uZ2VzdFRleHQoY29udGV4dCwgdGlja0ZvbnQuZm9udCwgbWUudGlja3MsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IG9yaWdpbmFsTGFiZWxXaWR0aDtcblx0XHRcdFx0dmFyIGNvc1JvdGF0aW9uO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb247XG5cblx0XHRcdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcblx0XHRcdFx0dmFyIHRpY2tXaWR0aCA9IG1lLmdldFBpeGVsRm9yVGljaygxKSAtIG1lLmdldFBpeGVsRm9yVGljaygwKSAtIDY7XG5cblx0XHRcdFx0Ly8gTWF4IGxhYmVsIHJvdGF0aW9uIGNhbiBiZSBzZXQgb3IgZGVmYXVsdCB0byA5MCAtIGFsc28gYWN0IGFzIGEgbG9vcCBjb3VudGVyXG5cdFx0XHRcdHdoaWxlIChsYWJlbFdpZHRoID4gdGlja1dpZHRoICYmIGxhYmVsUm90YXRpb24gPCB0aWNrT3B0cy5tYXhSb3RhdGlvbikge1xuXHRcdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzLnRvUmFkaWFucyhsYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0XHRjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdFx0c2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdFx0aWYgKHNpblJvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoID4gbWUubWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHQvLyBnbyBiYWNrIG9uZSBzdGVwXG5cdFx0XHRcdFx0XHRsYWJlbFJvdGF0aW9uLS07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYWJlbFJvdGF0aW9uKys7XG5cdFx0XHRcdFx0bGFiZWxXaWR0aCA9IGNvc1JvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG1lLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuXHRcdH0sXG5cdFx0YWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24sIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuXHRcdH0sXG5cdFx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHQvLyBSZXNldFxuXHRcdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge1xuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxPcHRzID0gb3B0cy5zY2FsZUxhYmVsO1xuXHRcdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udE9wdGlvbnModGlja09wdHMpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxGb250U2l6ZSA9IHBhcnNlRm9udE9wdGlvbnMoc2NhbGVMYWJlbE9wdHMpLnNpemUgKiAxLjU7XG5cdFx0XHR2YXIgdGlja01hcmtMZW5ndGggPSBvcHRzLmdyaWRMaW5lcy50aWNrTWFya0xlbmd0aDtcblxuXHRcdFx0Ly8gV2lkdGhcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0Ly8gc3VidHJhY3QgdGhlIG1hcmdpbnMgdG8gbGluZSB1cCB3aXRoIHRoZSBjaGFydEFyZWEgaWYgd2UgYXJlIGEgZnVsbCB3aWR0aCBzY2FsZVxuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1heFdpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodCA6IG1lLm1heFdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgJiYgZ3JpZExpbmVPcHRzLmRyYXdUaWNrcyA/IHRpY2tNYXJrTGVuZ3RoIDogMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGVpZ2h0XG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXJlIHdlIHNob3dpbmcgYSB0aXRsZSBmb3IgdGhlIHNjYWxlP1xuXHRcdFx0aWYgKHNjYWxlTGFiZWxPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gc2NhbGVMYWJlbEZvbnRTaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1pblNpemUud2lkdGggKz0gc2NhbGVMYWJlbEZvbnRTaXplO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlbVxuXHRcdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0XHR2YXIgbGFyZ2VzdFRleHRXaWR0aCA9IGhlbHBlcnMubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5mb250LCBtZS50aWNrcywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHRcdHZhciB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzID0gaGVscGVycy5udW1iZXJPZkxhYmVsTGluZXMobWUudGlja3MpO1xuXHRcdFx0XHR2YXIgbGluZVNwYWNlID0gdGlja0ZvbnQuc2l6ZSAqIDAuNTtcblxuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0Ly8gQSBob3Jpem9udGFsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgaGVpZ2h0LlxuXHRcdFx0XHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gbGFyZ2VzdFRleHRXaWR0aDtcblxuXHRcdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0XHQvLyBUT0RPIC0gaW1wcm92ZSB0aGlzIGNhbGN1bGF0aW9uXG5cdFx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHRcdCsgKHRpY2tGb250LnNpemUgKiB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzKVxuXHRcdFx0XHRcdFx0KyAobGluZVNwYWNlICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyk7XG5cblx0XHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKG1lLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCk7XG5cdFx0XHRcdFx0bWUuY3R4LmZvbnQgPSB0aWNrRm9udC5mb250O1xuXG5cdFx0XHRcdFx0dmFyIGZpcnN0VGljayA9IG1lLnRpY2tzWzBdO1xuXHRcdFx0XHRcdHZhciBmaXJzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBmaXJzdFRpY2ssIHRpY2tGb250LmZvbnQpO1xuXG5cdFx0XHRcdFx0dmFyIGxhc3RUaWNrID0gbWUudGlja3NbbWUudGlja3MubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0dmFyIGxhc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFzdFRpY2ssIHRpY2tGb250LmZvbnQpO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWQgd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWRcblx0XHRcdFx0XHQvLyBieSB0aGUgZm9udCBoZWlnaHRcblx0XHRcdFx0XHRpZiAobWUubGFiZWxSb3RhdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBvcHRzLnBvc2l0aW9uID09PSAnYm90dG9tJz8gKGNvc1JvdGF0aW9uICogZmlyc3RMYWJlbFdpZHRoKSArIDM6IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSkgKyAzOyAvLyBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IG9wdHMucG9zaXRpb24gPT09ICdib3R0b20nPyAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpICsgMzogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpICsgMztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsV2lkdGggLyAyICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDIgKyAzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3Rcblx0XHRcdFx0XHQvLyBBY2NvdW50IGZvciBwYWRkaW5nXG5cblx0XHRcdFx0XHRpZiAodGlja09wdHMubWlycm9yKSB7XG5cdFx0XHRcdFx0XHRsYXJnZXN0VGV4dFdpZHRoID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCArPSBtZS5vcHRpb25zLnRpY2tzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXHRcdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gdGlja0ZvbnQuc2l6ZSAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bWUuaGFuZGxlTWFyZ2lucygpO1xuXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRpZiAobWUubWFyZ2lucykge1xuXHRcdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0IC0gbWUubWFyZ2lucy5sZWZ0LCAwKTtcblx0XHRcdFx0bWUucGFkZGluZ1RvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AgLSBtZS5tYXJnaW5zLnRvcCwgMCk7XG5cdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KG1lLnBhZGRpbmdSaWdodCAtIG1lLm1hcmdpbnMucmlnaHQsIDApO1xuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSAtIG1lLm1hcmdpbnMuYm90dG9tLCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YWZ0ZXJGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aGVscGVycy5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG5cdFx0fSxcblxuXHRcdC8vIFNoYXJlZCBNZXRob2RzXG5cdFx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdFx0fSxcblx0XHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5mdWxsV2lkdGgpO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3Rcblx0XHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdFx0Ly8gTnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmaXJzdFxuXHRcdFx0aWYgKHJhd1ZhbHVlID09PSBudWxsIHx8IHR5cGVvZihyYXdWYWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9XG5cdFx0XHQvLyBpc05hTihvYmplY3QpIHJldHVybnMgdHJ1ZSwgc28gbWFrZSBzdXJlIE5hTiBpcyBjaGVja2luZyBmb3IgYSBudW1iZXI7IERpc2NhcmQgSW5maW5pdGUgdmFsdWVzXG5cdFx0XHRpZiAodHlwZW9mKHJhd1ZhbHVlKSA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTmFOO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRcdGlmICh0eXBlb2YocmF3VmFsdWUpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoKHJhd1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgfHwgKHJhd1ZhbHVlLmlzVmFsaWQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJhd1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5pc0hvcml6b250YWwoKSA/IHJhd1ZhbHVlLnggOiByYXdWYWx1ZS55KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVmFsdWUgaXMgZ29vZCwgcmV0dXJuIGl0XG5cdFx0XHRyZXR1cm4gcmF3VmFsdWU7XG5cdFx0fSxcblxuXHRcdC8vIFVzZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0XHQvLyBmdW5jdGlvbiBnZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycy5ub29wLFxuXG5cdFx0Ly8gVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzLm5vb3AsXG5cblx0XHQvLyBVc2VkIGZvciB0aWNrIGxvY2F0aW9uLCBzaG91bGRcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4LCBpbmNsdWRlT2Zmc2V0KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS50aWNrcy5sZW5ndGggLSAoKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykgPyAwIDogMSkpLCAxKTtcblx0XHRcdFx0dmFyIHBpeGVsID0gKHRpY2tXaWR0aCAqIGluZGV4KSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRcdGlmIChpbmNsdWRlT2Zmc2V0KSB7XG5cdFx0XHRcdFx0cGl4ZWwgKz0gdGlja1dpZHRoIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBNYXRoLnJvdW5kKHBpeGVsKTtcblx0XHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHRcdH1cblx0XHRcdHZhciBpbm5lckhlaWdodCA9IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUucGFkZGluZ0JvdHRvbSk7XG5cdFx0XHRyZXR1cm4gbWUudG9wICsgKGluZGV4ICogKGlubmVySGVpZ2h0IC8gKG1lLnRpY2tzLmxlbmd0aCAtIDEpKSk7XG5cdFx0fSxcblxuXHRcdC8vIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHRcdGdldFBpeGVsRm9yRGVjaW1hbDogZnVuY3Rpb24oZGVjaW1hbCAvKiAsIGluY2x1ZGVPZmZzZXQqLykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdFx0dmFyIHZhbHVlT2Zmc2V0ID0gKGlubmVyV2lkdGggKiBkZWNpbWFsKSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBNYXRoLnJvdW5kKHZhbHVlT2Zmc2V0KTtcblx0XHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZS50b3AgKyAoZGVjaW1hbCAqIG1lLmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuXHRcdH0sXG5cblx0XHRnZXRCYXNlVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0XHRyZXR1cm4gbWUuYmVnaW5BdFplcm8gPyAwOlxuXHRcdFx0XHRtaW4gPCAwICYmIG1heCA8IDA/IG1heCA6XG5cdFx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMD8gbWluIDpcblx0XHRcdFx0MDtcblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgc2NhbGUgb24gdGhlIGNhbnZhc1xuXHRcdC8vIEBwYXJhbSB7cmVjdGFuZ2xlfSBjaGFydEFyZWEgOiB0aGUgYXJlYSBvZiB0aGUgY2hhcnQgdG8gZHJhdyBmdWxsIGdyaWQgbGluZXMgb25cblx0XHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0XHRpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcztcblx0XHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcblx0XHRcdHZhciBzY2FsZUxhYmVsID0gb3B0aW9ucy5zY2FsZUxhYmVsO1xuXG5cdFx0XHR2YXIgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcblx0XHRcdHZhciBza2lwUmF0aW87XG5cdFx0XHR2YXIgdXNlQXV0b3NraXBwZXIgPSBvcHRpb25UaWNrcy5hdXRvU2tpcDtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0Ly8gZmlndXJlIG91dCB0aGUgbWF4aW11bSBudW1iZXIgb2YgZ3JpZGxpbmVzIHRvIHNob3dcblx0XHRcdHZhciBtYXhUaWNrcztcblx0XHRcdGlmIChvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0KSB7XG5cdFx0XHRcdG1heFRpY2tzID0gb3B0aW9uVGlja3MubWF4VGlja3NMaW1pdDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRpY2tGb250Q29sb3IgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KG9wdGlvblRpY2tzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKG9wdGlvblRpY2tzKTtcblxuXHRcdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdChzY2FsZUxhYmVsLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnRPcHRpb25zKHNjYWxlTGFiZWwpO1xuXG5cdFx0XHR2YXIgbGFiZWxSb3RhdGlvblJhZGlhbnMgPSBoZWxwZXJzLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblx0XHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGxhYmVsUm90YXRpb25SYWRpYW5zKTtcblx0XHRcdHZhciBsb25nZXN0Um90YXRlZExhYmVsID0gbWUubG9uZ2VzdExhYmVsV2lkdGggKiBjb3NSb3RhdGlvbjtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRyYXcgdGV4dCBpbiB0aGUgY29ycmVjdCBjb2xvciBhbmQgZm9udFxuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xuXG5cdFx0XHR2YXIgaXRlbXNUb0RyYXcgPSBbXTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRza2lwUmF0aW8gPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoKGxvbmdlc3RSb3RhdGVkTGFiZWwgKyBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcpICogbWUudGlja3MubGVuZ3RoID4gKG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KSkpIHtcblx0XHRcdFx0XHRza2lwUmF0aW8gPSAxICsgTWF0aC5mbG9vcigoKGxvbmdlc3RSb3RhdGVkTGFiZWwgKyBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcpICogbWUudGlja3MubGVuZ3RoKSAvIChtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCkpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoZXkgZGVmaW5lZCBhIG1heCBudW1iZXIgb2Ygb3B0aW9uVGlja3MsXG5cdFx0XHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRcdFx0aWYgKG1heFRpY2tzICYmIG1lLnRpY2tzLmxlbmd0aCA+IG1heFRpY2tzKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCFza2lwUmF0aW8gfHwgbWUudGlja3MubGVuZ3RoIC8gKHNraXBSYXRpbyB8fCAxKSA+IG1heFRpY2tzKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNraXBSYXRpbykge1xuXHRcdFx0XHRcdFx0XHRza2lwUmF0aW8gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcFJhdGlvICs9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF1c2VBdXRvc2tpcHBlcikge1xuXHRcdFx0XHRcdHNraXBSYXRpbyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0dmFyIHhUaWNrU3RhcnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnID8gbWUubGVmdCA6IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR2YXIgeFRpY2tFbmQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnID8gbWUubGVmdCArIHRsIDogbWUucmlnaHQ7XG5cdFx0XHR2YXIgeVRpY2tTdGFydCA9IG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nID8gbWUudG9wIDogbWUuYm90dG9tIC0gdGw7XG5cdFx0XHR2YXIgeVRpY2tFbmQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IG1lLnRvcCArIHRsIDogbWUuYm90dG9tO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuXHRcdFx0XHQvLyBJZiB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgYSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZSwgZG8gbm90IGRyYXcgdGhpcyBsaW5lXG5cdFx0XHRcdGlmIChsYWJlbCA9PT0gdW5kZWZpbmVkIHx8IGxhYmVsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGlzTGFzdFRpY2sgPSBtZS50aWNrcy5sZW5ndGggPT09IGluZGV4ICsgMTtcblxuXHRcdFx0XHQvLyBTaW5jZSB3ZSBhbHdheXMgc2hvdyB0aGUgbGFzdCB0aWNrLHdlIG5lZWQgbWF5IG5lZWQgdG8gaGlkZSB0aGUgbGFzdCBzaG93biBvbmUgYmVmb3JlXG5cdFx0XHRcdHZhciBzaG91bGRTa2lwID0gKHNraXBSYXRpbyA+IDEgJiYgaW5kZXggJSBza2lwUmF0aW8gPiAwKSB8fCAoaW5kZXggJSBza2lwUmF0aW8gPT09IDAgJiYgaW5kZXggKyBza2lwUmF0aW8gPj0gbWUudGlja3MubGVuZ3RoKTtcblx0XHRcdFx0aWYgKHNob3VsZFNraXAgJiYgIWlzTGFzdFRpY2sgfHwgKGxhYmVsID09PSB1bmRlZmluZWQgfHwgbGFiZWwgPT09IG51bGwpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0XHRpZiAoaW5kZXggPT09ICh0eXBlb2YgbWUuemVyb0xpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgPyBtZS56ZXJvTGluZUluZGV4IDogMCkpIHtcblx0XHRcdFx0XHQvLyBEcmF3IHRoZSBmaXJzdCBpbmRleCBzcGVjaWFsbHlcblx0XHRcdFx0XHRsaW5lV2lkdGggPSBncmlkTGluZXMuemVyb0xpbmVXaWR0aDtcblx0XHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaDtcblx0XHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaW5lV2lkdGggPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCBpbmRleCk7XG5cdFx0XHRcdFx0Ym9yZGVyRGFzaCA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQoZ3JpZExpbmVzLmJvcmRlckRhc2gsIGdsb2JhbERlZmF1bHRzLmJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KGdyaWRMaW5lcy5ib3JkZXJEYXNoT2Zmc2V0LCBnbG9iYWxEZWZhdWx0cy5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbW1vbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdHZhciB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyLCBsYWJlbFgsIGxhYmVsWTtcblx0XHRcdFx0dmFyIHRleHRBbGlnbiA9ICdtaWRkbGUnO1xuXHRcdFx0XHR2YXIgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRcdFx0XHQvLyBib3R0b21cblx0XHRcdFx0XHRcdHRleHRCYXNlbGluZSA9ICFpc1JvdGF0ZWQ/ICd0b3AnOidtaWRkbGUnO1xuXHRcdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZD8gJ2NlbnRlcic6ICdyaWdodCc7XG5cdFx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyB0bDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdG9wXG5cdFx0XHRcdFx0XHR0ZXh0QmFzZWxpbmUgPSAhaXNSb3RhdGVkPyAnYm90dG9tJzonbWlkZGxlJztcblx0XHRcdFx0XHRcdHRleHRBbGlnbiA9ICFpc1JvdGF0ZWQ/ICdjZW50ZXInOiAnbGVmdCc7XG5cdFx0XHRcdFx0XHRsYWJlbFkgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgeExpbmVWYWx1ZSA9IG1lLmdldFBpeGVsRm9yVGljayhpbmRleCkgKyBoZWxwZXJzLmFsaWFzUGl4ZWwobGluZVdpZHRoKTsgLy8geHZhbHVlcyBmb3IgZ3JpZCBsaW5lc1xuXHRcdFx0XHRcdGxhYmVsWCA9IG1lLmdldFBpeGVsRm9yVGljayhpbmRleCwgZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDsgLy8geCB2YWx1ZXMgZm9yIG9wdGlvblRpY2tzIChuZWVkIHRvIGNvbnNpZGVyIG9mZnNldExhYmVsIG9wdGlvbilcblxuXHRcdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSB4TGluZVZhbHVlO1xuXHRcdFx0XHRcdHR5MSA9IHlUaWNrU3RhcnQ7XG5cdFx0XHRcdFx0dHkyID0geVRpY2tFbmQ7XG5cdFx0XHRcdFx0eTEgPSBjaGFydEFyZWEudG9wO1xuXHRcdFx0XHRcdHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaXNMZWZ0ID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuXHRcdFx0XHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XG5cdFx0XHRcdFx0dmFyIGxhYmVsWE9mZnNldDtcblxuXHRcdFx0XHRcdGlmIChvcHRpb25UaWNrcy5taXJyb3IpIHtcblx0XHRcdFx0XHRcdHRleHRBbGlnbiA9IGlzTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0XHRsYWJlbFhPZmZzZXQgPSB0aWNrUGFkZGluZztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGV4dEFsaWduID0gaXNMZWZ0ID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRcdGxhYmVsWE9mZnNldCA9IHRsICsgdGlja1BhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFiZWxYID0gaXNMZWZ0ID8gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQgOiBtZS5sZWZ0ICsgbGFiZWxYT2Zmc2V0O1xuXG5cdFx0XHRcdFx0dmFyIHlMaW5lVmFsdWUgPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpOyAvLyB4dmFsdWVzIGZvciBncmlkIGxpbmVzXG5cdFx0XHRcdFx0eUxpbmVWYWx1ZSArPSBoZWxwZXJzLmFsaWFzUGl4ZWwobGluZVdpZHRoKTtcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpO1xuXG5cdFx0XHRcdFx0dHgxID0geFRpY2tTdGFydDtcblx0XHRcdFx0XHR0eDIgPSB4VGlja0VuZDtcblx0XHRcdFx0XHR4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0XHRcdHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuXHRcdFx0XHRcdHR5MSA9IHR5MiA9IHkxID0geTIgPSB5TGluZVZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aXRlbXNUb0RyYXcucHVzaCh7XG5cdFx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdFx0dHkxOiB0eTEsXG5cdFx0XHRcdFx0dHgyOiB0eDIsXG5cdFx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdFx0eDE6IHgxLFxuXHRcdFx0XHRcdHkxOiB5MSxcblx0XHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdFx0eTI6IHkyLFxuXHRcdFx0XHRcdGxhYmVsWDogbGFiZWxYLFxuXHRcdFx0XHRcdGxhYmVsWTogbGFiZWxZLFxuXHRcdFx0XHRcdGdsV2lkdGg6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRnbENvbG9yOiBsaW5lQ29sb3IsXG5cdFx0XHRcdFx0Z2xCb3JkZXJEYXNoOiBib3JkZXJEYXNoLFxuXHRcdFx0XHRcdGdsQm9yZGVyRGFzaE9mZnNldDogYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdFx0XHRyb3RhdGlvbjogLTEgKiBsYWJlbFJvdGF0aW9uUmFkaWFucyxcblx0XHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdFx0dGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG5cdFx0XHRcdFx0dGV4dEFsaWduOiB0ZXh0QWxpZ25cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRpY2sgbGFiZWxzLCB0aWNrIG1hcmtzLCBhbmQgZ3JpZCBsaW5lcyBhdCB0aGUgY29ycmVjdCBwbGFjZXNcblx0XHRcdGhlbHBlcnMuZWFjaChpdGVtc1RvRHJhdywgZnVuY3Rpb24oaXRlbVRvRHJhdykge1xuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGl0ZW1Ub0RyYXcuZ2xXaWR0aDtcblx0XHRcdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gaXRlbVRvRHJhdy5nbENvbG9yO1xuXHRcdFx0XHRcdGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldExpbmVEYXNoKGl0ZW1Ub0RyYXcuZ2xCb3JkZXJEYXNoKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcblx0XHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcudHgxLCBpdGVtVG9EcmF3LnR5MSk7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmxpbmVUbyhpdGVtVG9EcmF3LnR4MiwgaXRlbVRvRHJhdy50eTIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd09uQ2hhcnRBcmVhKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LngxLCBpdGVtVG9EcmF3LnkxKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcueDIsIGl0ZW1Ub0RyYXcueTIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0aW9uVGlja3MuZGlzcGxheSkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdFx0Y29udGV4dC5yb3RhdGUoaXRlbVRvRHJhdy5yb3RhdGlvbik7XG5cdFx0XHRcdFx0Y29udGV4dC5mb250ID0gdGlja0ZvbnQuZm9udDtcblx0XHRcdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9IGl0ZW1Ub0RyYXcudGV4dEJhc2VsaW5lO1xuXHRcdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0XHR2YXIgbGFiZWwgPSBpdGVtVG9EcmF3LmxhYmVsO1xuXHRcdFx0XHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBsYWJlbC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQoJycgKyBsYWJlbFtpXSwgMCwgeSk7XG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHNhbWUgbGluZVNwYWNpbmcgYXMgY2FsY3VsYXRlZCBAIEwjMzIwXG5cdFx0XHRcdFx0XHRcdHkgKz0gKHRpY2tGb250LnNpemUgKiAxLjUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc2NhbGVMYWJlbC5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHRcdHZhciBzY2FsZUxhYmVsWDtcblx0XHRcdFx0dmFyIHNjYWxlTGFiZWxZO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRzY2FsZUxhYmVsWCA9IG1lLmxlZnQgKyAoKG1lLnJpZ2h0IC0gbWUubGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdFx0c2NhbGVMYWJlbFkgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJyA/IG1lLmJvdHRvbSAtIChzY2FsZUxhYmVsRm9udC5zaXplIC8gMikgOiBtZS50b3AgKyAoc2NhbGVMYWJlbEZvbnQuc2l6ZSAvIDIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBpc0xlZnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdFx0c2NhbGVMYWJlbFggPSBpc0xlZnQgPyBtZS5sZWZ0ICsgKHNjYWxlTGFiZWxGb250LnNpemUgLyAyKSA6IG1lLnJpZ2h0IC0gKHNjYWxlTGFiZWxGb250LnNpemUgLyAyKTtcblx0XHRcdFx0XHRzY2FsZUxhYmVsWSA9IG1lLnRvcCArICgobWUuYm90dG9tIC0gbWUudG9wKSAvIDIpO1xuXHRcdFx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XG5cdFx0XHRcdGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdFx0Y29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdFx0Y29udGV4dC5mb250ID0gc2NhbGVMYWJlbEZvbnQuZm9udDtcblx0XHRcdFx0Y29udGV4dC5maWxsVGV4dChzY2FsZUxhYmVsLmxhYmVsU3RyaW5nLCAwLCAwKTtcblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChncmlkTGluZXMuZHJhd0JvcmRlcikge1xuXHRcdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXG5cdFx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCk7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0XHR2YXIgeDEgPSBtZS5sZWZ0LFxuXHRcdFx0XHRcdHgyID0gbWUucmlnaHQsXG5cdFx0XHRcdFx0eTEgPSBtZS50b3AsXG5cdFx0XHRcdFx0eTIgPSBtZS5ib3R0b207XG5cblx0XHRcdFx0dmFyIGFsaWFzUGl4ZWwgPSBoZWxwZXJzLmFsaWFzUGl4ZWwoY29udGV4dC5saW5lV2lkdGgpO1xuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0eTEgPSB5MiA9IG9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnID8gbWUuYm90dG9tIDogbWUudG9wO1xuXHRcdFx0XHRcdHkxICs9IGFsaWFzUGl4ZWw7XG5cdFx0XHRcdFx0eTIgKz0gYWxpYXNQaXhlbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MSA9IHgyID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gbWUucmlnaHQgOiBtZS5sZWZ0O1xuXHRcdFx0XHRcdHgxICs9IGFsaWFzUGl4ZWw7XG5cdFx0XHRcdFx0eDIgKz0gYWxpYXNQaXhlbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG5cdFx0XHRcdGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0Q2hhcnQuc2NhbGVTZXJ2aWNlID0ge1xuXHRcdC8vIFNjYWxlIHJlZ2lzdHJhdGlvbiBvYmplY3QuIEV4dGVuc2lvbnMgY2FuIHJlZ2lzdGVyIG5ldyBzY2FsZSB0eXBlcyAoc3VjaCBhcyBsb2cgb3IgREIgc2NhbGVzKSBhbmQgdGhlblxuXHRcdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxuXHRcdGNvbnN0cnVjdG9yczoge30sXG5cdFx0Ly8gVXNlIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIG1vdmUgdG8gYW4gRVM2IG1hcCB3aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHN1cHBvcnRcblx0XHQvLyBvbGQgYnJvd3NlcnNcblxuXHRcdC8vIFNjYWxlIGNvbmZpZyBkZWZhdWx0c1xuXHRcdGRlZmF1bHRzOiB7fSxcblx0XHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3RvciwgZGVmYXVsdHMpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHRcdHRoaXMuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzLmNsb25lKGRlZmF1bHRzKTtcblx0XHR9LFxuXHRcdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcblx0XHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycy5zY2FsZU1lcmdlKENoYXJ0LmRlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdKSA6IHt9O1xuXHRcdH0sXG5cdFx0dXBkYXRlU2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSwgYWRkaXRpb25zKSB7XG5cdFx0XHR2YXIgZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzO1xuXHRcdFx0aWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRcdGRlZmF1bHRzW3R5cGVdID0gaGVscGVycy5leHRlbmQoZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0XHRcdC8vIFNldCBJTGF5b3V0SXRlbSBwYXJhbWV0ZXJzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdFx0c2NhbGUucG9zaXRpb24gPSBzY2FsZS5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0XHRzY2FsZS53ZWlnaHQgPSBzY2FsZS5vcHRpb25zLndlaWdodDtcblx0XHRcdFx0Q2hhcnQubGF5b3V0U2VydmljZS5hZGRCb3goY2hhcnQsIHNjYWxlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0LyoqXG5cdCAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3Ncblx0ICovXG5cdENoYXJ0LlRpY2tzID0ge1xuXHRcdC8qKlxuXHRcdCAqIE5hbWVzcGFjZSB0byBob2xkIGdlbmVyYXRvcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuXHRcdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZ2VuZXJhdG9yc1xuXHRcdCAqL1xuXHRcdGdlbmVyYXRvcnM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogSW50ZXJmYWNlIGZvciB0aGUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgbnVtZXJpYyB0aWNrIGdlbmVyYXRvclxuXHRcdFx0ICogQGludGVyZmFjZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9uc1xuXHRcdFx0ICovXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byBkaXNwbGF5XG5cdFx0XHQgKiBAbmFtZSBJTnVtZXJpY1RpY2tHZW5lcmF0aW9uT3B0aW9ucyNtYXhUaWNrc1xuXHRcdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0XHQgKi9cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCB0aWNrLlxuXHRcdFx0ICogQG5hbWUgSU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnMjc3RlcFNpemVcblx0XHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdFx0ICogQG9wdGlvbmFsXG5cdFx0XHQgKi9cblx0XHRcdC8qKlxuXHRcdFx0ICogRm9yY2VkIG1pbmltdW0gZm9yIHRoZSB0aWNrcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIG1pbmltdW0gb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHRpY2sgbWluaW11bVxuXHRcdFx0ICogQG5hbWUgSU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnMjbWluXG5cdFx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHRcdCAqIEBvcHRpb25hbFxuXHRcdFx0ICovXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSB0aWNrcy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIG1heGltdW0gb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHRpY2sgbWF4aW11bVxuXHRcdFx0ICogQG5hbWUgSU51bWVyaWNUaWNrR2VuZXJhdGlvbk9wdGlvbnMjbWF4XG5cdFx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHRcdCAqIEBvcHRpb25hbFxuXHRcdFx0ICovXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzXG5cdFx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmdlbmVyYXRvcnMubGluZWFyXG5cdFx0XHQgKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMge0lOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zfSB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuXHRcdFx0ICogQHBhcmFtIGRhdGFSYW5nZSB7SVJhbmdlfSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcblx0XHRcdCAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuXHRcdFx0ICovXG5cdFx0XHRsaW5lYXI6IGZ1bmN0aW9uKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0XHRcdFx0dmFyIHRpY2tzID0gW107XG5cdFx0XHRcdC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuXHRcdFx0XHQvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG5cdFx0XHRcdC8vIGZvciBkZXRhaWxzLlxuXG5cdFx0XHRcdHZhciBzcGFjaW5nO1xuXHRcdFx0XHRpZiAoZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemUgJiYgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemUgPiAwKSB7XG5cdFx0XHRcdFx0c3BhY2luZyA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBuaWNlUmFuZ2UgPSBoZWxwZXJzLm5pY2VOdW0oZGF0YVJhbmdlLm1heCAtIGRhdGFSYW5nZS5taW4sIGZhbHNlKTtcblx0XHRcdFx0XHRzcGFjaW5nID0gaGVscGVycy5uaWNlTnVtKG5pY2VSYW5nZSAvIChnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDEpLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbmljZU1pbiA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0XHRcdFx0dmFyIG5pY2VNYXggPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcblxuXHRcdFx0XHQvLyBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgaXMgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG5cdFx0XHRcdGlmIChnZW5lcmF0aW9uT3B0aW9ucy5taW4gJiYgZ2VuZXJhdGlvbk9wdGlvbnMubWF4ICYmIGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0XHRcdFx0aWYgKGhlbHBlcnMuYWxtb3N0V2hvbGUoKGdlbmVyYXRpb25PcHRpb25zLm1heCAtIGdlbmVyYXRpb25PcHRpb25zLm1pbikgLyBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRcdFx0XHRuaWNlTWluID0gZ2VuZXJhdGlvbk9wdGlvbnMubWluO1xuXHRcdFx0XHRcdFx0bmljZU1heCA9IGdlbmVyYXRpb25PcHRpb25zLm1heDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cdFx0XHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMuYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdFx0XHRudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQdXQgdGhlIHZhbHVlcyBpbnRvIHRoZSB0aWNrcyBhcnJheVxuXHRcdFx0XHR0aWNrcy5wdXNoKGdlbmVyYXRpb25PcHRpb25zLm1pbiAhPT0gdW5kZWZpbmVkID8gZ2VuZXJhdGlvbk9wdGlvbnMubWluIDogbmljZU1pbik7XG5cdFx0XHRcdGZvciAodmFyIGogPSAxOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcblx0XHRcdFx0XHR0aWNrcy5wdXNoKG5pY2VNaW4gKyAoaiAqIHNwYWNpbmcpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWNrcy5wdXNoKGdlbmVyYXRpb25PcHRpb25zLm1heCAhPT0gdW5kZWZpbmVkID8gZ2VuZXJhdGlvbk9wdGlvbnMubWF4IDogbmljZU1heCk7XG5cblx0XHRcdFx0cmV0dXJuIHRpY2tzO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuXHRcdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5nZW5lcmF0b3JzLmxvZ2FyaXRobWljXG5cdFx0XHQgKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMge0lOdW1lcmljVGlja0dlbmVyYXRpb25PcHRpb25zfSB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuXHRcdFx0ICogQHBhcmFtIGRhdGFSYW5nZSB7SVJhbmdlfSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcblx0XHRcdCAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuXHRcdFx0ICovXG5cdFx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24oZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuXHRcdFx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHRcdFx0dmFyIGdldFZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdDtcblxuXHRcdFx0XHQvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2Zcblx0XHRcdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDUwXG5cdFx0XHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0XHRcdC8vIHRoZSBncmFwaFxuXHRcdFx0XHR2YXIgdGlja1ZhbCA9IGdldFZhbHVlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcblxuXHRcdFx0XHR2YXIgZW5kRXhwID0gTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcblx0XHRcdFx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG5cdFx0XHRcdHZhciBleHA7XG5cdFx0XHRcdHZhciBzaWduaWZpY2FuZDtcblxuXHRcdFx0XHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdFx0XHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChkYXRhUmFuZ2UubWluTm90WmVybykpO1xuXHRcdFx0XHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcihkYXRhUmFuZ2UubWluTm90WmVybyAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdFx0XHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cdFx0XHRcdFx0dGlja1ZhbCA9IHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKHRpY2tWYWwpKTtcblx0XHRcdFx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0XHRcdFx0KytzaWduaWZpY2FuZDtcblx0XHRcdFx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRcdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHRcdFx0XHQrK2V4cDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0XHRcdFx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0XHRcdFx0dmFyIGxhc3RUaWNrID0gZ2V0VmFsdWVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcblx0XHRcdFx0dGlja3MucHVzaChsYXN0VGljayk7XG5cblx0XHRcdFx0cmV0dXJuIHRpY2tzO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0XHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcblx0XHQgKi9cblx0XHRmb3JtYXR0ZXJzOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG5cdFx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0XHQgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcblx0XHRcdCAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcblx0XHRcdCAqL1xuXHRcdFx0dmFsdWVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRm9ybWF0dGVyIGZvciBsaW5lYXIgbnVtZXJpYyB0aWNrc1xuXHRcdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHRcdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7TnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0XHQgKiBAcGFyYW0gaW5kZXgge051bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuXHRcdFx0ICogQHBhcmFtIHRpY2tzIHtBcnJheTxOdW1iZXI+fSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHRcdCAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG5cdFx0XHQgKi9cblx0XHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBsb3RzIG9mIHRpY2tzLCBkb24ndCB1c2UgdGhlIG9uZXNcblx0XHRcdFx0dmFyIGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdIC0gdGlja3NbMV0gOiB0aWNrc1sxXSAtIHRpY2tzWzBdO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdFx0aWYgKE1hdGguYWJzKGRlbHRhKSA+IDEpIHtcblx0XHRcdFx0XHRpZiAodGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0XHRkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbG9nRGVsdGEgPSBoZWxwZXJzLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XG5cblx0XHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gMCkge1xuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGlja1N0cmluZyA9ICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKHRpY2tWYWx1ZSkpKSk7XG5cblx0XHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiAnMCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHRpY2tzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHQvKipcbiBcdCAqIEhlbHBlciBtZXRob2QgdG8gbWVyZ2UgdGhlIG9wYWNpdHkgaW50byBhIGNvbG9yXG4gXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VPcGFjaXR5KGNvbG9yU3RyaW5nLCBvcGFjaXR5KSB7XG5cdFx0dmFyIGNvbG9yID0gaGVscGVycy5jb2xvcihjb2xvclN0cmluZyk7XG5cdFx0cmV0dXJuIGNvbG9yLmFscGhhKG9wYWNpdHkgKiBjb2xvci5hbHBoYSgpKS5yZ2JhU3RyaW5nKCk7XG5cdH1cblxuXHRDaGFydC5kZWZhdWx0cy5nbG9iYWwudG9vbHRpcHMgPSB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycy5ub29wLFxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xuXHRcdFx0XHQvLyBQaWNrIGZpcnN0IHhMYWJlbCBmb3Igbm93XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cblx0XHRcdFx0XHRpZiAoaXRlbS54TGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmluZGV4IDwgbGFiZWxDb3VudCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0XHRiZWZvcmVMYWJlbDogaGVscGVycy5ub29wLFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblxuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbCArPSAnOiAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsQ29sb3I6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBjaGFydCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBhY3RpdmVFbGVtZW50ID0gbWV0YS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZpZXcgPSBhY3RpdmVFbGVtZW50Ll92aWV3O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiB2aWV3LmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdmlldy5iYWNrZ3JvdW5kQ29sb3Jcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YWZ0ZXJCb2R5OiBoZWxwZXJzLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlRm9vdGVyOiBoZWxwZXJzLm5vb3AsXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMubm9vcCxcblx0XHRcdGFmdGVyRm9vdGVyOiBoZWxwZXJzLm5vb3Bcblx0XHR9XG5cdH07XG5cblx0Ly8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuXHRmdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG5cdFx0aWYgKHRvUHVzaCkge1xuXHRcdFx0aWYgKGhlbHBlcnMuaXNBcnJheSh0b1B1c2gpKSB7XG5cdFx0XHRcdC8vIGJhc2UgPSBiYXNlLmNvbmNhdCh0b1B1c2gpO1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YmFzZS5wdXNoKHRvUHVzaCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvLyBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcblx0Ly8gQHBhcmFtIGVsZW1lbnQgOiB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3Jcblx0Ly8gQHJldHVybiA6IG5ldyB0b29sdGlwIGl0ZW1cblx0ZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oZWxlbWVudCkge1xuXHRcdHZhciB4U2NhbGUgPSBlbGVtZW50Ll94U2NhbGU7XG5cdFx0dmFyIHlTY2FsZSA9IGVsZW1lbnQuX3lTY2FsZSB8fCBlbGVtZW50Ll9zY2FsZTsgLy8gaGFuZGxlIHJhZGFyIHx8IHBvbGFyQXJlYSBjaGFydHNcblx0XHR2YXIgaW5kZXggPSBlbGVtZW50Ll9pbmRleCxcblx0XHRcdGRhdGFzZXRJbmRleCA9IGVsZW1lbnQuX2RhdGFzZXRJbmRleDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0XHR5TGFiZWw6IHlTY2FsZSA/IHlTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXG5cdFx0XHR5OiBlbGVtZW50Ll9tb2RlbC55XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHRvb2x0aXBPcHRzIHtPYmplY3R9IHRoZSB0b29sdGlwIG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IENoYXJ0LmRlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXG5cdFx0XHR5UGFkZGluZzogdG9vbHRpcE9wdHMueVBhZGRpbmcsXG5cdFx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxuXG5cdFx0XHQvLyBCb2R5XG5cdFx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdFx0X2JvZHlGb250RmFtaWx5OiBnZXRWYWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdFx0X2JvZHlGb250U3R5bGU6IGdldFZhbHVlT3JEZWZhdWx0KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0X2JvZHlBbGlnbjogdG9vbHRpcE9wdHMuYm9keUFsaWduLFxuXHRcdFx0Ym9keUZvbnRTaXplOiBnZXRWYWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRib2R5U3BhY2luZzogdG9vbHRpcE9wdHMuYm9keVNwYWNpbmcsXG5cblx0XHRcdC8vIFRpdGxlXG5cdFx0XHR0aXRsZUZvbnRDb2xvcjogdG9vbHRpcE9wdHMudGl0bGVGb250Q29sb3IsXG5cdFx0XHRfdGl0bGVGb250RmFtaWx5OiBnZXRWYWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy50aXRsZUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdF90aXRsZUZvbnRTdHlsZTogZ2V0VmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0dGl0bGVGb250U2l6ZTogZ2V0VmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMudGl0bGVGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRcdF90aXRsZUFsaWduOiB0b29sdGlwT3B0cy50aXRsZUFsaWduLFxuXHRcdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0XHR0aXRsZU1hcmdpbkJvdHRvbTogdG9vbHRpcE9wdHMudGl0bGVNYXJnaW5Cb3R0b20sXG5cblx0XHRcdC8vIEZvb3RlclxuXHRcdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0XHRfZm9vdGVyRm9udEZhbWlseTogZ2V0VmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdFx0X2Zvb3RlckZvbnRTdHlsZTogZ2V0VmFsdWVPckRlZmF1bHQodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdGZvb3RlckZvbnRTaXplOiBnZXRWYWx1ZU9yRGVmYXVsdCh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRcdF9mb290ZXJBbGlnbjogdG9vbHRpcE9wdHMuZm9vdGVyQWxpZ24sXG5cdFx0XHRmb290ZXJTcGFjaW5nOiB0b29sdGlwT3B0cy5mb290ZXJTcGFjaW5nLFxuXHRcdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdGNhcmV0U2l6ZTogdG9vbHRpcE9wdHMuY2FyZXRTaXplLFxuXHRcdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcblx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXG5cdFx0XHRib3JkZXJDb2xvcjogdG9vbHRpcE9wdHMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0XHR2YXIgY3R4ID0gdG9vbHRpcC5fY2hhcnQuY3R4O1xuXG5cdFx0dmFyIGhlaWdodCA9IG1vZGVsLnlQYWRkaW5nICogMjsgLy8gVG9vbHRpcCBQYWRkaW5nXG5cdFx0dmFyIHdpZHRoID0gMDtcblxuXHRcdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuXHRcdHZhciBib2R5ID0gbW9kZWwuYm9keTtcblx0XHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xuXHRcdH0sIDApO1xuXHRcdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0XHR2YXIgdGl0bGVMaW5lQ291bnQgPSBtb2RlbC50aXRsZS5sZW5ndGg7XG5cdFx0dmFyIGZvb3RlckxpbmVDb3VudCA9IG1vZGVsLmZvb3Rlci5sZW5ndGg7XG5cdFx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplLFxuXHRcdFx0Ym9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplLFxuXHRcdFx0Zm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRcdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udFNpemU7IC8vIFRpdGxlIExpbmVzXG5cdFx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ID8gKHRpdGxlTGluZUNvdW50IC0gMSkgKiBtb2RlbC50aXRsZVNwYWNpbmcgOiAwOyAvLyBUaXRsZSBMaW5lIFNwYWNpbmdcblx0XHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRcdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggKiBib2R5Rm9udFNpemU7IC8vIEJvZHkgTGluZXNcblx0XHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoID8gKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogbW9kZWwuYm9keVNwYWNpbmcgOiAwOyAvLyBCb2R5IExpbmUgU3BhY2luZ1xuXHRcdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdFx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCAqIChmb290ZXJGb250U2l6ZSk7IC8vIEZvb3RlciBMaW5lc1xuXHRcdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBtb2RlbC5mb290ZXJTcGFjaW5nIDogMDsgLy8gRm9vdGVyIExpbmUgU3BhY2luZ1xuXG5cdFx0Ly8gVGl0bGUgd2lkdGhcblx0XHR2YXIgd2lkdGhQYWRkaW5nID0gMDtcblx0XHR2YXIgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0XHR9O1xuXG5cdFx0Y3R4LmZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgbW9kZWwuX3RpdGxlRm9udFN0eWxlLCBtb2RlbC5fdGl0bGVGb250RmFtaWx5KTtcblx0XHRoZWxwZXJzLmVhY2gobW9kZWwudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cblx0XHQvLyBCb2R5IHdpZHRoXG5cdFx0Y3R4LmZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCBtb2RlbC5fYm9keUZvbnRTdHlsZSwgbW9kZWwuX2JvZHlGb250RmFtaWx5KTtcblx0XHRoZWxwZXJzLmVhY2gobW9kZWwuYmVmb3JlQm9keS5jb25jYXQobW9kZWwuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuXHRcdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHRcdHdpZHRoUGFkZGluZyA9IG1vZGVsLmRpc3BsYXlDb2xvcnMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xuXHRcdGhlbHBlcnMuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSkge1xuXHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcblx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcblx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHRcdHdpZHRoUGFkZGluZyA9IDA7XG5cblx0XHQvLyBGb290ZXIgd2lkdGhcblx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhmb290ZXJGb250U2l6ZSwgbW9kZWwuX2Zvb3RlckZvbnRTdHlsZSwgbW9kZWwuX2Zvb3RlckZvbnRGYW1pbHkpO1xuXHRcdGhlbHBlcnMuZWFjaChtb2RlbC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cblx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdHdpZHRoICs9IDIgKiBtb2RlbC54UGFkZGluZztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIHRvIGdldCB0aGUgYWxpZ25tZW50IG9mIGEgdG9vbHRpcCBnaXZlbiB0aGUgc2l6ZVxuXHQgKi9cblx0ZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KHRvb2x0aXAsIHNpemUpIHtcblx0XHR2YXIgbW9kZWwgPSB0b29sdGlwLl9tb2RlbDtcblx0XHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gdG9vbHRpcC5fY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciB4QWxpZ24gPSAnY2VudGVyJztcblx0XHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0XHRpZiAobW9kZWwueSA8IHNpemUuaGVpZ2h0KSB7XG5cdFx0XHR5QWxpZ24gPSAndG9wJztcblx0XHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0XHR5QWxpZ24gPSAnYm90dG9tJztcblx0XHR9XG5cblx0XHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHRcdHZhciBvbGYsIG9yZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBpZiBsZWZ0L3JpZ2h0IGFsaWdubWVudCBjYXVzZXMgdG9vbHRpcCB0byBnbyBvdXRzaWRlIGNoYXJ0XG5cdFx0dmFyIHlmOyAvLyBmdW5jdGlvbiB0byBnZXQgdGhlIHkgYWxpZ25tZW50IGlmIHRoZSB0b29sdGlwIGdvZXMgb3V0c2lkZSBvZiB0aGUgbGVmdCBvciByaWdodCBlZGdlc1xuXHRcdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdFx0dmFyIG1pZFkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIHggPD0gbWlkWDtcblx0XHRcdH07XG5cdFx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0cmV0dXJuIHggPiBtaWRYO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiB4IDw9IChzaXplLndpZHRoIC8gMik7XG5cdFx0XHR9O1xuXHRcdFx0cmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdHJldHVybiB4ID49IChjaGFydC53aWR0aCAtIChzaXplLndpZHRoIC8gMikpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRvbGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCArIHNpemUud2lkdGggPiBjaGFydC53aWR0aDtcblx0XHR9O1xuXHRcdG9yZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCA8IDA7XG5cdFx0fTtcblx0XHR5ZiA9IGZ1bmN0aW9uKHkpIHtcblx0XHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHRcdH07XG5cblx0XHRpZiAobGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdmVyIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjaGFydC4/XG5cdFx0XHRpZiAob2xmKG1vZGVsLngpKSB7XG5cdFx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0XHR4QWxpZ24gPSAncmlnaHQnO1xuXG5cdFx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG91dHNpZGUgbGVmdCBlZGdlIG9mIGNhbnZhcz9cblx0XHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBvcHRzID0gdG9vbHRpcC5fb3B0aW9ucztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eEFsaWduOiBvcHRzLnhBbGlnbiA/IG9wdHMueEFsaWduIDogeEFsaWduLFxuXHRcdFx0eUFsaWduOiBvcHRzLnlBbGlnbiA/IG9wdHMueUFsaWduIDogeUFsaWduXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBASGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcblx0ICovXG5cdGZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludCh2bSwgc2l6ZSwgYWxpZ25tZW50KSB7XG5cdFx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cblx0XHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplLFxuXHRcdFx0Y2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nLFxuXHRcdFx0Y29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzLFxuXHRcdFx0eEFsaWduID0gYWxpZ25tZW50LnhBbGlnbixcblx0XHRcdHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ24sXG5cdFx0XHRwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZyxcblx0XHRcdHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0XHRpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR4IC09IHNpemUud2lkdGg7XG5cdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR4IC09IChzaXplLndpZHRoIC8gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHkgKz0gcGFkZGluZ0FuZFNpemU7XG5cdFx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0XHR5IC09IHNpemUuaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4ICs9IHBhZGRpbmdBbmRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHggKz0gcmFkaXVzQW5kUGFkZGluZztcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9XG5cblx0Q2hhcnQuVG9vbHRpcCA9IENoYXJ0LkVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX21vZGVsID0gZ2V0QmFzZU1vZGVsKHRoaXMuX29wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgdGhlIHRpdGxlXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblx0XHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdFx0dmFyIGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpLFxuXHRcdFx0XHR0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseShtZSwgYXJndW1lbnRzKSxcblx0XHRcdFx0YWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBiZWZvcmVUaXRsZSk7XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgdGl0bGUpO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGFmdGVyVGl0bGUpO1xuXG5cdFx0XHRyZXR1cm4gbGluZXM7XG5cdFx0fSxcblxuXHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGluZXMgPSB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KGxpbmVzKSA/IGxpbmVzIDogbGluZXMgIT09IHVuZGVmaW5lZCA/IFtsaW5lc10gOiBbXTtcblx0XHR9LFxuXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRCb2R5OiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdFx0dmFyIGJvZHlJdGVtcyA9IFtdO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0XHR2YXIgYm9keUl0ZW0gPSB7XG5cdFx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0XHRsaW5lczogW10sXG5cdFx0XHRcdFx0YWZ0ZXI6IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xuXHRcdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGNhbGxiYWNrcy5sYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xuXHRcdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIGNhbGxiYWNrcy5hZnRlckxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cblx0XHRcdFx0Ym9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBib2R5SXRlbXM7XG5cdFx0fSxcblxuXHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsaW5lcyA9IHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMuaXNBcnJheShsaW5lcykgPyBsaW5lcyA6IGxpbmVzICE9PSB1bmRlZmluZWQgPyBbbGluZXNdIDogW107XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRnZXRGb290ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cblx0XHRcdHZhciBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIGJlZm9yZUZvb3Rlcik7XG5cdFx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgZm9vdGVyKTtcblx0XHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBhZnRlckZvb3Rlcik7XG5cblx0XHRcdHJldHVybiBsaW5lcztcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihjaGFuZ2VkKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblxuXHRcdFx0Ly8gTmVlZCB0byByZWdlbmVyYXRlIHRoZSBtb2RlbCBiZWNhdXNlIGl0cyBmYXN0ZXIgdGhhbiB1c2luZyBleHRlbmQgYW5kIGl0IGlzIG5lY2Vzc2FyeSBkdWUgdG8gdGhlIG9wdGltaXphdGlvbiBpbiBDaGFydC5FbGVtZW50LnRyYW5zaXRpb25cblx0XHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cblx0XHRcdHZhciBleGlzdGluZ01vZGVsID0gbWUuX21vZGVsO1xuXHRcdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdHZhciBkYXRhID0gbWUuX2RhdGE7XG5cblx0XHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0XHR2YXIgYWxpZ25tZW50ID0ge1xuXHRcdFx0XHR4QWxpZ246IGV4aXN0aW5nTW9kZWwueEFsaWduLFxuXHRcdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0XHR9O1xuXHRcdFx0dmFyIGJhY2tncm91bmRQb2ludCA9IHtcblx0XHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0XHR5OiBleGlzdGluZ01vZGVsLnlcblx0XHRcdH07XG5cdFx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiBleGlzdGluZ01vZGVsLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGV4aXN0aW5nTW9kZWwuaGVpZ2h0XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHRvb2x0aXBQb3NpdGlvbiA9IHtcblx0XHRcdFx0eDogZXhpc3RpbmdNb2RlbC5jYXJldFgsXG5cdFx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgaSwgbGVuO1xuXG5cdFx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0XHRtb2RlbC5vcGFjaXR5ID0gMTtcblxuXHRcdFx0XHR2YXIgbGFiZWxDb2xvcnMgPSBbXTtcblx0XHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1tvcHRzLnBvc2l0aW9uXShhY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcblxuXHRcdFx0XHR2YXIgdG9vbHRpcEl0ZW1zID0gW107XG5cdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRcdHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKGFjdGl2ZVtpXSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdFx0aWYgKG9wdHMuZmlsdGVyKSB7XG5cdFx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcihmdW5jdGlvbihhKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdFx0aWYgKG9wdHMuaXRlbVNvcnQpIHtcblx0XHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRcdGhlbHBlcnMuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdFx0bGFiZWxDb2xvcnMucHVzaChvcHRzLmNhbGxiYWNrcy5sYWJlbENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gQnVpbGQgdGhlIFRleHQgTGluZXNcblx0XHRcdFx0bW9kZWwudGl0bGUgPSBtZS5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0XHRtb2RlbC5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0XHRtb2RlbC5hZnRlckJvZHkgPSBtZS5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdFx0Ly8gSW5pdGlhbCBwb3NpdGlvbmluZyBhbmQgY29sb3JzXG5cdFx0XHRcdG1vZGVsLnggPSBNYXRoLnJvdW5kKHRvb2x0aXBQb3NpdGlvbi54KTtcblx0XHRcdFx0bW9kZWwueSA9IE1hdGgucm91bmQodG9vbHRpcFBvc2l0aW9uLnkpO1xuXHRcdFx0XHRtb2RlbC5jYXJldFBhZGRpbmcgPSBvcHRzLmNhcmV0UGFkZGluZztcblx0XHRcdFx0bW9kZWwubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcblxuXHRcdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGFsaWdubWVudCBvZiB0aGUgdG9vbHRpcFxuXHRcdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdFx0YWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMsIHRvb2x0aXBTaXplKTtcblx0XHRcdFx0Ly8gRmluYWwgU2l6ZSBhbmQgUG9zaXRpb25cblx0XHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLm9wYWNpdHkgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0XHRcdG1vZGVsLnggPSBiYWNrZ3JvdW5kUG9pbnQueDtcblx0XHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0XHRtb2RlbC5oZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cblx0XHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRcdG1vZGVsLmNhcmV0WCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwuY2FyZXRZID0gdG9vbHRpcFBvc2l0aW9uLnk7XG5cblx0XHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xuXHRcdFx0XHRvcHRzLmN1c3RvbS5jYWxsKG1lLCBtb2RlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZTtcblx0XHR9LFxuXHRcdGRyYXdDYXJldDogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pO1xuXG5cdFx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcblx0XHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG5cdFx0fSxcblx0XHRnZXRDYXJldFBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKSB7XG5cdFx0XHR2YXIgeDEsIHgyLCB4Mztcblx0XHRcdHZhciB5MSwgeTIsIHkzO1xuXHRcdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcblx0XHRcdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cdFx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduLFxuXHRcdFx0XHR5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0XHR2YXIgcHRYID0gdG9vbHRpcFBvaW50LngsXG5cdFx0XHRcdHB0WSA9IHRvb2x0aXBQb2ludC55O1xuXHRcdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cblx0XHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG5cdFx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHRcdHgyID0geDEgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDMgPSB4MTtcblxuXHRcdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdFx0eTMgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHRcdHgyID0geDEgKyBjYXJldFNpemU7XG5cdFx0XHRcdFx0eDMgPSB4MTtcblxuXHRcdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdFx0eTMgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDIgPSBwdFggKyBjb3JuZXJSYWRpdXMgKyAoY2FyZXRTaXplKTtcblx0XHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDIgPSBwdFggKyAod2lkdGggLyAyKTtcblx0XHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHR5MSA9IHB0WTtcblx0XHRcdFx0XHR5MiA9IHkxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHRcdHkzID0geTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eTEgPSBwdFkgKyBoZWlnaHQ7XG5cdFx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0XHR5MyA9IHkxO1xuXHRcdFx0XHRcdC8vIGludmVydCBkcmF3aW5nIG9yZGVyXG5cdFx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHRcdHgzID0geDE7XG5cdFx0XHRcdFx0eDEgPSB0bXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7eDE6IHgxLCB4MjogeDIsIHgzOiB4MywgeTE6IHkxLCB5MjogeTIsIHkzOiB5M307XG5cdFx0fSxcblx0XHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4LCBvcGFjaXR5KSB7XG5cdFx0XHR2YXIgdGl0bGUgPSB2bS50aXRsZTtcblxuXHRcdFx0aWYgKHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX3RpdGxlQWxpZ247XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHR2YXIgdGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemUsXG5cdFx0XHRcdFx0dGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0udGl0bGVGb250Q29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCB2bS5fdGl0bGVGb250U3R5bGUsIHZtLl90aXRsZUZvbnRGYW1pbHkpO1xuXG5cdFx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpdGxlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBwdC54LCBwdC55KTtcblx0XHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0XHRpZiAoaSArIDEgPT09IHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cHQueSArPSB2bS50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZzsgLy8gSWYgTGFzdCwgYWRkIG1hcmdpbiwgcmVtb3ZlIHNwYWNpbmdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgb3BhY2l0eSkge1xuXHRcdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcblx0XHRcdHZhciBib2R5U3BhY2luZyA9IHZtLmJvZHlTcGFjaW5nO1xuXHRcdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX2JvZHlBbGlnbjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0dmFyIHRleHRDb2xvciA9IG1lcmdlT3BhY2l0eSh2bS5ib2R5Rm9udENvbG9yLCBvcGFjaXR5KTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIHZtLl9ib2R5Rm9udFN0eWxlLCB2bS5fYm9keUZvbnRGYW1pbHkpO1xuXG5cdFx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0XHR2YXIgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdFx0cHQueSArPSBib2R5Rm9udFNpemUgKyBib2R5U3BhY2luZztcblx0XHRcdH07XG5cblx0XHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0XHRoZWxwZXJzLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHR2YXIgZHJhd0NvbG9yQm94ZXMgPSB2bS5kaXNwbGF5Q29sb3JzO1xuXHRcdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xuXG5cdFx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0XHRoZWxwZXJzLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChib2R5SXRlbS5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG1lcmdlT3BhY2l0eSh2bS5sZWdlbmRDb2xvckJhY2tncm91bmQsIG9wYWNpdHkpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHB0LngsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdFx0Ly8gQm9yZGVyXG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0ubGFiZWxDb2xvcnNbaV0uYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QocHQueCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0XHQvLyBJbm5lciBzcXVhcmVcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0ubGFiZWxDb2xvcnNbaV0uYmFja2dyb3VuZENvbG9yLCBvcGFjaXR5KTtcblx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdChwdC54ICsgMSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZpbGxMaW5lT2ZUZXh0KGxpbmUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcblx0XHRcdHhMaW5lUGFkZGluZyA9IDA7XG5cblx0XHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRcdGhlbHBlcnMuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuXHRcdH0sXG5cdFx0ZHJhd0Zvb3RlcjogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIG9wYWNpdHkpIHtcblx0XHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRcdGlmIChmb290ZXIubGVuZ3RoKSB7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyTWFyZ2luVG9wO1xuXG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmZvb3RlckZvbnRDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRcdGN0eC5mb250ID0gaGVscGVycy5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54LCBwdC55KTtcblx0XHRcdFx0XHRwdC55ICs9IHZtLmZvb3RlckZvbnRTaXplICsgdm0uZm9vdGVyU3BhY2luZztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplLCBvcGFjaXR5KSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gbWVyZ2VPcGFjaXR5KHZtLmJhY2tncm91bmRDb2xvciwgb3BhY2l0eSk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBtZXJnZU9wYWNpdHkodm0uYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0XHR2YXIgeCA9IHB0Lng7XG5cdFx0XHR2YXIgeSA9IHB0Lnk7XG5cdFx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cdFx0XHR2YXIgcmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcblx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdGN0eC5maWxsKCk7XG5cblx0XHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiB2bS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiB2bS5oZWlnaHRcblx0XHRcdH07XG5cdFx0XHR2YXIgcHQgPSB7XG5cdFx0XHRcdHg6IHZtLngsXG5cdFx0XHRcdHk6IHZtLnlcblx0XHRcdH07XG5cblx0XHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcblx0XHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHRcdC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcblx0XHRcdHZhciBoYXNUb29sdGlwQ29udGVudCA9IHZtLnRpdGxlLmxlbmd0aCB8fCB2bS5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB2bS5ib2R5Lmxlbmd0aCB8fCB2bS5hZnRlckJvZHkubGVuZ3RoIHx8IHZtLmZvb3Rlci5sZW5ndGg7XG5cblx0XHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdFx0Ly8gRHJhdyBCYWNrZ3JvdW5kXG5cdFx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplLCBvcGFjaXR5KTtcblxuXHRcdFx0XHQvLyBEcmF3IFRpdGxlLCBCb2R5LCBhbmQgRm9vdGVyXG5cdFx0XHRcdHB0LnggKz0gdm0ueFBhZGRpbmc7XG5cdFx0XHRcdHB0LnkgKz0gdm0ueVBhZGRpbmc7XG5cblx0XHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHRcdHRoaXMuZHJhd1RpdGxlKHB0LCB2bSwgY3R4LCBvcGFjaXR5KTtcblxuXHRcdFx0XHQvLyBCb2R5XG5cdFx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgsIG9wYWNpdHkpO1xuXG5cdFx0XHRcdC8vIEZvb3RlclxuXHRcdFx0XHR0aGlzLmRyYXdGb290ZXIocHQsIHZtLCBjdHgsIG9wYWNpdHkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0XHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IG1lLl9vcHRpb25zO1xuXHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG5cdFx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLl9hY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRcdGNoYW5nZWQgPSAhaGVscGVycy5hcnJheUVxdWFscyhtZS5fYWN0aXZlLCBtZS5fbGFzdEFjdGl2ZSk7XG5cblx0XHRcdC8vIElmIHRvb2x0aXAgZGlkbid0IGNoYW5nZSwgZG8gbm90IGhhbmRsZSB0aGUgdGFyZ2V0IGV2ZW50XG5cdFx0XHRpZiAoIWNoYW5nZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcblx0XHRcdFx0bWUuX2V2ZW50UG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0eDogZS54LFxuXHRcdFx0XHRcdHk6IGUueVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXG5cdFx0XHRcdC8vIFNlZSBpZiBvdXIgdG9vbHRpcCBwb3NpdGlvbiBjaGFuZ2VkXG5cdFx0XHRcdGNoYW5nZWQgfD0gKG1vZGVsLnggIT09IG1lLl9tb2RlbC54KSB8fCAobW9kZWwueSAhPT0gbWUuX21vZGVsLnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcblx0ICovXG5cdENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMgPSB7XG5cdFx0LyoqXG5cdFx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXG5cdFx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydEVsZW1lbnRbXX0gdGhlIGVsZW1lbnRzIGJlaW5nIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxuXHRcdCAqIEByZXR1cm5zIHtQb2ludH0gdG9vbHRpcCBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHR2YXIgeCA9IDA7XG5cdFx0XHR2YXIgeSA9IDA7XG5cdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0XHR2YXIgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0XHR5ICs9IHBvcy55O1xuXHRcdFx0XHRcdCsrY291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCh4IC8gY291bnQpLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKHkgLyBjb3VudClcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0XHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcblx0XHQgKiBAcGFyYW0gZXZlbnRQb3NpdGlvbiB7UG9pbnR9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdFx0ICogQHJldHVybnMge1BvaW50fSB0aGUgdG9vbHRpcCBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgeCA9IGV2ZW50UG9zaXRpb24ueDtcblx0XHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXG5cdFx0XHR2YXIgbmVhcmVzdEVsZW1lbnQ7XG5cdFx0XHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0XHR2YXIgaSwgbGVuO1xuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XG5cdFx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG5cdFx0XHRcdFx0dmFyIGQgPSBoZWxwZXJzLmRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG5cdFx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lYXJlc3RFbGVtZW50KSB7XG5cdFx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0XHR4ID0gdHAueDtcblx0XHRcdFx0eSA9IHRwLnk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycyxcblx0XHRnbG9iYWxPcHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdGdsb2JhbE9wdHMuZWxlbWVudHMuYXJjID0ge1xuXHRcdGJhY2tncm91bmRDb2xvcjogZ2xvYmFsT3B0cy5kZWZhdWx0Q29sb3IsXG5cdFx0Ym9yZGVyQ29sb3I6ICcjZmZmJyxcblx0XHRib3JkZXJXaWR0aDogMlxuXHR9O1xuXG5cdENoYXJ0LmVsZW1lbnRzLkFyYyA9IENoYXJ0LkVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdFx0aWYgKHZtKSB7XG5cdFx0XHRcdHJldHVybiAoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5ob3ZlclJhZGl1cywgMikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0aW5SYW5nZTogZnVuY3Rpb24oY2hhcnRYLCBjaGFydFkpIHtcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRcdGlmICh2bSkge1xuXHRcdFx0XHR2YXIgcG9pbnRSZWxhdGl2ZVBvc2l0aW9uID0gaGVscGVycy5nZXRBbmdsZUZyb21Qb2ludCh2bSwge1xuXHRcdFx0XHRcdFx0eDogY2hhcnRYLFxuXHRcdFx0XHRcdFx0eTogY2hhcnRZXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0YW5nbGUgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uYW5nbGUsXG5cdFx0XHRcdFx0ZGlzdGFuY2UgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uZGlzdGFuY2U7XG5cblx0XHRcdFx0Ly8gU2FuaXRpc2UgYW5nbGUgcmFuZ2Vcblx0XHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcblx0XHRcdFx0d2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKGFuZ2xlID4gZW5kQW5nbGUpIHtcblx0XHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChhbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgb3Blbi9jbG9zZSBhbmdsZVxuXHRcdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKSxcblx0XHRcdFx0XHR3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0XHR2YXIgaGFsZlJhZGl1cyA9ICh2bS5pbm5lclJhZGl1cyArIHZtLm91dGVyUmFkaXVzKSAvIDI7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHRcdHk6IHZtLnkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHJldHVybiBNYXRoLlBJICogKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gKDIgKiBNYXRoLlBJKSkgKiAoTWF0aC5wb3codm0ub3V0ZXJSYWRpdXMsIDIpIC0gTWF0aC5wb3codm0uaW5uZXJSYWRpdXMsIDIpKTtcblx0XHR9LFxuXHRcdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMiksXG5cdFx0XHRcdHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHZtLnggKyAoTWF0aC5jb3MoY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKSxcblx0XHRcdFx0eTogdm0ueSArIChNYXRoLnNpbihjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHgsXG5cdFx0XHRcdHZtID0gdGhpcy5fdmlldyxcblx0XHRcdFx0c0EgPSB2bS5zdGFydEFuZ2xlLFxuXHRcdFx0XHRlQSA9IHZtLmVuZEFuZ2xlO1xuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBLCBlQSk7XG5cdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblxuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdGN0eC5saW5lSm9pbiA9ICdiZXZlbCc7XG5cblx0XHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cdHZhciBnbG9iYWxEZWZhdWx0cyA9IENoYXJ0LmRlZmF1bHRzLmdsb2JhbDtcblxuXHRDaGFydC5kZWZhdWx0cy5nbG9iYWwuZWxlbWVudHMubGluZSA9IHtcblx0XHR0ZW5zaW9uOiAwLjQsXG5cdFx0YmFja2dyb3VuZENvbG9yOiBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3IsXG5cdFx0Ym9yZGVyV2lkdGg6IDMsXG5cdFx0Ym9yZGVyQ29sb3I6IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcixcblx0XHRib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG5cdFx0Y2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuXHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xuXHR9O1xuXG5cdENoYXJ0LmVsZW1lbnRzLkxpbmUgPSBDaGFydC5FbGVtZW50LmV4dGVuZCh7XG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHZtID0gbWUuX3ZpZXc7XG5cdFx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHRcdHZhciBzcGFuR2FwcyA9IHZtLnNwYW5HYXBzO1xuXHRcdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxuXHRcdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0XHR2YXIgbGFzdERyYXduSW5kZXggPSAtMTtcblx0XHRcdHZhciBpbmRleCwgY3VycmVudCwgcHJldmlvdXMsIGN1cnJlbnRWTTtcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRcdGlmIChtZS5fbG9vcCAmJiBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdC8vIFN0cm9rZSBMaW5lIE9wdGlvbnNcblx0XHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2bS5ib3JkZXJEYXNoT2Zmc2V0IHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlcldpZHRoO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXG5cdFx0XHQvLyBTdHJva2UgTGluZVxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0bGFzdERyYXduSW5kZXggPSAtMTtcblxuXHRcdFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuXHRcdFx0XHRjdXJyZW50ID0gcG9pbnRzW2luZGV4XTtcblx0XHRcdFx0cHJldmlvdXMgPSBoZWxwZXJzLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdFx0Y3VycmVudFZNID0gY3VycmVudC5fdmlldztcblxuXHRcdFx0XHQvLyBGaXJzdCBwb2ludCBtb3ZlcyB0byBpdCdzIHN0YXJ0aW5nIHBvc2l0aW9uIG5vIG1hdHRlciB3aGF0XG5cdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0XHRcdFx0aWYgKChsYXN0RHJhd25JbmRleCAhPT0gKGluZGV4IC0gMSkgJiYgIXNwYW5HYXBzKSB8fCBsYXN0RHJhd25JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0XHRoZWxwZXJzLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzLFxuXHRcdGdsb2JhbE9wdHMgPSBDaGFydC5kZWZhdWx0cy5nbG9iYWwsXG5cdFx0ZGVmYXVsdENvbG9yID0gZ2xvYmFsT3B0cy5kZWZhdWx0Q29sb3I7XG5cblx0Z2xvYmFsT3B0cy5lbGVtZW50cy5wb2ludCA9IHtcblx0XHRyYWRpdXM6IDMsXG5cdFx0cG9pbnRTdHlsZTogJ2NpcmNsZScsXG5cdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHQvLyBIb3ZlclxuXHRcdGhpdFJhZGl1czogMSxcblx0XHRob3ZlclJhZGl1czogNCxcblx0XHRob3ZlckJvcmRlcldpZHRoOiAxXG5cdH07XG5cblx0ZnVuY3Rpb24geFJhbmdlKG1vdXNlWCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtID8gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHlSYW5nZShtb3VzZVkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bSA/IChNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSA8IE1hdGgucG93KHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cywgMikpIDogZmFsc2U7XG5cdH1cblxuXHRDaGFydC5lbGVtZW50cy5Qb2ludCA9IENoYXJ0LkVsZW1lbnQuZXh0ZW5kKHtcblx0XHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0XHRpblhSYW5nZTogeFJhbmdlLFxuXHRcdGluWVJhbmdlOiB5UmFuZ2UsXG5cblx0XHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogdm0ueCxcblx0XHRcdFx0eTogdm0ueVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLl92aWV3LnJhZGl1cywgMik7XG5cdFx0fSxcblx0XHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHZtLngsXG5cdFx0XHRcdHk6IHZtLnksXG5cdFx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdFx0dmFyIG1vZGVsID0gdGhpcy5fbW9kZWw7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHBvaW50U3R5bGUgPSB2bS5wb2ludFN0eWxlO1xuXHRcdFx0dmFyIHJhZGl1cyA9IHZtLnJhZGl1cztcblx0XHRcdHZhciB4ID0gdm0ueDtcblx0XHRcdHZhciB5ID0gdm0ueTtcblx0XHRcdHZhciBjb2xvciA9IENoYXJ0LmhlbHBlcnMuY29sb3I7XG5cdFx0XHR2YXIgZXJyTWFyZ2luID0gMS4wMTsgLy8gMS4wMSBpcyBtYXJnaW4gZm9yIEFjY3VtdWxhdGVkIGVycm9yLiAoRXNwZWNpYWxseSBFZGdlLCBJRS4pXG5cdFx0XHR2YXIgcmF0aW8gPSAwO1xuXG5cdFx0XHRpZiAodm0uc2tpcCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGRlZmF1bHRDb2xvcjtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXG5cdFx0XHQvLyBDbGlwaW5nIGZvciBQb2ludHMuXG5cdFx0XHQvLyBnb2luZyBvdXQgZnJvbSBpbm5lciBjaGFyQXJlYT9cblx0XHRcdGlmICgoY2hhcnRBcmVhICE9PSB1bmRlZmluZWQpICYmICgobW9kZWwueCA8IGNoYXJ0QXJlYS5sZWZ0KSB8fCAoY2hhcnRBcmVhLnJpZ2h0KmVyck1hcmdpbiA8IG1vZGVsLngpIHx8IChtb2RlbC55IDwgY2hhcnRBcmVhLnRvcCkgfHwgKGNoYXJ0QXJlYS5ib3R0b20qZXJyTWFyZ2luIDwgbW9kZWwueSkpKSB7XG5cdFx0XHRcdC8vIFBvaW50IGZhZGUgb3V0XG5cdFx0XHRcdGlmIChtb2RlbC54IDwgY2hhcnRBcmVhLmxlZnQpIHtcblx0XHRcdFx0XHRyYXRpbyA9ICh4IC0gbW9kZWwueCkgLyAoY2hhcnRBcmVhLmxlZnQgLSBtb2RlbC54KTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGFydEFyZWEucmlnaHQqZXJyTWFyZ2luIDwgbW9kZWwueCkge1xuXHRcdFx0XHRcdHJhdGlvID0gKG1vZGVsLnggLSB4KSAvIChtb2RlbC54IC0gY2hhcnRBcmVhLnJpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChtb2RlbC55IDwgY2hhcnRBcmVhLnRvcCkge1xuXHRcdFx0XHRcdHJhdGlvID0gKHkgLSBtb2RlbC55KSAvIChjaGFydEFyZWEudG9wIC0gbW9kZWwueSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hhcnRBcmVhLmJvdHRvbSplcnJNYXJnaW4gPCBtb2RlbC55KSB7XG5cdFx0XHRcdFx0cmF0aW8gPSAobW9kZWwueSAtIHkpIC8gKG1vZGVsLnkgLSBjaGFydEFyZWEuYm90dG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYXRpbyA9IE1hdGgucm91bmQocmF0aW8qMTAwKSAvIDEwMDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY29sb3IoY3R4LnN0cm9rZVN0eWxlKS5hbHBoYShyYXRpbykucmdiU3RyaW5nKCk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBjb2xvcihjdHguZmlsbFN0eWxlKS5hbHBoYShyYXRpbykucmdiU3RyaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdENoYXJ0LmNhbnZhc0hlbHBlcnMuZHJhd1BvaW50KGN0eCwgcG9pbnRTdHlsZSwgcmFkaXVzLCB4LCB5KTtcblx0XHR9XG5cdH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBnbG9iYWxPcHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdGdsb2JhbE9wdHMuZWxlbWVudHMucmVjdGFuZ2xlID0ge1xuXHRcdGJhY2tncm91bmRDb2xvcjogZ2xvYmFsT3B0cy5kZWZhdWx0Q29sb3IsXG5cdFx0Ym9yZGVyV2lkdGg6IDAsXG5cdFx0Ym9yZGVyQ29sb3I6IGdsb2JhbE9wdHMuZGVmYXVsdENvbG9yLFxuXHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nXG5cdH07XG5cblx0ZnVuY3Rpb24gaXNWZXJ0aWNhbChiYXIpIHtcblx0XHRyZXR1cm4gYmFyLl92aWV3LndpZHRoICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIGJhciB7Q2hhcnQuRWxlbWVudC5SZWN0YW5nbGV9IHRoZSBiYXJcblx0ICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhcikge1xuXHRcdHZhciB2bSA9IGJhci5fdmlldztcblx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRpZiAoaXNWZXJ0aWNhbChiYXIpKSB7XG5cdFx0XHQvLyB2ZXJ0aWNhbFxuXHRcdFx0dmFyIGhhbGZXaWR0aCA9IHZtLndpZHRoIC8gMjtcblx0XHRcdHgxID0gdm0ueCAtIGhhbGZXaWR0aDtcblx0XHRcdHgyID0gdm0ueCArIGhhbGZXaWR0aDtcblx0XHRcdHkxID0gTWF0aC5taW4odm0ueSwgdm0uYmFzZSk7XG5cdFx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBob3Jpem9udGFsIGJhclxuXHRcdFx0dmFyIGhhbGZIZWlnaHQgPSB2bS5oZWlnaHQgLyAyO1xuXHRcdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHRcdHgyID0gTWF0aC5tYXgodm0ueCwgdm0uYmFzZSk7XG5cdFx0XHR5MSA9IHZtLnkgLSBoYWxmSGVpZ2h0O1xuXHRcdFx0eTIgPSB2bS55ICsgaGFsZkhlaWdodDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogeDEsXG5cdFx0XHR0b3A6IHkxLFxuXHRcdFx0cmlnaHQ6IHgyLFxuXHRcdFx0Ym90dG9tOiB5MlxuXHRcdH07XG5cdH1cblxuXHRDaGFydC5lbGVtZW50cy5SZWN0YW5nbGUgPSBDaGFydC5FbGVtZW50LmV4dGVuZCh7XG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHNpZ25YLCBzaWduWSwgYm9yZGVyU2tpcHBlZDtcblx0XHRcdHZhciBib3JkZXJXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXG5cdFx0XHRpZiAoIXZtLmhvcml6b250YWwpIHtcblx0XHRcdFx0Ly8gYmFyXG5cdFx0XHRcdGxlZnQgPSB2bS54IC0gdm0ud2lkdGggLyAyO1xuXHRcdFx0XHRyaWdodCA9IHZtLnggKyB2bS53aWR0aCAvIDI7XG5cdFx0XHRcdHRvcCA9IHZtLnk7XG5cdFx0XHRcdGJvdHRvbSA9IHZtLmJhc2U7XG5cdFx0XHRcdHNpZ25YID0gMTtcblx0XHRcdFx0c2lnblkgPSBib3R0b20gPiB0b3A/IDE6IC0xO1xuXHRcdFx0XHRib3JkZXJTa2lwcGVkID0gdm0uYm9yZGVyU2tpcHBlZCB8fCAnYm90dG9tJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGhvcml6b250YWwgYmFyXG5cdFx0XHRcdGxlZnQgPSB2bS5iYXNlO1xuXHRcdFx0XHRyaWdodCA9IHZtLng7XG5cdFx0XHRcdHRvcCA9IHZtLnkgLSB2bS5oZWlnaHQgLyAyO1xuXHRcdFx0XHRib3R0b20gPSB2bS55ICsgdm0uaGVpZ2h0IC8gMjtcblx0XHRcdFx0c2lnblggPSByaWdodCA+IGxlZnQ/IDE6IC0xO1xuXHRcdFx0XHRzaWduWSA9IDE7XG5cdFx0XHRcdGJvcmRlclNraXBwZWQgPSB2bS5ib3JkZXJTa2lwcGVkIHx8ICdsZWZ0Jztcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FudmFzIGRvZXNuJ3QgYWxsb3cgdXMgdG8gc3Ryb2tlIGluc2lkZSB0aGUgd2lkdGggc28gd2UgY2FuXG5cdFx0XHQvLyBhZGp1c3QgdGhlIHNpemVzIHRvIGZpdCBpZiB3ZSdyZSBzZXR0aW5nIGEgc3Ryb2tlIG9uIHRoZSBsaW5lXG5cdFx0XHRpZiAoYm9yZGVyV2lkdGgpIHtcblx0XHRcdFx0Ly8gYm9yZGVyV2lkdGggc2hvbGQgYmUgbGVzcyB0aGFuIGJhciB3aWR0aCBhbmQgYmFyIGhlaWdodC5cblx0XHRcdFx0dmFyIGJhclNpemUgPSBNYXRoLm1pbihNYXRoLmFicyhsZWZ0IC0gcmlnaHQpLCBNYXRoLmFicyh0b3AgLSBib3R0b20pKTtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCA+IGJhclNpemU/IGJhclNpemU6IGJvcmRlcldpZHRoO1xuXHRcdFx0XHR2YXIgaGFsZlN0cm9rZSA9IGJvcmRlcldpZHRoIC8gMjtcblx0XHRcdFx0Ly8gQWRqdXN0IGJvcmRlcldpZHRoIHdoZW4gYmFyIHRvcCBwb3NpdGlvbiBpcyBuZWFyIHZtLmJhc2UoemVybykuXG5cdFx0XHRcdHZhciBib3JkZXJMZWZ0ID0gbGVmdCArIChib3JkZXJTa2lwcGVkICE9PSAnbGVmdCc/IGhhbGZTdHJva2UgKiBzaWduWDogMCk7XG5cdFx0XHRcdHZhciBib3JkZXJSaWdodCA9IHJpZ2h0ICsgKGJvcmRlclNraXBwZWQgIT09ICdyaWdodCc/IC1oYWxmU3Ryb2tlICogc2lnblg6IDApO1xuXHRcdFx0XHR2YXIgYm9yZGVyVG9wID0gdG9wICsgKGJvcmRlclNraXBwZWQgIT09ICd0b3AnPyBoYWxmU3Ryb2tlICogc2lnblk6IDApO1xuXHRcdFx0XHR2YXIgYm9yZGVyQm90dG9tID0gYm90dG9tICsgKGJvcmRlclNraXBwZWQgIT09ICdib3R0b20nPyAtaGFsZlN0cm9rZSAqIHNpZ25ZOiAwKTtcblx0XHRcdFx0Ly8gbm90IGJlY29tZSBhIHZlcnRpY2FsIGxpbmU/XG5cdFx0XHRcdGlmIChib3JkZXJMZWZ0ICE9PSBib3JkZXJSaWdodCkge1xuXHRcdFx0XHRcdHRvcCA9IGJvcmRlclRvcDtcblx0XHRcdFx0XHRib3R0b20gPSBib3JkZXJCb3R0b207XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbm90IGJlY29tZSBhIGhvcml6b250YWwgbGluZT9cblx0XHRcdFx0aWYgKGJvcmRlclRvcCAhPT0gYm9yZGVyQm90dG9tKSB7XG5cdFx0XHRcdFx0bGVmdCA9IGJvcmRlckxlZnQ7XG5cdFx0XHRcdFx0cmlnaHQgPSBib3JkZXJSaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG5cblx0XHRcdC8vIENvcm5lciBwb2ludHMsIGZyb20gYm90dG9tLWxlZnQgdG8gYm90dG9tLXJpZ2h0IGNsb2Nrd2lzZVxuXHRcdFx0Ly8gfCAxIDIgfFxuXHRcdFx0Ly8gfCAwIDMgfFxuXHRcdFx0dmFyIGNvcm5lcnMgPSBbXG5cdFx0XHRcdFtsZWZ0LCBib3R0b21dLFxuXHRcdFx0XHRbbGVmdCwgdG9wXSxcblx0XHRcdFx0W3JpZ2h0LCB0b3BdLFxuXHRcdFx0XHRbcmlnaHQsIGJvdHRvbV1cblx0XHRcdF07XG5cblx0XHRcdC8vIEZpbmQgZmlyc3QgKHN0YXJ0aW5nKSBjb3JuZXIgd2l0aCBmYWxsYmFjayB0byAnYm90dG9tJ1xuXHRcdFx0dmFyIGJvcmRlcnMgPSBbJ2JvdHRvbScsICdsZWZ0JywgJ3RvcCcsICdyaWdodCddO1xuXHRcdFx0dmFyIHN0YXJ0Q29ybmVyID0gYm9yZGVycy5pbmRleE9mKGJvcmRlclNraXBwZWQsIDApO1xuXHRcdFx0aWYgKHN0YXJ0Q29ybmVyID09PSAtMSkge1xuXHRcdFx0XHRzdGFydENvcm5lciA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvcm5lckF0KGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiBjb3JuZXJzWyhzdGFydENvcm5lciArIGluZGV4KSAlIDRdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IHJlY3RhbmdsZSBmcm9tICdzdGFydENvcm5lcidcblx0XHRcdHZhciBjb3JuZXIgPSBjb3JuZXJBdCgwKTtcblx0XHRcdGN0eC5tb3ZlVG8oY29ybmVyWzBdLCBjb3JuZXJbMV0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRjb3JuZXIgPSBjb3JuZXJBdChpKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhjb3JuZXJbMF0sIGNvcm5lclsxXSk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRpZiAoYm9yZGVyV2lkdGgpIHtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdFx0fSxcblx0XHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdFx0dmFyIGluUmFuZ2UgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHRoaXMuX3ZpZXcpIHtcblx0XHRcdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh0aGlzKTtcblx0XHRcdFx0aW5SYW5nZSA9IG1vdXNlWCA+PSBib3VuZHMubGVmdCAmJiBtb3VzZVggPD0gYm91bmRzLnJpZ2h0ICYmIG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW5SYW5nZTtcblx0XHR9LFxuXHRcdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluUmFuZ2UgPSBmYWxzZTtcblx0XHRcdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHMobWUpO1xuXG5cdFx0XHRpZiAoaXNWZXJ0aWNhbChtZSkpIHtcblx0XHRcdFx0aW5SYW5nZSA9IG1vdXNlWCA+PSBib3VuZHMubGVmdCAmJiBtb3VzZVggPD0gYm91bmRzLnJpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5SYW5nZSA9IG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW5SYW5nZTtcblx0XHR9LFxuXHRcdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModGhpcyk7XG5cdFx0XHRyZXR1cm4gbW91c2VYID49IGJvdW5kcy5sZWZ0ICYmIG1vdXNlWCA8PSBib3VuZHMucmlnaHQ7XG5cdFx0fSxcblx0XHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHRoaXMpO1xuXHRcdFx0cmV0dXJuIG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xuXHRcdH0sXG5cdFx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHZhciB4LCB5O1xuXHRcdFx0aWYgKGlzVmVydGljYWwodGhpcykpIHtcblx0XHRcdFx0eCA9IHZtLng7XG5cdFx0XHRcdHkgPSAodm0ueSArIHZtLmJhc2UpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcblx0XHRcdFx0eSA9IHZtLnk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7eDogeCwgeTogeX07XG5cdFx0fSxcblx0XHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0XHRyZXR1cm4gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSk7XG5cdFx0fSxcblx0XHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHZtLngsXG5cdFx0XHRcdHk6IHZtLnlcblx0XHRcdH07XG5cdFx0fVxuXHR9KTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblxuXHQvLyBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG5cdC8vIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuXHR2YXIgZXZlbnRUeXBlTWFwID0ge1xuXHRcdC8vIFRvdWNoIGV2ZW50c1xuXHRcdHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuXHRcdHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG5cdFx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblxuXHRcdC8vIFBvaW50ZXIgZXZlbnRzXG5cdFx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdFx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuXHRcdHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcblx0XHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0XHRwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG5cdFx0cG9pbnRlcm91dDogJ21vdXNlb3V0J1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG5cdCAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG5cdCAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcblx0ICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcblx0ICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cblx0ICovXG5cdGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuXHRcdHZhciB2YWx1ZSA9IGhlbHBlcnMuZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHRcdHZhciBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG5cdFx0cmV0dXJuIG1hdGNoZXM/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcblx0ICogc2luY2UgcmVzcG9uc2l2ZW5lc3MgaXMgaGFuZGxlZCBieSB0aGUgY29udHJvbGxlci5yZXNpemUoKSBtZXRob2QuIFRoZSBjb25maWcgaXMgdXNlZFxuXHQgKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgY29uZmlnKSB7XG5cdFx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdFx0Ly8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuXHRcdC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG5cdFx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHRcdHZhciByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cblx0XHQvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuXHRcdGNhbnZhcy5fY2hhcnRqcyA9IHtcblx0XHRcdGluaXRpYWw6IHtcblx0XHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHRcdHdpZHRoOiByZW5kZXJXaWR0aCxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHRcdHdpZHRoOiBzdHlsZS53aWR0aFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0XHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1Mzhcblx0XHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdFx0aWYgKHJlbmRlcldpZHRoID09PSBudWxsIHx8IHJlbmRlcldpZHRoID09PSAnJykge1xuXHRcdFx0dmFyIGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuXHRcdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVuZGVySGVpZ2h0ID09PSBudWxsIHx8IHJlbmRlckhlaWdodCA9PT0gJycpIHtcblx0XHRcdGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuXHRcdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHRcdC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuXHRcdFx0XHQvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuXHRcdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjYW52YXM7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgeCwgeSwgbmF0aXZlRXZlbnQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdG5hdGl2ZTogbmF0aXZlRXZlbnQgfHwgbnVsbCxcblx0XHRcdHg6IHggIT09IHVuZGVmaW5lZD8geCA6IG51bGwsXG5cdFx0XHR5OiB5ICE9PSB1bmRlZmluZWQ/IHkgOiBudWxsLFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdFx0dmFyIHR5cGUgPSBldmVudFR5cGVNYXBbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0XHR2YXIgcG9zID0gaGVscGVycy5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCBwb3MueCwgcG9zLnksIGV2ZW50KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaGFuZGxlcikge1xuXHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRpZnJhbWUuY2xhc3NOYW1lID0gJ2NoYXJ0anMtaGlkZGVuLWlmcmFtZSc7XG5cdFx0aWZyYW1lLnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0J2Rpc3BsYXk6YmxvY2s7Jytcblx0XHRcdCdvdmVyZmxvdzpoaWRkZW47Jytcblx0XHRcdCdib3JkZXI6MDsnK1xuXHRcdFx0J21hcmdpbjowOycrXG5cdFx0XHQndG9wOjA7Jytcblx0XHRcdCdsZWZ0OjA7Jytcblx0XHRcdCdib3R0b206MDsnK1xuXHRcdFx0J3JpZ2h0OjA7Jytcblx0XHRcdCdoZWlnaHQ6MTAwJTsnK1xuXHRcdFx0J3dpZHRoOjEwMCU7Jytcblx0XHRcdCdwb3NpdGlvbjphYnNvbHV0ZTsnK1xuXHRcdFx0J3BvaW50ZXItZXZlbnRzOm5vbmU7Jytcblx0XHRcdCd6LWluZGV4Oi0xOyc7XG5cblx0XHQvLyBQcmV2ZW50IHRoZSBpZnJhbWUgdG8gZ2FpbiBmb2N1cyBvbiB0YWIuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzMwOTBcblx0XHRpZnJhbWUudGFiSW5kZXggPSAtMTtcblxuXHRcdC8vIElmIHRoZSBpZnJhbWUgaXMgcmUtYXR0YWNoZWQgdG8gdGhlIERPTSwgdGhlIHJlc2l6ZSBsaXN0ZW5lciBpcyByZW1vdmVkIGJlY2F1c2UgdGhlXG5cdFx0Ly8gY29udGVudCBpcyByZWxvYWRlZCwgc28gbWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIGhhbmRsZXIgYWZ0ZXIgdGhlIGlmcmFtZSBpcyBsb2FkZWQuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1MjFcblx0XHRoZWxwZXJzLmFkZEV2ZW50KGlmcmFtZSwgJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdGhlbHBlcnMuYWRkRXZlbnQoaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLCAncmVzaXplJywgaGFuZGxlcik7XG5cblx0XHRcdC8vIFRoZSBpZnJhbWUgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQgd2hpbGUgbG9hZGluZywgd2hpY2ggY2FuIGFsc29cblx0XHRcdC8vIGhhcHBlbiBpZiB0aGUgc2l6ZSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGRldGFjaGVkIGZyb20gdGhlIERPTS5cblx0XHRcdGhhbmRsZXIoKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBpZnJhbWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRSZXNpemVMaXN0ZW5lcihub2RlLCBsaXN0ZW5lciwgY2hhcnQpIHtcblx0XHR2YXIgc3R1YiA9IG5vZGUuX2NoYXJ0anMgPSB7XG5cdFx0XHR0aWNraW5nOiBmYWxzZVxuXHRcdH07XG5cblx0XHQvLyBUaHJvdHRsZSB0aGUgY2FsbGJhY2sgbm90aWZpY2F0aW9uIHVudGlsIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cblx0XHR2YXIgbm90aWZ5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXN0dWIudGlja2luZykge1xuXHRcdFx0XHRzdHViLnRpY2tpbmcgPSB0cnVlO1xuXHRcdFx0XHRoZWxwZXJzLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChzdHViLnJlc2l6ZXIpIHtcblx0XHRcdFx0XHRcdHN0dWIudGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExldCdzIGtlZXAgdHJhY2sgb2YgdGhpcyBhZGRlZCBpZnJhbWUgYW5kIHRodXMgYXZvaWQgRE9NIHF1ZXJ5IHdoZW4gcmVtb3ZpbmcgaXQuXG5cdFx0c3R1Yi5yZXNpemVyID0gY3JlYXRlUmVzaXplcihub3RpZnkpO1xuXG5cdFx0bm9kZS5pbnNlcnRCZWZvcmUoc3R1Yi5yZXNpemVyLCBub2RlLmZpcnN0Q2hpbGQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHRcdGlmICghbm9kZSB8fCAhbm9kZS5fY2hhcnRqcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciByZXNpemVyID0gbm9kZS5fY2hhcnRqcy5yZXNpemVyO1xuXHRcdGlmIChyZXNpemVyKSB7XG5cdFx0XHRyZXNpemVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzaXplcik7XG5cdFx0XHRub2RlLl9jaGFydGpzLnJlc2l6ZXIgPSBudWxsO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBub2RlLl9jaGFydGpzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbS5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRcdGl0ZW0gPSBpdGVtWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG5cdFx0XHQvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdHZhciBjb250ZXh0ID0gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcblx0XHRcdC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG5cdFx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRcdGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBpdGVtKSB7XG5cdFx0XHRcdGluaXRDYW52YXMoaXRlbSwgY29uZmlnKTtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dmFyIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuXHRcdFx0aWYgKCFjYW52YXMuX2NoYXJ0anMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5pdGlhbCA9IGNhbnZhcy5fY2hhcnRqcy5pbml0aWFsO1xuXHRcdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycy5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcblx0XHRcdC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuXHRcdFx0Ly8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG5cdFx0XHRjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cblx0XHRcdGRlbGV0ZSBjYW52YXMuX2NoYXJ0anM7XG5cdFx0fSxcblxuXHRcdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMucGFyZW50Tm9kZSwgbGlzdGVuZXIsIGNoYXJ0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3R1YiA9IGxpc3RlbmVyLl9jaGFydGpzIHx8IChsaXN0ZW5lci5fY2hhcnRqcyA9IHt9KTtcblx0XHRcdHZhciBwcm94aWVzID0gc3R1Yi5wcm94aWVzIHx8IChzdHViLnByb3hpZXMgPSB7fSk7XG5cdFx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRoZWxwZXJzLmFkZEV2ZW50KGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzLnBhcmVudE5vZGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3R1YiA9IGxpc3RlbmVyLl9jaGFydGpzIHx8IHt9O1xuXHRcdFx0dmFyIHByb3hpZXMgPSBzdHViLnByb3hpZXMgfHwge307XG5cdFx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XG5cdFx0XHRpZiAoIXByb3h5KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aGVscGVycy5yZW1vdmVFdmVudChjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0XHR9XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBCeSBkZWZhdWx0LCBzZWxlY3QgdGhlIGJyb3dzZXIgKERPTSkgcGxhdGZvcm0uXG4vLyBAVE9ETyBNYWtlIHBvc3NpYmxlIHRvIHNlbGVjdCBhbm90aGVyIHBsYXRmb3JtIGF0IGJ1aWxkIHRpbWUuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL3BsYXRmb3JtLmRvbS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG5cdCAqIEBzZWUgaHR0cHM6Ly9jaGFydGpzLmdpdGJvb2tzLmlvL3Byb3Bvc2Fscy9jb250ZW50L1BsYXRmb3JtLmh0bWxcblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqL1xuXHRDaGFydC5wbGF0Zm9ybSA9IHtcblx0XHQvKipcblx0XHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdFx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdFx0ICogQHBhcmFtIHsqfSBpdGVtIC0gVGhlIG5hdGl2ZSBpdGVtIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBjaGFydCBvcHRpb25zXG5cdFx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0XHQvKipcblx0XHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdFx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdFx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdFx0ICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0XHQgKi9cblx0XHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHRcdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0XHQgKi9cblx0XHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLUNoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHRcdCAqL1xuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cblx0fTtcblxuXHQvKipcblx0ICogQGludGVyZmFjZSBJUGxhdGZvcm1cblx0ICogQWxsb3dzIGFic3RyYWN0aW5nIHBsYXRmb3JtIGRlcGVuZGVuY2llcyBhd2F5IGZyb20gdGhlIGNoYXJ0XG5cdCAqIEBib3Jyb3dzIENoYXJ0LnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0IGFzIGFjcXVpcmVDb250ZXh0XG5cdCAqIEBib3Jyb3dzIENoYXJ0LnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0IGFzIHJlbGVhc2VDb250ZXh0XG5cdCAqIEBib3Jyb3dzIENoYXJ0LnBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIgYXMgYWRkRXZlbnRMaXN0ZW5lclxuXHQgKiBAYm9ycm93cyBDaGFydC5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXJcblx0ICovXG5cblx0LyoqXG5cdCAqIEBpbnRlcmZhY2UgSUV2ZW50XG5cdCAqIEBwcm9wIHtTdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZSBuYW1lLCBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuXHQgKiAnY29udGV4dG1lbnUnLCAnbW91c2VlbnRlcicsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnbW91c2VvdXQnLFxuXHQgKiAnY2xpY2snLCAnZGJsY2xpY2snLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcgYW5kICdyZXNpemUnXG5cdCAqIEBwcm9wIHsqfSBuYXRpdmUgLSBUaGUgb3JpZ2luYWwgbmF0aXZlIGV2ZW50IChudWxsIGZvciBlbXVsYXRlZCBldmVudHMsIGUuZy4gJ3Jlc2l6ZScpXG5cdCAqIEBwcm9wIHtOdW1iZXJ9IHggLSBUaGUgbW91c2UgeCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAobnVsbCBmb3IgaW5jb21wYXRpYmxlIGV2ZW50cylcblx0ICogQHByb3Age051bWJlcn0geSAtIFRoZSBtb3VzZSB5IHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgY2FudmFzIChudWxsIGZvciBpbmNvbXBhdGlibGUgZXZlbnRzKVxuXHQgKi9cblxuXHRDaGFydC5oZWxwZXJzLmV4dGVuZChDaGFydC5wbGF0Zm9ybSwgaW1wbGVtZW50YXRpb24oQ2hhcnQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblx0LyoqXG5cdCAqIFBsdWdpbiBiYXNlZCBvbiBkaXNjdXNzaW9uIGZyb20gdGhlIGZvbGxvd2luZyBDaGFydC5qcyBpc3N1ZXM6XG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcblx0ICovXG5cdENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5wbHVnaW5zLmZpbGxlciA9IHtcblx0XHRwcm9wYWdhdGU6IHRydWVcblx0fTtcblxuXHR2YXIgZGVmYXVsdHMgPSBDaGFydC5kZWZhdWx0cztcblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXHR2YXIgbWFwcGVycyA9IHtcblx0XHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHZhciBpbmRleCA9IHNvdXJjZS5maWxsO1xuXHRcdFx0dmFyIGNoYXJ0ID0gc291cmNlLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0XHR2YXIgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG5cdFx0XHR2YXIgcG9pbnRzID0gKHZpc2libGUgJiYgbWV0YS5kYXRhc2V0Ll9jaGlsZHJlbikgfHwgW107XG5cblx0XHRcdHJldHVybiAhcG9pbnRzLmxlbmd0aD8gbnVsbCA6IGZ1bmN0aW9uKHBvaW50LCBpKSB7XG5cdFx0XHRcdHJldHVybiBwb2ludHNbaV0uX3ZpZXcgfHwgbnVsbDtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGJvdW5kYXJ5OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHZhciBib3VuZGFyeSA9IHNvdXJjZS5ib3VuZGFyeTtcblx0XHRcdHZhciB4ID0gYm91bmRhcnk/IGJvdW5kYXJ5LnggOiBudWxsO1xuXHRcdFx0dmFyIHkgPSBib3VuZGFyeT8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHg6IHggPT09IG51bGw/IHBvaW50LnggOiB4LFxuXHRcdFx0XHRcdHk6IHkgPT09IG51bGw/IHBvaW50LnkgOiB5LFxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQHRvZG8gaWYgKGZpbGxbMF0gPT09ICcjJylcblx0ZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdFx0dmFyIG1vZGVsID0gZWwuX21vZGVsIHx8IHt9O1xuXHRcdHZhciBmaWxsID0gbW9kZWwuZmlsbDtcblx0XHR2YXIgdGFyZ2V0O1xuXG5cdFx0aWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZmlsbCA9ICEhbW9kZWwuYmFja2dyb3VuZENvbG9yO1xuXHRcdH1cblxuXHRcdGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGZpbGwgPT09IHRydWUpIHtcblx0XHRcdHJldHVybiAnb3JpZ2luJztcblx0XHR9XG5cblx0XHR0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwsIDEwKTtcblx0XHRpZiAoaXNGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuXHRcdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdFx0dGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGZpbGwpIHtcblx0XHQvLyBjb21wYXRpYmlsaXR5XG5cdFx0Y2FzZSAnYm90dG9tJzpcblx0XHRcdHJldHVybiAnc3RhcnQnO1xuXHRcdGNhc2UgJ3RvcCc6XG5cdFx0XHRyZXR1cm4gJ2VuZCc7XG5cdFx0Y2FzZSAnemVybyc6XG5cdFx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdFx0Ly8gc3VwcG9ydGVkIGJvdW5kYXJpZXNcblx0XHRjYXNlICdvcmlnaW4nOlxuXHRcdGNhc2UgJ3N0YXJ0Jzpcblx0XHRjYXNlICdlbmQnOlxuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuXHRcdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdFx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcblx0XHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciB0YXJnZXQgPSBudWxsO1xuXHRcdHZhciBob3Jpem9udGFsO1xuXG5cdFx0aWYgKGlzRmluaXRlKGZpbGwpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiB1bnRpbCB2Mywgd2Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IGJvdW5kYXJ5IHZhbHVlcyBzZXQgb25cblx0XHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0XHQvLyBjb250cm9sbGVycyBtaWdodCBzdGlsbCB1c2UgaXQgKGUuZy4gdGhlIFNtaXRoIGNoYXJ0KS5cblxuXHRcdGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG5cdFx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkPyBzY2FsZS5ib3R0b20gOiBtb2RlbC5zY2FsZUJvdHRvbTtcblx0XHR9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG5cdFx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcblx0XHR9IGVsc2UgaWYgKG1vZGVsLnNjYWxlWmVybyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdFx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUG9zaXRpb24pIHtcblx0XHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQb3NpdGlvbigpO1xuXHRcdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0XHRpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR4OiBob3Jpem9udGFsPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHRcdHk6IGhvcml6b250YWw/IG51bGwgOiB0YXJnZXRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuXHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0XHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciB2aXNpdGVkID0gW2luZGV4XTtcblx0XHR2YXIgdGFyZ2V0O1xuXG5cdFx0aWYgKCFwcm9wYWdhdGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG5cdFx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0XHRcdHJldHVybiBmaWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0XHR9XG5cblx0XHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVNYXBwZXIoc291cmNlKSB7XG5cdFx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgdHlwZSA9ICdkYXRhc2V0JztcblxuXHRcdGlmIChmaWxsID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuXHRcdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hcHBlcnNbdHlwZV0oc291cmNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgJiYgIXBvaW50LnNraXA7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKSB7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdFx0Y3R4Lm1vdmVUbyhjdXJ2ZTBbMF0ueCwgY3VydmUwWzBdLnkpO1xuXHRcdGZvciAoaT0xOyBpPGxlbjA7ICsraSkge1xuXHRcdFx0aGVscGVycy5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2ktMV0sIGN1cnZlMFtpXSk7XG5cdFx0fVxuXG5cdFx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXG5cdFx0Y3R4LmxpbmVUbyhjdXJ2ZTFbbGVuMS0xXS54LCBjdXJ2ZTFbbGVuMS0xXS55KTtcblxuXHRcdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXG5cdFx0Zm9yIChpPWxlbjEtMTsgaT4wOyAtLWkpIHtcblx0XHRcdGhlbHBlcnMuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMVtpXSwgY3VydmUxW2ktMV0sIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xuXHRcdHZhciBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHRcdHZhciBjdXJ2ZTAgPSBbXTtcblx0XHR2YXIgY3VydmUxID0gW107XG5cdFx0dmFyIGxlbjAgPSAwO1xuXHRcdHZhciBsZW4xID0gMDtcblx0XHR2YXIgaSwgaWxlbiwgaW5kZXgsIHAwLCBwMSwgZDAsIGQxO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjb3VudCArICEhbG9vcCk7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGluZGV4ID0gaSVjb3VudDtcblx0XHRcdHAwID0gcG9pbnRzW2luZGV4XS5fdmlldztcblx0XHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XG5cdFx0XHRkMCA9IGlzRHJhd2FibGUocDApO1xuXHRcdFx0ZDEgPSBpc0RyYXdhYmxlKHAxKTtcblxuXHRcdFx0aWYgKGQwICYmIGQxKSB7XG5cdFx0XHRcdGxlbjAgPSBjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRcdGxlbjEgPSBjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbjAgJiYgbGVuMSkge1xuXHRcdFx0XHRpZiAoIXNwYW4pIHtcblx0XHRcdFx0XHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblx0XHRcdFx0XHRsZW4wID0gbGVuMSA9IDA7XG5cdFx0XHRcdFx0Y3VydmUwID0gW107XG5cdFx0XHRcdFx0Y3VydmUxID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGQwKSB7XG5cdFx0XHRcdFx0XHRjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkMSkge1xuXHRcdFx0XHRcdFx0Y3VydmUxLnB1c2gocDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHRjdHguZmlsbCgpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRpZDogJ2ZpbGxlcicsXG5cblx0XHRhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcblx0XHRcdHZhciBwcm9wYWdhdGUgPSBvcHRpb25zLnByb3BhZ2F0ZTtcblx0XHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0XHR2YXIgbWV0YSwgaSwgZWwsIHNvdXJjZTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRlbCA9IG1ldGEuZGF0YXNldDtcblx0XHRcdFx0c291cmNlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgQ2hhcnQuZWxlbWVudHMuTGluZSkge1xuXHRcdFx0XHRcdHNvdXJjZSA9IHtcblx0XHRcdFx0XHRcdHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXG5cdFx0XHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdFx0XHRlbDogZWxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWV0YS4kZmlsbGVyID0gc291cmNlO1xuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpPTA7IGk8Y291bnQ7ICsraSkge1xuXHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c291cmNlLmZpbGwgPSByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIHByb3BhZ2F0ZSk7XG5cdFx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZURhdGFzZXREcmF3OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuXHRcdFx0dmFyIG1ldGEgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblx0XHRcdGlmICghbWV0YSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBlbCA9IG1ldGEuZWw7XG5cdFx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdFx0dmFyIHBvaW50cyA9IGVsLl9jaGlsZHJlbiB8fCBbXTtcblx0XHRcdHZhciBtYXBwZXIgPSBtZXRhLm1hcHBlcjtcblx0XHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cblx0XHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRkb0ZpbGwoY2hhcnQuY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXHR2YXIgbGF5b3V0ID0gQ2hhcnQubGF5b3V0U2VydmljZTtcblx0dmFyIG5vb3AgPSBoZWxwZXJzLm5vb3A7XG5cblx0Q2hhcnQuZGVmYXVsdHMuZ2xvYmFsLmxlZ2VuZCA9IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0d2VpZ2h0OiAxMDAwLFxuXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxuXHRcdFx0bWV0YS5oaWRkZW4gPSBtZXRhLmhpZGRlbiA9PT0gbnVsbD8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XG5cblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxuXHRcdFx0Y2kudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycy5pc0FycmF5KGRhdGEuZGF0YXNldHMpID8gZGF0YS5kYXRhc2V0cy5tYXAoZnVuY3Rpb24oZGF0YXNldCwgaSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0ZXh0OiBkYXRhc2V0LmxhYmVsLFxuXHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiAoIWhlbHBlcnMuaXNBcnJheShkYXRhc2V0LmJhY2tncm91bmRDb2xvcikgPyBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA6IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yWzBdKSxcblx0XHRcdFx0XHRcdGhpZGRlbjogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBkYXRhc2V0LmJvcmRlckNhcFN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZURhc2g6IGRhdGFzZXQuYm9yZGVyRGFzaCxcblx0XHRcdFx0XHRcdGxpbmVEYXNoT2Zmc2V0OiBkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogZGF0YXNldC5ib3JkZXJKb2luU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGRhdGFzZXQuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogZGF0YXNldC5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IGRhdGFzZXQucG9pbnRTdHlsZSxcblxuXHRcdFx0XHRcdFx0Ly8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcblx0XHRcdFx0XHRcdGRhdGFzZXRJbmRleDogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sIHRoaXMpIDogW107XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3ggd2lkdGggYmFzZWQgb24gdGhlIHVzZVBvaW50U3R5bGUgb3B0aW9uXG5cdCAqIEBwYXJhbSBsYWJlbG9wdHMge09iamVjdH0gdGhlIGxhYmVsIG9wdGlvbnMgb24gdGhlIGxlZ2VuZFxuXHQgKiBAcGFyYW0gZm9udFNpemUge051bWJlcn0gdGhlIGxhYmVsIGZvbnQgc2l6ZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSkge1xuXHRcdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSA/XG5cdFx0XHRmb250U2l6ZSAqIE1hdGguU1FSVDIgOlxuXHRcdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xuXHR9XG5cblx0Q2hhcnQuTGVnZW5kID0gQ2hhcnQuRWxlbWVudC5leHRlbmQoe1xuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZCh0aGlzLCBjb25maWcpO1xuXG5cdFx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHRcdHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdFx0Ly8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuXHRcdFx0dGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0XHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgbGVnZW5kIHR5cGVzLlxuXHRcdC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIGxlZ2VuZCB0eXBlXG5cblx0XHRiZWZvcmVVcGRhdGU6IG5vb3AsXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0XHQvLyBEaW1lbnNpb25zXG5cdFx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblx0XHRcdC8vIExhYmVsc1xuXHRcdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRcdG1lLmJ1aWxkTGFiZWxzKCk7XG5cdFx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHRcdC8vIEZpdFxuXHRcdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0XHRtZS5maXQoKTtcblx0XHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0XHQvL1xuXHRcdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cdFx0fSxcblx0XHRhZnRlclVwZGF0ZTogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wLFxuXHRcdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0XHQvLyBSZXNldCBtaW5TaXplXG5cdFx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wLFxuXHRcdGJ1aWxkTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbGFiZWxPcHRzID0gbWUub3B0aW9ucy5sYWJlbHM7XG5cdFx0XHR2YXIgbGVnZW5kSXRlbXMgPSBsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMuY2FsbChtZSwgbWUuY2hhcnQpO1xuXG5cdFx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuXHRcdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgbWUuY2hhcnQuZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUub3B0aW9ucy5yZXZlcnNlKSB7XG5cdFx0XHRcdGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0bWUubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcblx0XHR9LFxuXHRcdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlRml0OiBub29wLFxuXHRcdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xuXHRcdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cblx0XHRcdHZhciBnbG9iYWxEZWZhdWx0ID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdFx0XHRpdGVtT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCxcblx0XHRcdFx0Zm9udFNpemUgPSBpdGVtT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdFx0XHRmb250U3R5bGUgPSBpdGVtT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHQuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHRcdGZvbnRGYW1pbHkgPSBpdGVtT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdFx0bGFiZWxGb250ID0gaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xuXG5cdFx0XHQvLyBSZXNldCBoaXQgYm94ZXNcblx0XHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxuXHRcdFx0aWYgKGRpc3BsYXkpIHtcblx0XHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQ7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG5cdFx0XHRcdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzID0gWzBdO1xuXHRcdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IG1lLmxlZ2VuZEl0ZW1zLmxlbmd0aCA/IGZvbnRTaXplICsgKGxhYmVsT3B0cy5wYWRkaW5nKSA6IDA7XG5cblx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHRcdGlmIChsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID49IG1lLndpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgKGxhYmVsT3B0cy5wYWRkaW5nKTtcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aF0gPSBtZS5sZWZ0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IHRvdGFsSGVpZ2h0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHZQYWRkaW5nID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IG1lLmNvbHVtbldpZHRocyA9IFtdO1xuXHRcdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0XHR2YXIgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ID4gbWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTsgLy8gcHJldmlvdXMgY29sdW1uIHdpZHRoXG5cblx0XHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodDtcblxuXHRcdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcblx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRcdG1pblNpemUud2lkdGggKz0gdG90YWxXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0XHR9LFxuXHRcdGFmdGVyRml0OiBub29wLFxuXG5cdFx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0XHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgbGVnZW5kIG9uIHRoZSBjYW52YXNcblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0XHR2YXIgZ2xvYmFsRGVmYXVsdCA9IENoYXJ0LmRlZmF1bHRzLmdsb2JhbCxcblx0XHRcdFx0bGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0LmVsZW1lbnRzLmxpbmUsXG5cdFx0XHRcdGxlZ2VuZFdpZHRoID0gbWUud2lkdGgsXG5cdFx0XHRcdGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzO1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBjdHggPSBtZS5jdHgsXG5cdFx0XHRcdFx0Y3Vyc29yLFxuXHRcdFx0XHRcdGl0ZW1PckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0LFxuXHRcdFx0XHRcdGZvbnRDb2xvciA9IGl0ZW1PckRlZmF1bHQobGFiZWxPcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Rm9udENvbG9yKSxcblx0XHRcdFx0XHRmb250U2l6ZSA9IGl0ZW1PckRlZmF1bHQobGFiZWxPcHRzLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRcdFx0Zm9udFN0eWxlID0gaXRlbU9yRGVmYXVsdChsYWJlbE9wdHMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0XHRcdGZvbnRGYW1pbHkgPSBpdGVtT3JEZWZhdWx0KGxhYmVsT3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0LmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdFx0XHRsYWJlbEZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSk7XG5cblx0XHRcdFx0Ly8gQ2FudmFzIHNldHVwXG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDAuNTtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3Rcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRcdGN0eC5mb250ID0gbGFiZWxGb250O1xuXG5cdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpLFxuXHRcdFx0XHRcdGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdFx0Ly8gY3VycmVudCBwb3NpdGlvblxuXHRcdFx0XHR2YXIgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gaXRlbU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRcdGN0eC5saW5lQ2FwID0gaXRlbU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsIGxpbmVEZWZhdWx0LmJvcmRlckNhcFN0eWxlKTtcblx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBpdGVtT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdFx0XHRcdGN0eC5saW5lSm9pbiA9IGl0ZW1PckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gaXRlbU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGl0ZW1PckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZ2xvYmFsRGVmYXVsdC5kZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRcdHZhciBpc0xpbmVXaWR0aFplcm8gPSAoaXRlbU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpID09PSAwKTtcblxuXHRcdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGl0ZW1PckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRzLmxhYmVscyAmJiBvcHRzLmxhYmVscy51c2VQb2ludFN0eWxlKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3Rpbmdcblx0XHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHRcdHZhciByYWRpdXMgPSBmb250U2l6ZSAqIE1hdGguU1FSVDIgLyAyO1xuXHRcdFx0XHRcdFx0dmFyIG9mZlNldCA9IHJhZGl1cyAvIE1hdGguU1FSVDI7XG5cdFx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBvZmZTZXQ7XG5cdFx0XHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBvZmZTZXQ7XG5cblx0XHRcdFx0XHRcdC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0XHRDaGFydC5jYW52YXNIZWxwZXJzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuXHRcdFx0XHRcdFx0aWYgKCFpc0xpbmVXaWR0aFplcm8pIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdCh4LCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyB4LCB5KTtcblxuXHRcdFx0XHRcdGlmIChsZWdlbmRJdGVtLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAyO1xuXHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyhib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgeCwgeSArIChmb250U2l6ZSAvIDIpKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIHggKyB0ZXh0V2lkdGgsIHkgKyAoZm9udFNpemUgLyAyKSk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHRcdFx0eDogbWUubGVmdCArICgobGVnZW5kV2lkdGggLSBsaW5lV2lkdGhzWzBdKSAvIDIpLFxuXHRcdFx0XHRcdFx0eTogbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRoZWxwZXJzLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGgsXG5cdFx0XHRcdFx0XHR3aWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyB0ZXh0V2lkdGgsXG5cdFx0XHRcdFx0XHR4ID0gY3Vyc29yLngsXG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnk7XG5cblx0XHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0XHRpZiAoeCArIHdpZHRoID49IGxlZ2VuZFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRjdXJzb3IubGluZSsrO1xuXHRcdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeSArIGl0ZW1IZWlnaHQgPiBtZS5ib3R0b20pIHtcblx0XHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgPSBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZHJhd0xlZ2VuZEJveCh4LCB5LCBsZWdlbmRJdGVtKTtcblxuXHRcdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRcdGhpdGJveGVzW2ldLnRvcCA9IHk7XG5cblx0XHRcdFx0XHQvLyBGaWxsIHRoZSBhY3R1YWwgbGFiZWxcblx0XHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdFx0Y3Vyc29yLnggKz0gd2lkdGggKyAobGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBvY2N1cmVkXG5cdFx0ICovXG5cdFx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2NsaWNrJyA6IGUudHlwZTtcblx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0XHRpZiAoIW9wdHMub25Ib3Zlcikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdGlmICghb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG5cdFx0XHR2YXIgeCA9IGUueCxcblx0XHRcdFx0eSA9IGUueTtcblxuXHRcdFx0aWYgKHggPj0gbWUubGVmdCAmJiB4IDw9IG1lLnJpZ2h0ICYmIHkgPj0gbWUudG9wICYmIHkgPD0gbWUuYm90dG9tKSB7XG5cdFx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRcdHZhciBsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdFx0aWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xuXHRcdFx0XHRcdFx0Ly8gVG91Y2hpbmcgYW4gZWxlbWVudFxuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIGUubmF0aXZlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRvcHRzLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmxlZ2VuZEl0ZW1zW2ldKTtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUubGVnZW5kSXRlbXNbaV0pO1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IG5ldyBDaGFydC5MZWdlbmQoe1xuXHRcdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0XHRvcHRpb25zOiBsZWdlbmRPcHRzLFxuXHRcdFx0Y2hhcnQ6IGNoYXJ0XG5cdFx0fSk7XG5cblx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdGxheW91dC5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG5cdFx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRpZDogJ2xlZ2VuZCcsXG5cblx0XHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcblxuXHRcdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcblx0XHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRcdGlmIChsZWdlbmRPcHRzKSB7XG5cdFx0XHRcdGxlZ2VuZE9wdHMgPSBoZWxwZXJzLmNvbmZpZ01lcmdlKENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5sZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXG5cdFx0XHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdFx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRcdGxlZ2VuZC5vcHRpb25zID0gbGVnZW5kT3B0cztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRsYXlvdXQucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0XHRkZWxldGUgY2hhcnQubGVnZW5kO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblx0XHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cdHZhciBsYXlvdXQgPSBDaGFydC5sYXlvdXRTZXJ2aWNlO1xuXHR2YXIgbm9vcCA9IGhlbHBlcnMubm9vcDtcblxuXHRDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUgPSB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHR3ZWlnaHQ6IDIwMDAsICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0cGFkZGluZzogMTAsXG5cblx0XHQvLyBhY3R1YWwgdGl0bGVcblx0XHR0ZXh0OiAnJ1xuXHR9O1xuXG5cdENoYXJ0LlRpdGxlID0gQ2hhcnQuRWxlbWVudC5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKG1lLCBjb25maWcpO1xuXG5cdFx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdFx0fSxcblxuXHRcdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cblx0XHRiZWZvcmVVcGRhdGU6IG5vb3AsXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0XHQvLyBEaW1lbnNpb25zXG5cdFx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblx0XHRcdC8vIExhYmVsc1xuXHRcdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRcdG1lLmJ1aWxkTGFiZWxzKCk7XG5cdFx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHRcdC8vIEZpdFxuXHRcdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0XHRtZS5maXQoKTtcblx0XHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0XHQvL1xuXHRcdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0XHR9LFxuXHRcdGFmdGVyVXBkYXRlOiBub29wLFxuXG5cdFx0Ly9cblxuXHRcdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AsXG5cdFx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AsXG5cblx0XHQvL1xuXG5cdFx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AsXG5cdFx0YnVpbGRMYWJlbHM6IG5vb3AsXG5cdFx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCxcblxuXHRcdC8vXG5cblx0XHRiZWZvcmVGaXQ6IG5vb3AsXG5cdFx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXMsXG5cdFx0XHRcdHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCxcblx0XHRcdFx0b3B0cyA9IG1lLm9wdGlvbnMsXG5cdFx0XHRcdGdsb2JhbERlZmF1bHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdFx0XHRkaXNwbGF5ID0gb3B0cy5kaXNwbGF5LFxuXHRcdFx0XHRmb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRcdG1pblNpemUgPSBtZS5taW5TaXplO1xuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gZm9udFNpemUgKyAob3B0cy5wYWRkaW5nICogMikgOiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyBmb250U2l6ZSArIChvcHRzLnBhZGRpbmcgKiAyKSA6IDA7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0XHR9XG5cblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXG5cdFx0fSxcblx0XHRhZnRlckZpdDogbm9vcCxcblxuXHRcdC8vIFNoYXJlZCBNZXRob2RzXG5cdFx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cdFx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWxseSBkcmF3IHRoZSB0aXRsZSBibG9jayBvbiB0aGUgY2FudmFzXG5cdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzLFxuXHRcdFx0XHRjdHggPSBtZS5jdHgsXG5cdFx0XHRcdHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCxcblx0XHRcdFx0b3B0cyA9IG1lLm9wdGlvbnMsXG5cdFx0XHRcdGdsb2JhbERlZmF1bHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBmb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0XHRcdFx0Zm9udFN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0XHRcdGZvbnRGYW1pbHkgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdFx0XHR0aXRsZUZvbnQgPSBoZWxwZXJzLmZvbnRTdHJpbmcoZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSksXG5cdFx0XHRcdFx0cm90YXRpb24gPSAwLFxuXHRcdFx0XHRcdHRpdGxlWCxcblx0XHRcdFx0XHR0aXRsZVksXG5cdFx0XHRcdFx0dG9wID0gbWUudG9wLFxuXHRcdFx0XHRcdGxlZnQgPSBtZS5sZWZ0LFxuXHRcdFx0XHRcdGJvdHRvbSA9IG1lLmJvdHRvbSxcblx0XHRcdFx0XHRyaWdodCA9IG1lLnJpZ2h0LFxuXHRcdFx0XHRcdG1heFdpZHRoO1xuXG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0XHRjdHguZm9udCA9IHRpdGxlRm9udDtcblxuXHRcdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdFx0dGl0bGVZID0gdG9wICsgKChib3R0b20gLSB0b3ApIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSBoZWlnaHRcblx0XHRcdFx0XHRtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgKGZvbnRTaXplIC8gMikgOiByaWdodCAtIChmb250U2l6ZSAvIDIpO1xuXHRcdFx0XHRcdHRpdGxlWSA9IHRvcCArICgoYm90dG9tIC0gdG9wKSAvIDIpO1xuXHRcdFx0XHRcdG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuXHRcdFx0XHRcdHJvdGF0aW9uID0gTWF0aC5QSSAqIChvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyAtMC41IDogMC41KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xuXHRcdFx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChvcHRzLnRleHQsIDAsIDAsIG1heFdpZHRoKTtcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cykge1xuXHRcdHZhciB0aXRsZSA9IG5ldyBDaGFydC5UaXRsZSh7XG5cdFx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRcdG9wdGlvbnM6IHRpdGxlT3B0cyxcblx0XHRcdGNoYXJ0OiBjaGFydFxuXHRcdH0pO1xuXG5cdFx0bGF5b3V0LmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG5cdFx0bGF5b3V0LmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRcdGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0aWQ6ICd0aXRsZScsXG5cblx0XHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cblx0XHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cdFx0XHR2YXIgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG5cblx0XHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdFx0dGl0bGVPcHRzID0gaGVscGVycy5jb25maWdNZXJnZShDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUsIHRpdGxlT3B0cyk7XG5cblx0XHRcdFx0aWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdFx0XHRsYXlvdXQuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHRcdHRpdGxlQmxvY2sub3B0aW9ucyA9IHRpdGxlT3B0cztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdFx0Q2hhcnQubGF5b3V0U2VydmljZS5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuXHRcdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XG5cblx0dmFyIGhlbHBlcnMgPSBDaGFydC5oZWxwZXJzO1xuXHQvLyBEZWZhdWx0IGNvbmZpZyBmb3IgYSBjYXRlZ29yeSBzY2FsZVxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0fTtcblxuXHR2YXIgRGF0YXNldFNjYWxlID0gQ2hhcnQuU2NhbGUuZXh0ZW5kKHtcblx0XHQvKipcblx0XHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHRcdCogZWxzZSBmYWxsIGJhY2sgdG8gZGF0YS5sYWJlbHNcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRnZXRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG5cdFx0XHRyZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzO1xuXHRcdH0sXG5cblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHRtZS5taW5JbmRleCA9IDA7XG5cdFx0XHRtZS5tYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuXHRcdFx0dmFyIGZpbmRJbmRleDtcblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWluIHZhbHVlXG5cdFx0XHRcdGZpbmRJbmRleCA9IGhlbHBlcnMuaW5kZXhPZihsYWJlbHMsIG1lLm9wdGlvbnMudGlja3MubWluKTtcblx0XHRcdFx0bWUubWluSW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWluSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxuXHRcdFx0XHRmaW5kSW5kZXggPSBoZWxwZXJzLmluZGV4T2YobGFiZWxzLCBtZS5vcHRpb25zLnRpY2tzLm1heCk7XG5cdFx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5taW4gPSBsYWJlbHNbbWUubWluSW5kZXhdO1xuXHRcdFx0bWUubWF4ID0gbGFiZWxzW21lLm1heEluZGV4XTtcblx0XHR9LFxuXG5cdFx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdFx0Ly8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcblx0XHRcdG1lLnRpY2tzID0gKG1lLm1pbkluZGV4ID09PSAwICYmIG1lLm1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWUubWluSW5kZXgsIG1lLm1heEluZGV4ICsgMSk7XG5cdFx0fSxcblxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdGlmIChkYXRhLnlMYWJlbHMgJiYgIWlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRyZXR1cm4gbWUuZ2V0UmlnaHRWYWx1ZShkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lLnRpY2tzW2luZGV4IC0gbWUubWluSW5kZXhdO1xuXHRcdH0sXG5cblx0XHQvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0XHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCwgaW5jbHVkZU9mZnNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdC8vIDEgaXMgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBsZW5ndGggYnV0IHdlIGhhdmUgdGhlIGluZGV4ZXNcblx0XHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUubWF4SW5kZXggKyAxIC0gbWUubWluSW5kZXggLSAoKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykgPyAwIDogMSkpLCAxKTtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBkYXRhIG9iamVjdCwgdGhlbiBpbmRleCBpcyB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXksXG5cdFx0XHQvLyBub3QgdGhlIGluZGV4IG9mIHRoZSBzY2FsZS4gV2UgbmVlZCB0byBjaGFuZ2UgdGhhdC5cblx0XHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWVDYXRlZ29yeSA9IG1lLmlzSG9yaXpvbnRhbCgpID8gdmFsdWUueCA6IHZhbHVlLnk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcblx0XHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHRcdHZhciBpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dmFyIHZhbHVlV2lkdGggPSBtZS53aWR0aCAvIG9mZnNldEFtdDtcblx0XHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRcdGlmIChtZS5vcHRpb25zLmdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMgJiYgaW5jbHVkZU9mZnNldCB8fCBtZS5tYXhJbmRleCA9PT0gbWUubWluSW5kZXggJiYgaW5jbHVkZU9mZnNldCkge1xuXHRcdFx0XHRcdHdpZHRoT2Zmc2V0ICs9ICh2YWx1ZVdpZHRoIC8gMik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWUubGVmdCArIE1hdGgucm91bmQod2lkdGhPZmZzZXQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHZhbHVlSGVpZ2h0ID0gbWUuaGVpZ2h0IC8gb2Zmc2V0QW10O1xuXHRcdFx0dmFyIGhlaWdodE9mZnNldCA9ICh2YWx1ZUhlaWdodCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSk7XG5cblx0XHRcdGlmIChtZS5vcHRpb25zLmdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMgJiYgaW5jbHVkZU9mZnNldCkge1xuXHRcdFx0XHRoZWlnaHRPZmZzZXQgKz0gKHZhbHVlSGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS50b3AgKyBNYXRoLnJvdW5kKGhlaWdodE9mZnNldCk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4LCBpbmNsdWRlT2Zmc2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwsIGluY2x1ZGVPZmZzZXQpO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb2Zmc2V0QW10ID0gTWF0aC5tYXgoKG1lLnRpY2tzLmxlbmd0aCAtICgobWUub3B0aW9ucy5ncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzKSA/IDAgOiAxKSksIDEpO1xuXHRcdFx0dmFyIGhvcnogPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHZhciB2YWx1ZURpbWVuc2lvbiA9IChob3J6ID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gb2Zmc2V0QW10O1xuXG5cdFx0XHRwaXhlbCAtPSBob3J6ID8gbWUubGVmdCA6IG1lLnRvcDtcblxuXHRcdFx0aWYgKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykge1xuXHRcdFx0XHRwaXhlbCAtPSAodmFsdWVEaW1lbnNpb24gLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBpeGVsIDw9IDApIHtcblx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHBpeGVsIC8gdmFsdWVEaW1lbnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSxcblx0XHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xuXHRcdH1cblx0fSk7XG5cblx0Q2hhcnQuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKCdjYXRlZ29yeScsIERhdGFzZXRTY2FsZSwgZGVmYXVsdENvbmZpZyk7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHR0aWNrczoge1xuXHRcdFx0Y2FsbGJhY2s6IENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBMaW5lYXJTY2FsZSA9IENoYXJ0LkxpbmVhclNjYWxlQmFzZS5leHRlbmQoe1xuXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHRcdHZhciBERUZBVUxUX01BWCA9IDE7XG5cblx0XHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlyc3QgQ2FsY3VsYXRlIHRoZSByYW5nZVxuXHRcdFx0bWUubWluID0gbnVsbDtcblx0XHRcdG1lLm1heCA9IG51bGw7XG5cblx0XHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XG5cdFx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpICYmXG5cdFx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcblx0XHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdFx0dmFyIGtleSA9IFtcblx0XHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdCgob3B0cy5zdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSA/IGRhdGFzZXRJbmRleCA6ICcnKSxcblx0XHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzOiBbXSxcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXM6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZXNlIHBlciB0eXBlXG5cdFx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0XHR2YXIgbmVnYXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLm5lZ2F0aXZlVmFsdWVzO1xuXG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSBwb3NpdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdID0gbmVnYXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzRm9yVHlwZS5wb3NpdGl2ZVZhbHVlcy5jb25jYXQodmFsdWVzRm9yVHlwZS5uZWdhdGl2ZVZhbHVlcyk7XG5cdFx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMubWluKHZhbHVlcyk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMubWF4KHZhbHVlcyk7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWluID09PSBudWxsID8gbWluVmFsIDogTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgbWUubWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bWUubWluID0gaXNGaW5pdGUobWUubWluKSA/IG1lLm1pbiA6IERFRkFVTFRfTUlOO1xuXHRcdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0XHR9LFxuXHRcdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWF4VGlja3M7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCA/IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgOiAxMSwgTWF0aC5jZWlsKG1lLndpZHRoIC8gNTApKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFRoZSBmYWN0b3Igb2YgMiB1c2VkIHRvIHNjYWxlIHRoZSBmb250IHNpemUgaGFzIGJlZW4gZXhwZXJpbWVudGFsbHkgZGV0ZXJtaW5lZC5cblx0XHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRtYXhUaWNrcyA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgPyB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IDogMTEsIE1hdGguY2VpbChtZS5oZWlnaHQgLyAoMiAqIHRpY2tGb250U2l6ZSkpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1heFRpY2tzO1xuXHRcdH0sXG5cdFx0Ly8gQ2FsbGVkIGFmdGVyIHRoZSB0aWNrcyBhcmUgYnVpbHQuIFdlIG5lZWRcblx0XHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdC8vIFdlIGFyZSBpbiBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLiBUaGUgdG9wIHZhbHVlIGlzIHRoZSBoaWdoZXN0LiBTbyByZXZlcnNlIHRoZSBhcnJheVxuXHRcdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXHRcdC8vIFV0aWxzXG5cdFx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0XHQvLyB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCBhbmQgdGhpcy5ib3R0b20gaGF2ZSBiZWVuIGRlZmluZWRcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdFx0dmFyIHJpZ2h0VmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR2YXIgcGl4ZWw7XG5cdFx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHBpeGVsID0gbWUubGVmdCArIChtZS53aWR0aCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChwaXhlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQocGl4ZWwpO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSAoaXNIb3Jpem9udGFsID8gcGl4ZWwgLSBtZS5sZWZ0IDogbWUuYm90dG9tIC0gcGl4ZWwpIC8gaW5uZXJEaW1lbnNpb247XG5cdFx0XHRyZXR1cm4gbWUuc3RhcnQgKyAoKG1lLmVuZCAtIG1lLnN0YXJ0KSAqIG9mZnNldCk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblx0XHR9XG5cdH0pO1xuXHRDaGFydC5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUoJ2xpbmVhcicsIExpbmVhclNjYWxlLCBkZWZhdWx0Q29uZmlnKTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycyxcblx0XHRub29wID0gaGVscGVycy5ub29wO1xuXG5cdENoYXJ0LkxpbmVhclNjYWxlQmFzZSA9IENoYXJ0LlNjYWxlLmV4dGVuZCh7XG5cdFx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcblx0XHRcdC8vIGF4aXMsIHRoZXkgY2FuIG1hbnVhbGx5IG92ZXJyaWRlIGl0XG5cdFx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzLnNpZ24obWUubWluKTtcblx0XHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzLnNpZ24obWUubWF4KTtcblxuXHRcdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlIHRoZSB0b3AgdXAgdG8gMFxuXHRcdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcblx0XHRcdFx0XHQvLyBtb3ZlIHRoZSBib3R0b20gZG93biB0byAwXG5cdFx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bWUubWluID0gdGlja09wdHMubWluO1xuXHRcdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0bWUubWluID0gdGlja09wdHMuc3VnZ2VzdGVkTWluO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMubWF4O1xuXHRcdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMuc3VnZ2VzdGVkTWF4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0XHRcdG1lLm1pbi0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXRUaWNrTGltaXQ6IG5vb3AsXG5cdFx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBub29wLFxuXG5cdFx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG5cdFx0XHQvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNTBcblx0XHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG5cdFx0XHR2YXIgbWF4VGlja3MgPSBtZS5nZXRUaWNrTGltaXQoKTtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG5cdFx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcblx0XHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRcdG1heDogdGlja09wdHMubWF4LFxuXHRcdFx0XHRzdGVwU2l6ZTogaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHRcdH07XG5cdFx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IENoYXJ0LlRpY2tzLmdlbmVyYXRvcnMubGluZWFyKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBtZSk7XG5cblx0XHRcdG1lLmhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcygpO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRcdG1lLm1heCA9IGhlbHBlcnMubWF4KHRpY2tzKTtcblx0XHRcdG1lLm1pbiA9IGhlbHBlcnMubWluKHRpY2tzKTtcblxuXHRcdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0XHRtZS5lbmQgPSBtZS5taW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdFx0bWUuZW5kID0gbWUubWF4O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xuXG5cdFx0XHRDaGFydC5TY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cblx0dmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdFx0cG9zaXRpb246ICdsZWZ0JyxcblxuXHRcdC8vIGxhYmVsIHNldHRpbmdzXG5cdFx0dGlja3M6IHtcblx0XHRcdGNhbGxiYWNrOiBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBMb2dhcml0aG1pY1NjYWxlID0gQ2hhcnQuU2NhbGUuZXh0ZW5kKHtcblx0XHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdFx0dmFyIGdldFZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdDtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0XHRtZS5taW4gPSBudWxsO1xuXHRcdFx0bWUubWF4ID0gbnVsbDtcblx0XHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXNQZXJTdGFjayA9IHt9O1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0XHRtZXRhLnR5cGUsXG5cdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0XHRtZXRhLnN0YWNrXG5cdFx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgbmVlZCB0byBzcGxpdCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgc2luY2UgdGhlIGxvZyBzY2FsZSBjYW4ndCBoYW5kbGUgYSAwIGNyb3NzaW5nXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRoZWxwZXJzLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycy5taW4odmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdFx0aGVscGVycy5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT09IDAgJiYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwgfHwgdmFsdWUgPCBtZS5taW5Ob3RaZXJvKSkge1xuXHRcdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bWUubWluID0gZ2V0VmFsdWVPckRlZmF1bHQodGlja09wdHMubWluLCBtZS5taW4pO1xuXHRcdFx0bWUubWF4ID0gZ2V0VmFsdWVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKG1lLm1pbiAhPT0gMCAmJiBtZS5taW4gIT09IG51bGwpIHtcblx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzLmxvZzEwKG1lLm1pbikpIC0gMSk7XG5cdFx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycy5sb2cxMChtZS5tYXgpKSArIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1pbiA9IDE7XG5cdFx0XHRcdFx0bWUubWF4ID0gMTA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRcdHZhciBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcblx0XHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRcdG1heDogdGlja09wdHMubWF4XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBDaGFydC5UaWNrcy5nZW5lcmF0b3JzLmxvZ2FyaXRobWljKGdlbmVyYXRpb25PcHRpb25zLCBtZSk7XG5cblx0XHRcdGlmICghbWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0XHRtZS5tYXggPSBoZWxwZXJzLm1heCh0aWNrcyk7XG5cdFx0XHRtZS5taW4gPSBoZWxwZXJzLm1pbih0aWNrcyk7XG5cblx0XHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblxuXHRcdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdFx0Q2hhcnQuU2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdFx0fSxcblx0XHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxuXHRcdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9LFxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrVmFsdWVzW2luZGV4XSk7XG5cdFx0fSxcblx0XHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBpbm5lckRpbWVuc2lvbjtcblx0XHRcdHZhciBwaXhlbDtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHR2YXIgbmV3VmFsID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdFx0dmFyIHJhbmdlO1xuXHRcdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHJhbmdlID0gaGVscGVycy5sb2cxMChtZS5lbmQpIC0gaGVscGVycy5sb2cxMChzdGFydCk7IC8vIHRvZG86IGlmIHN0YXJ0ID09PSAwXG5cdFx0XHRcdGlmIChuZXdWYWwgPT09IDApIHtcblx0XHRcdFx0XHRwaXhlbCA9IG1lLmxlZnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdFx0XHRwaXhlbCA9IG1lLmxlZnQgKyAoaW5uZXJEaW1lbnNpb24gLyByYW5nZSAqIChoZWxwZXJzLmxvZzEwKG5ld1ZhbCkgLSBoZWxwZXJzLmxvZzEwKHN0YXJ0KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBCb3R0b20gLSB0b3Agc2luY2UgcGl4ZWxzIGluY3JlYXNlIGRvd253YXJkIG9uIGEgc2NyZWVuXG5cdFx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAoc3RhcnQgPT09IDAgJiYgIXRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuZW5kKSAtIGhlbHBlcnMubG9nMTAobWUubWluTm90WmVybyk7XG5cdFx0XHRcdFx0aWYgKG5ld1ZhbCA9PT0gc3RhcnQpIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUuYm90dG9tO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmV3VmFsID09PSBtZS5taW5Ob3RaZXJvKSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLmJvdHRvbSAtIGlubmVyRGltZW5zaW9uICogMC4wMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSBpbm5lckRpbWVuc2lvbiAqIDAuMDIgLSAoaW5uZXJEaW1lbnNpb24gKiAwLjk4LyByYW5nZSAqIChoZWxwZXJzLmxvZzEwKG5ld1ZhbCktaGVscGVycy5sb2cxMChtZS5taW5Ob3RaZXJvKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChtZS5lbmQgPT09IDAgJiYgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHJhbmdlID0gaGVscGVycy5sb2cxMChtZS5zdGFydCkgLSBoZWxwZXJzLmxvZzEwKG1lLm1pbk5vdFplcm8pO1xuXHRcdFx0XHRcdGlmIChuZXdWYWwgPT09IG1lLmVuZCkge1xuXHRcdFx0XHRcdFx0cGl4ZWwgPSBtZS50b3A7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChuZXdWYWwgPT09IG1lLm1pbk5vdFplcm8pIHtcblx0XHRcdFx0XHRcdHBpeGVsID0gbWUudG9wICsgaW5uZXJEaW1lbnNpb24gKiAwLjAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwaXhlbCA9IG1lLnRvcCArIGlubmVyRGltZW5zaW9uICogMC4wMiArIChpbm5lckRpbWVuc2lvbiAqIDAuOTgvIHJhbmdlICogKGhlbHBlcnMubG9nMTAobmV3VmFsKS1oZWxwZXJzLmxvZzEwKG1lLm1pbk5vdFplcm8pKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG5ld1ZhbCA9PT0gMCkge1xuXHRcdFx0XHRcdHBpeGVsID0gdGlja09wdHMucmV2ZXJzZSA/IG1lLnRvcCA6IG1lLmJvdHRvbTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyYW5nZSA9IGhlbHBlcnMubG9nMTAobWUuZW5kKSAtIGhlbHBlcnMubG9nMTAoc3RhcnQpO1xuXHRcdFx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKGlubmVyRGltZW5zaW9uIC8gcmFuZ2UgKiAoaGVscGVycy5sb2cxMChuZXdWYWwpIC0gaGVscGVycy5sb2cxMChzdGFydCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgcmFuZ2UgPSBoZWxwZXJzLmxvZzEwKG1lLmVuZCkgLSBoZWxwZXJzLmxvZzEwKG1lLnN0YXJ0KTtcblx0XHRcdHZhciB2YWx1ZSwgaW5uZXJEaW1lbnNpb247XG5cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0XHR2YWx1ZSA9IG1lLnN0YXJ0ICogTWF0aC5wb3coMTAsIChwaXhlbCAtIG1lLmxlZnQpICogcmFuZ2UgLyBpbm5lckRpbWVuc2lvbik7XG5cdFx0XHR9IGVsc2UgeyAgLy8gdG9kbzogaWYgc3RhcnQgPT09IDBcblx0XHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS5oZWlnaHQ7XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5wb3coMTAsIChtZS5ib3R0b20gLSBwaXhlbCkgKiByYW5nZSAvIGlubmVyRGltZW5zaW9uKSAvIG1lLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSk7XG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgnbG9nYXJpdGhtaWMnLCBMb2dhcml0aG1pY1NjYWxlLCBkZWZhdWx0Q29uZmlnKTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDaGFydCkge1xuXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcblx0dmFyIGdsb2JhbERlZmF1bHRzID0gQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdHZhciBkZWZhdWx0Q29uZmlnID0ge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGU6IHRydWUsXG5cdFx0cG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG5cdFx0YW5nbGVMaW5lczoge1xuXHRcdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcblx0XHRcdGxpbmVXaWR0aDogMVxuXHRcdH0sXG5cblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGNpcmN1bGFyOiBmYWxzZVxuXHRcdH0sXG5cblx0XHQvLyBsYWJlbCBzZXR0aW5nc1xuXHRcdHRpY2tzOiB7XG5cdFx0XHQvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuXHRcdFx0c2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cblx0XHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXG5cdFx0XHRiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjc1KScsXG5cblx0XHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdFx0YmFja2Ryb3BQYWRkaW5nWTogMixcblxuXHRcdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgdG8gdGhlIHNpZGUgb2YgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdFx0YmFja2Ryb3BQYWRkaW5nWDogMixcblxuXHRcdFx0Y2FsbGJhY2s6IENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0fSxcblxuXHRcdHBvaW50TGFiZWxzOiB7XG5cdFx0XHQvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcblx0XHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHRcdC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcblx0XHRcdGZvbnRTaXplOiAxMCxcblxuXHRcdFx0Ly8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG5cdFx0XHRjYWxsYmFjazogZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBnZXRWYWx1ZUNvdW50KHNjYWxlKSB7XG5cdFx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHRcdHJldHVybiBvcHRzLmFuZ2xlTGluZXMuZGlzcGxheSB8fCBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkgPyBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggOiAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zKHNjYWxlKSB7XG5cdFx0dmFyIHBvaW50TGFiZWxPcHRpb25zID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcblx0XHR2YXIgZm9udFNpemUgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHBvaW50TGFiZWxPcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdHZhciBmb250U3R5bGUgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHBvaW50TGFiZWxPcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSk7XG5cdFx0dmFyIGZvbnRGYW1pbHkgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHBvaW50TGFiZWxPcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KTtcblx0XHR2YXIgZm9udCA9IGhlbHBlcnMuZm9udFN0cmluZyhmb250U2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRzaXplOiBmb250U2l6ZSxcblx0XHRcdHN0eWxlOiBmb250U3R5bGUsXG5cdFx0XHRmYW1pbHk6IGZvbnRGYW1pbHksXG5cdFx0XHRmb250OiBmb250XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250U2l6ZSwgbGFiZWwpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxhYmVsKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dzogaGVscGVycy5sb25nZXN0VGV4dChjdHgsIGN0eC5mb250LCBsYWJlbCksXG5cdFx0XHRcdGg6IChsYWJlbC5sZW5ndGggKiBmb250U2l6ZSkgKyAoKGxhYmVsLmxlbmd0aCAtIDEpICogMS41ICogZm9udFNpemUpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR3OiBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxuXHRcdFx0aDogZm9udFNpemVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG5cdFx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG5cdFx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGFydDogcG9zIC0gc2l6ZSAtIDUsXG5cdFx0XHRcdGVuZDogcG9zXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogcG9zLFxuXHRcdFx0ZW5kOiBwb3MgKyBzaXplICsgNVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcblx0ICovXG5cdGZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXHRcdC8qXG5cdFx0ICogUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuXHRcdCAqIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuXHRcdCAqXG5cdFx0ICogUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuXHRcdCAqXG5cdFx0ICogU29sdXRpb246XG5cdFx0ICpcblx0XHQgKiBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3Rcblx0XHQgKiBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuXHRcdCAqXG5cdFx0ICogV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cblx0XHQgKlxuXHRcdCAqIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuXHRcdCAqIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cblx0XHQgKlxuXHRcdCAqIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG5cdFx0ICogYWxvbmcgd2l0aCBsYWJlbHMuXG5cdFx0ICpcblx0XHQgKiBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG5cdFx0ICogb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG5cdFx0ICpcblx0XHQgKiBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcblx0XHQgKiBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuXHRcdCAqXG5cdFx0ICogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cdFx0ICovXG5cblx0XHR2YXIgcGxGb250ID0gZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zKHNjYWxlKTtcblxuXHRcdC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuXHRcdC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuXHRcdHZhciBsYXJnZXN0UG9zc2libGVSYWRpdXMgPSBNYXRoLm1pbihzY2FsZS5oZWlnaHQgLyAyLCBzY2FsZS53aWR0aCAvIDIpO1xuXHRcdHZhciBmdXJ0aGVzdExpbWl0cyA9IHtcblx0XHRcdHI6IHNjYWxlLndpZHRoLFxuXHRcdFx0bDogMCxcblx0XHRcdHQ6IHNjYWxlLmhlaWdodCxcblx0XHRcdGI6IDBcblx0XHR9O1xuXHRcdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuXHRcdHZhciBpO1xuXHRcdHZhciB0ZXh0U2l6ZTtcblx0XHR2YXIgcG9pbnRQb3NpdGlvbjtcblxuXHRcdHNjYWxlLmN0eC5mb250ID0gcGxGb250LmZvbnQ7XG5cdFx0c2NhbGUuX3BvaW50TGFiZWxTaXplcyA9IFtdO1xuXG5cdFx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG5cdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBsYXJnZXN0UG9zc2libGVSYWRpdXMpO1xuXHRcdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LnNpemUsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnKTtcblx0XHRcdHNjYWxlLl9wb2ludExhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuXHRcdFx0Ly8gQWRkIHF1YXJ0ZXIgY2lyY2xlIHRvIG1ha2UgZGVncmVlIDAgbWVhbiB0b3Agb2YgY2lyY2xlXG5cdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHRcdHZhciBhbmdsZSA9IGhlbHBlcnMudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0XHR2YXIgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuXHRcdFx0dmFyIHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG5cblx0XHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0XHRmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcblx0XHRcdFx0ZnVydGhlc3RBbmdsZXMubCA9IGFuZ2xlUmFkaWFucztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMucikge1xuXHRcdFx0XHRmdXJ0aGVzdExpbWl0cy5yID0gaExpbWl0cy5lbmQ7XG5cdFx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2TGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMudCkge1xuXHRcdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdFx0ZnVydGhlc3RBbmdsZXMudCA9IGFuZ2xlUmFkaWFucztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0XHRmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XG5cdFx0XHRcdGZ1cnRoZXN0QW5nbGVzLmIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2NhbGUuc2V0UmVkdWN0aW9ucyhsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcyk7XG5cdH1cblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBubyBwb2ludCBsYWJlbHNcblx0ICovXG5cdGZ1bmN0aW9uIGZpdChzY2FsZSkge1xuXHRcdHZhciBsYXJnZXN0UG9zc2libGVSYWRpdXMgPSBNYXRoLm1pbihzY2FsZS5oZWlnaHQgLyAyLCBzY2FsZS53aWR0aCAvIDIpO1xuXHRcdHNjYWxlLmRyYXdpbmdBcmVhID0gTWF0aC5yb3VuZChsYXJnZXN0UG9zc2libGVSYWRpdXMpO1xuXHRcdHNjYWxlLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcblx0XHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdFx0cmV0dXJuICdjZW50ZXInO1xuXHRcdH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcblx0XHRcdHJldHVybiAnbGVmdCc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdyaWdodCc7XG5cdH1cblxuXHRmdW5jdGlvbiBmaWxsVGV4dChjdHgsIHRleHQsIHBvc2l0aW9uLCBmb250U2l6ZSkge1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkodGV4dCkpIHtcblx0XHRcdHZhciB5ID0gcG9zaXRpb24ueTtcblx0XHRcdHZhciBzcGFjaW5nID0gMS41ICogZm9udFNpemU7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHRcdHkrPSBzcGFjaW5nO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCB0ZXh0U2l6ZSwgcG9zaXRpb24pIHtcblx0XHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcblx0XHR9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcblx0XHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0XHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xuXHRcdHZhciBnZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQ7XG5cdFx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHRcdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xuXHRcdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XG5cblx0XHRjdHgubGluZVdpZHRoID0gYW5nbGVMaW5lT3B0cy5saW5lV2lkdGg7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gYW5nbGVMaW5lT3B0cy5jb2xvcjtcblxuXHRcdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHRcdC8vIFBvaW50IExhYmVsIEZvbnRcblx0XHR2YXIgcGxGb250ID0gZ2V0UG9pbnRMYWJlbEZvbnRPcHRpb25zKHNjYWxlKTtcblxuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdGZvciAodmFyIGkgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAoYW5nbGVMaW5lT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBvdXRlclBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIpO1xuXHRcdFx0XHRjdHgubGluZVRvKG91dGVyUG9zaXRpb24ueCwgb3V0ZXJQb3NpdGlvbi55KTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIEV4dHJhIDNweCBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xuXHRcdFx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgNSk7XG5cblx0XHRcdFx0Ly8gS2VlcCB0aGlzIGluIGxvb3Agc2luY2Ugd2UgbWF5IHN1cHBvcnQgYXJyYXkgcHJvcGVydGllcyBoZXJlXG5cdFx0XHRcdHZhciBwb2ludExhYmVsRm9udENvbG9yID0gZ2V0VmFsdWVPckRlZmF1bHQocG9pbnRMYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0Y3R4LmZvbnQgPSBwbEZvbnQuZm9udDtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0XHRcdHZhciBhbmdsZSA9IGhlbHBlcnMudG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG5cdFx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdFx0ZmlsbFRleHQoY3R4LCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJywgcG9pbnRMYWJlbFBvc2l0aW9uLCBwbEZvbnQuc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBpbmRleCkge1xuXHRcdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVPcHRzLmNvbG9yLCBpbmRleCAtIDEpO1xuXHRcdGN0eC5saW5lV2lkdGggPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZU9wdHMubGluZVdpZHRoLCBpbmRleCAtIDEpO1xuXG5cdFx0aWYgKHNjYWxlLm9wdGlvbnMuZ3JpZExpbmVzLmNpcmN1bGFyKSB7XG5cdFx0XHQvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuXHRcdFx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblxuXHRcdFx0aWYgKHZhbHVlQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR2YXIgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcblx0XHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuXHRcdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRcdHJldHVybiBoZWxwZXJzLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcblx0fVxuXG5cdHZhciBMaW5lYXJSYWRpYWxTY2FsZSA9IENoYXJ0LkxpbmVhclNjYWxlQmFzZS5leHRlbmQoe1xuXHRcdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblx0XHRcdG1lLnhDZW50ZXIgPSBNYXRoLnJvdW5kKG1lLndpZHRoIC8gMik7XG5cdFx0XHRtZS55Q2VudGVyID0gTWF0aC5yb3VuZChtZS5oZWlnaHQgLyAyKTtcblxuXHRcdFx0dmFyIG1pblNpemUgPSBoZWxwZXJzLm1pbihbbWUuaGVpZ2h0LCBtZS53aWR0aF0pO1xuXHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRtZS5kcmF3aW5nQXJlYSA9IG9wdHMuZGlzcGxheSA/IChtaW5TaXplIC8gMikgLSAodGlja0ZvbnRTaXplIC8gMiArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kpIDogKG1pblNpemUgLyAyKTtcblx0XHR9LFxuXHRcdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdFx0dmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRcdGhlbHBlcnMuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHZhbHVlLCBtaW4pO1xuXHRcdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgodmFsdWUsIG1heCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRcdG1lLm1heCA9IChtYXggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/IDAgOiBtYXgpO1xuXG5cdFx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdFx0fSxcblx0XHRnZXRUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXHRcdFx0dmFyIHRpY2tGb250U2l6ZSA9IGhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCA/IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgOiAxMSwgTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyAoMS41ICogdGlja0ZvbnRTaXplKSkpO1xuXHRcdH0sXG5cdFx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdENoYXJ0LkxpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHRcdC8vIFBvaW50IGxhYmVsc1xuXHRcdFx0bWUucG9pbnRMYWJlbHMgPSBtZS5jaGFydC5kYXRhLmxhYmVscy5tYXAobWUub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgbWUpO1xuXHRcdH0sXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdH0sXG5cdFx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTZXQgcmFkaXVzIHJlZHVjdGlvbnMgYW5kIGRldGVybWluZSBuZXcgcmFkaXVzIGFuZCBjZW50ZXIgcG9pbnRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHNldFJlZHVjdGlvbnM6IGZ1bmN0aW9uKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBNYXRoLm1heChmdXJ0aGVzdExpbWl0cy5yIC0gbWUud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XG5cdFx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uVG9wID0gLWZ1cnRoZXN0TGltaXRzLnQgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy50KTtcblx0XHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIG1lLmhlaWdodCwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdFx0cmFkaXVzUmVkdWN0aW9uTGVmdCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25MZWZ0KTtcblx0XHRcdHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcblx0XHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdFx0cmFkaXVzUmVkdWN0aW9uQm90dG9tID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG5cblx0XHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4oXG5cdFx0XHRcdE1hdGgucm91bmQobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdFx0TWF0aC5yb3VuZChsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uVG9wICsgcmFkaXVzUmVkdWN0aW9uQm90dG9tKSAvIDIpKTtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KHJhZGl1c1JlZHVjdGlvbkxlZnQsIHJhZGl1c1JlZHVjdGlvblJpZ2h0LCByYWRpdXNSZWR1Y3Rpb25Ub3AsIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG5cdFx0fSxcblx0XHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgbWF4UmlnaHQgPSBtZS53aWR0aCAtIHJpZ2h0TW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYSxcblx0XHRcdFx0bWF4TGVmdCA9IGxlZnRNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhLFxuXHRcdFx0XHRtYXhUb3AgPSB0b3BNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhLFxuXHRcdFx0XHRtYXhCb3R0b20gPSBtZS5oZWlnaHQgLSBib3R0b21Nb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXG5cdFx0XHRtZS54Q2VudGVyID0gTWF0aC5yb3VuZCgoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdFx0bWUueUNlbnRlciA9IE1hdGgucm91bmQoKChtYXhUb3AgKyBtYXhCb3R0b20pIC8gMikgKyBtZS50b3ApO1xuXHRcdH0sXG5cblx0XHRnZXRJbmRleEFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dmFyIGFuZ2xlTXVsdGlwbGllciA9IChNYXRoLlBJICogMikgLyBnZXRWYWx1ZUNvdW50KHRoaXMpO1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgdGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgP1xuXHRcdFx0XHR0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA6XG5cdFx0XHRcdDA7XG5cblx0XHRcdHZhciBzdGFydEFuZ2xlUmFkaWFucyA9IHN0YXJ0QW5nbGUgKiBNYXRoLlBJICogMiAvIDM2MDtcblxuXHRcdFx0Ly8gU3RhcnQgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgcmlnaHQsIHNvIHJlbW92ZSBhIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXHRcdFx0cmV0dXJuIGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgc3RhcnRBbmdsZVJhZGlhbnM7XG5cdFx0fSxcblx0XHRnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gMDsgLy8gbnVsbCBhbHdheXMgaW4gY2VudGVyXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgaW50byBhY2NvdW50IGhhbGYgZm9udCBzaXplICsgdGhlIHlQYWRkaW5nIG9mIHRoZSB0b3AgdmFsdWVcblx0XHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdFx0cmV0dXJuIChtZS5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh2YWx1ZSAtIG1lLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuXHRcdH0sXG5cdFx0Z2V0UG9pbnRQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlcikge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0aGlzQW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIChNYXRoLlBJIC8gMik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBNYXRoLnJvdW5kKE1hdGguY29zKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIpICsgbWUueENlbnRlcixcblx0XHRcdFx0eTogTWF0aC5yb3VuZChNYXRoLnNpbih0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyKSArIG1lLnlDZW50ZXJcblx0XHRcdH07XG5cdFx0fSxcblx0XHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0XHRyZXR1cm4gbWUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsXG5cdFx0XHRcdG1lLmJlZ2luQXRaZXJvPyAwOlxuXHRcdFx0XHRtaW4gPCAwICYmIG1heCA8IDA/IG1heCA6XG5cdFx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMD8gbWluIDpcblx0XHRcdFx0MCk7XG5cdFx0fSxcblxuXHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0XHR2YXIgZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cblx0XHRcdFx0Ly8gVGljayBGb250XG5cdFx0XHRcdHZhciB0aWNrRm9udFNpemUgPSBnZXRWYWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFyIHRpY2tGb250U3R5bGUgPSBnZXRWYWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpO1xuXHRcdFx0XHR2YXIgdGlja0ZvbnRGYW1pbHkgPSBnZXRWYWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSk7XG5cdFx0XHRcdHZhciB0aWNrTGFiZWxGb250ID0gaGVscGVycy5mb250U3RyaW5nKHRpY2tGb250U2l6ZSwgdGlja0ZvbnRTdHlsZSwgdGlja0ZvbnRGYW1pbHkpO1xuXG5cdFx0XHRcdGhlbHBlcnMuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdFx0Ly8gRG9uJ3QgZHJhdyBhIGNlbnRyZSB2YWx1ZSAoaWYgaXQgaXMgbWluaW11bSlcblx0XHRcdFx0XHRpZiAoaW5kZXggPiAwIHx8IG9wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHlDZW50ZXJPZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXHRcdFx0XHRcdFx0dmFyIHlIZWlnaHQgPSBtZS55Q2VudGVyIC0geUNlbnRlck9mZnNldDtcblxuXHRcdFx0XHRcdFx0Ly8gRHJhdyBjaXJjdWxhciBsaW5lcyBhcm91bmQgdGhlIHNjYWxlXG5cdFx0XHRcdFx0XHRpZiAoZ3JpZExpbmVPcHRzLmRpc3BsYXkgJiYgaW5kZXggIT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGlja09wdHMuZGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IGdldFZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0xhYmVsRm9udDtcblxuXHRcdFx0XHRcdFx0XHRpZiAodGlja09wdHMuc2hvd0xhYmVsQmFja2Ryb3ApIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tPcHRzLmJhY2tkcm9wQ29sb3I7XG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxuXHRcdFx0XHRcdFx0XHRcdFx0bWUueENlbnRlciAtIGxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHRcdHlIZWlnaHQgLSB0aWNrRm9udFNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsV2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcblx0XHRcdFx0XHRcdFx0XHRcdHRpY2tGb250U2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCBtZS54Q2VudGVyLCB5SGVpZ2h0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChvcHRzLmFuZ2xlTGluZXMuZGlzcGxheSB8fCBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0Q2hhcnQuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKCdyYWRpYWxMaW5lYXInLCBMaW5lYXJSYWRpYWxTY2FsZSwgZGVmYXVsdENvbmZpZyk7XG5cbn07XG4iLCIvKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5tb21lbnQgPSB0eXBlb2YobW9tZW50KSA9PT0gJ2Z1bmN0aW9uJyA/IG1vbWVudCA6IHdpbmRvdy5tb21lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcblxuXHR2YXIgaGVscGVycyA9IENoYXJ0LmhlbHBlcnM7XG5cdHZhciBpbnRlcnZhbCA9IHtcblx0XHRtaWxsaXNlY29uZDoge1xuXHRcdFx0c2l6ZTogMSxcblx0XHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwLCAyNTAsIDUwMF1cblx0XHR9LFxuXHRcdHNlY29uZDoge1xuXHRcdFx0c2l6ZTogMTAwMCxcblx0XHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDMwXVxuXHRcdH0sXG5cdFx0bWludXRlOiB7XG5cdFx0XHRzaXplOiA2MDAwMCxcblx0XHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDMwXVxuXHRcdH0sXG5cdFx0aG91cjoge1xuXHRcdFx0c2l6ZTogMzYwMDAwMCxcblx0XHRcdHN0ZXBzOiBbMSwgMiwgMywgNiwgMTJdXG5cdFx0fSxcblx0XHRkYXk6IHtcblx0XHRcdHNpemU6IDg2NDAwMDAwLFxuXHRcdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHRcdH0sXG5cdFx0d2Vlazoge1xuXHRcdFx0c2l6ZTogNjA0ODAwMDAwLFxuXHRcdFx0bWF4U3RlcDogNFxuXHRcdH0sXG5cdFx0bW9udGg6IHtcblx0XHRcdHNpemU6IDIuNjI4ZTksXG5cdFx0XHRtYXhTdGVwOiAzXG5cdFx0fSxcblx0XHRxdWFydGVyOiB7XG5cdFx0XHRzaXplOiA3Ljg4NGU5LFxuXHRcdFx0bWF4U3RlcDogNFxuXHRcdH0sXG5cdFx0eWVhcjoge1xuXHRcdFx0c2l6ZTogMy4xNTRlMTAsXG5cdFx0XHRtYXhTdGVwOiBmYWxzZVxuXHRcdH1cblx0fTtcblxuXHR2YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0XHR0aW1lOiB7XG5cdFx0XHRwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdFx0Zm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRCBmYWxzZSA9PSBkYXRlIG9iamVjdHMsIG1vbWVudCBvYmplY3QsIGNhbGxiYWNrIG9yIGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvXG5cdFx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRcdHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdFx0ZGlzcGxheUZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURURcblx0XHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9nZXQtc2V0L2lzby13ZWVrZGF5L1xuXHRcdFx0bWluVW5pdDogJ21pbGxpc2Vjb25kJyxcblxuXHRcdFx0Ly8gZGVmYXVsdHMgdG8gdW5pdCdzIGNvcnJlc3BvbmRpbmcgdW5pdEZvcm1hdCBiZWxvdyBvciBvdmVycmlkZSB1c2luZyBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1xuXHRcdFx0ZGlzcGxheUZvcm1hdHM6IHtcblx0XHRcdFx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJywgLy8gMTE6MjA6MDEuMTIzIEFNLFxuXHRcdFx0XHRzZWNvbmQ6ICdoOm1tOnNzIGEnLCAvLyAxMToyMDowMSBBTVxuXHRcdFx0XHRtaW51dGU6ICdoOm1tOnNzIGEnLCAvLyAxMToyMDowMSBBTVxuXHRcdFx0XHRob3VyOiAnTU1NIEQsIGhBJywgLy8gU2VwdCA0LCA1UE1cblx0XHRcdFx0ZGF5OiAnbGwnLCAvLyBTZXAgNCAyMDE1XG5cdFx0XHRcdHdlZWs6ICdsbCcsIC8vIFdlZWsgNDYsIG9yIG1heWJlIFwiW1ddV1cgLSBZWVlZXCIgP1xuXHRcdFx0XHRtb250aDogJ01NTSBZWVlZJywgLy8gU2VwdCAyMDE1XG5cdFx0XHRcdHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsIC8vIFEzXG5cdFx0XHRcdHllYXI6ICdZWVlZJyAvLyAyMDE1XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0dGlja3M6IHtcblx0XHRcdGF1dG9Ta2lwOiBmYWxzZVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIHRpbWUgdG8gYSBtb21lbnQgb2JqZWN0XG5cdCAqIEBwYXJhbSBheGlzIHtUaW1lQXhpc30gdGhlIHRpbWUgYXhpc1xuXHQgKiBAcGFyYW0gbGFiZWwge0RhdGV8c3RyaW5nfG51bWJlcnxNb21lbnR9IFRoZSB0aGluZyB0byBwYXJzZVxuXHQgKiBAcmV0dXJuIHtNb21lbnR9IHBhcnNlZCB0aW1lXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZVRpbWUoYXhpcywgbGFiZWwpIHtcblx0XHR2YXIgdGltZU9wdHMgPSBheGlzLm9wdGlvbnMudGltZTtcblx0XHRpZiAodHlwZW9mIHRpbWVPcHRzLnBhcnNlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBtb21lbnQobGFiZWwsIHRpbWVPcHRzLnBhcnNlcik7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdGltZU9wdHMucGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gdGltZU9wdHMucGFyc2VyKGxhYmVsKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsYWJlbC5nZXRNb250aCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbGFiZWwgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBEYXRlIG9iamVjdHNcblx0XHRcdHJldHVybiBtb21lbnQobGFiZWwpO1xuXHRcdH1cblx0XHRpZiAobGFiZWwuaXNWYWxpZCAmJiBsYWJlbC5pc1ZhbGlkKCkpIHtcblx0XHRcdC8vIE1vbWVudCBzdXBwb3J0XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHRcdHZhciBmb3JtYXQgPSB0aW1lT3B0cy5mb3JtYXQ7XG5cdFx0aWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnICYmIGZvcm1hdC5jYWxsKSB7XG5cdFx0XHQvLyBDdXN0b20gcGFyc2luZyAocmV0dXJuIGFuIGluc3RhbmNlIG9mIG1vbWVudClcblx0XHRcdGNvbnNvbGUud2Fybignb3B0aW9ucy50aW1lLmZvcm1hdCBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBvcHRpb25zLnRpbWUucGFyc2VyLicpO1xuXHRcdFx0cmV0dXJuIGZvcm1hdChsYWJlbCk7XG5cdFx0fVxuXHRcdC8vIE1vbWVudCBmb3JtYXQgcGFyc2luZ1xuXHRcdHJldHVybiBtb21lbnQobGFiZWwsIGZvcm1hdCk7XG5cdH1cblxuXHQvKipcblx0ICogRmlndXJlIG91dCB3aGljaCBpcyB0aGUgYmVzdCB1bml0IGZvciB0aGUgc2NhbGVcblx0ICogQHBhcmFtIG1pblVuaXQge1N0cmluZ30gbWluaW11bSB1bml0IHRvIHVzZVxuXHQgKiBAcGFyYW0gbWluIHtOdW1iZXJ9IHNjYWxlIG1pbmltdW1cblx0ICogQHBhcmFtIG1heCB7TnVtYmVyfSBzY2FsZSBtYXhpbXVtXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaXQgdG8gdXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBkZXRlcm1pbmVVbml0KG1pblVuaXQsIG1pbiwgbWF4LCBtYXhUaWNrcykge1xuXHRcdHZhciB1bml0cyA9IE9iamVjdC5rZXlzKGludGVydmFsKTtcblx0XHR2YXIgdW5pdDtcblx0XHR2YXIgbnVtVW5pdHMgPSB1bml0cy5sZW5ndGg7XG5cblx0XHRmb3IgKHZhciBpID0gdW5pdHMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IG51bVVuaXRzOyBpKyspIHtcblx0XHRcdHVuaXQgPSB1bml0c1tpXTtcblx0XHRcdHZhciB1bml0RGV0YWlscyA9IGludGVydmFsW3VuaXRdO1xuXHRcdFx0dmFyIHN0ZXBzID0gKHVuaXREZXRhaWxzLnN0ZXBzICYmIHVuaXREZXRhaWxzLnN0ZXBzW3VuaXREZXRhaWxzLnN0ZXBzLmxlbmd0aCAtIDFdKSB8fCB1bml0RGV0YWlscy5tYXhTdGVwO1xuXHRcdFx0aWYgKHN0ZXBzID09PSB1bmRlZmluZWQgfHwgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKHN0ZXBzICogdW5pdERldGFpbHMuc2l6ZSkpIDw9IG1heFRpY2tzKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1bml0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaG93IHdlIHNjYWxlIHRoZSB1bml0XG5cdCAqIEBwYXJhbSBtaW4ge051bWJlcn0gdGhlIHNjYWxlIG1pbmltdW1cblx0ICogQHBhcmFtIG1heCB7TnVtYmVyfSB0aGUgc2NhbGUgbWF4aW11bVxuXHQgKiBAcGFyYW0gdW5pdCB7U3RyaW5nfSB0aGUgdW5pdCBkZXRlcm1pbmVkIGJ5IHRoZSB7QHNlZSBkZXRlcm1pbmVVbml0fSBtZXRob2Rcblx0ICogQHJldHVybiB7TnVtYmVyfSB0aGUgYXhpcyBzdGVwIHNpemUgYXMgYSBtdWx0aXBsZSBvZiB1bml0XG5cdCAqL1xuXHRmdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgbWF4VGlja3MpIHtcblx0XHQvLyBVc2luZyBvdXIgdW5pdCwgZmlnb3VyZSBvdXQgd2hhdCB3ZSBuZWVkIHRvIHNjYWxlIGFzXG5cdFx0dmFyIHVuaXREZWZpbml0aW9uID0gaW50ZXJ2YWxbdW5pdF07XG5cdFx0dmFyIHVuaXRTaXplSW5NaWxsaVNlY29uZHMgPSB1bml0RGVmaW5pdGlvbi5zaXplO1xuXHRcdHZhciBzaXplSW5Vbml0cyA9IE1hdGguY2VpbCgobWF4IC0gbWluKSAvIHVuaXRTaXplSW5NaWxsaVNlY29uZHMpO1xuXHRcdHZhciBtdWx0aXBsaWVyID0gMTtcblx0XHR2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cblx0XHRpZiAodW5pdERlZmluaXRpb24uc3RlcHMpIHtcblx0XHRcdC8vIEhhdmUgYW4gYXJyYXkgb2Ygc3RlcHNcblx0XHRcdHZhciBudW1TdGVwcyA9IHVuaXREZWZpbml0aW9uLnN0ZXBzLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3RlcHMgJiYgc2l6ZUluVW5pdHMgPiBtYXhUaWNrczsgaSsrKSB7XG5cdFx0XHRcdG11bHRpcGxpZXIgPSB1bml0RGVmaW5pdGlvbi5zdGVwc1tpXTtcblx0XHRcdFx0c2l6ZUluVW5pdHMgPSBNYXRoLmNlaWwocmFuZ2UgLyAodW5pdFNpemVJbk1pbGxpU2Vjb25kcyAqIG11bHRpcGxpZXIpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUgKHNpemVJblVuaXRzID4gbWF4VGlja3MgJiYgbWF4VGlja3MgPiAwKSB7XG5cdFx0XHRcdCsrbXVsdGlwbGllcjtcblx0XHRcdFx0c2l6ZUluVW5pdHMgPSBNYXRoLmNlaWwocmFuZ2UgLyAodW5pdFNpemVJbk1pbGxpU2Vjb25kcyAqIG11bHRpcGxpZXIpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbXVsdGlwbGllcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZm9yIGdlbmVyYXRpbmcgYXhpcyBsYWJlbHMuXG5cdCAqIEBwYXJhbSBvcHRpb25zIHtJVGltZUdlbmVyYXRvck9wdGlvbnN9IHRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW9uXG5cdCAqIEBwYXJhbSBkYXRhUmFuZ2Uge0lSYW5nZX0gdGhlIGRhdGEgcmFuZ2Vcblx0ICogQHBhcmFtIG5pY2VSYW5nZSB7SVJhbmdlfSB0aGUgcHJldHR5IHJhbmdlIHRvIGRpc3BsYXlcblx0ICogQHJldHVybiB7TnVtYmVyW119IHRpY2tzXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKG9wdGlvbnMsIGRhdGFSYW5nZSwgbmljZVJhbmdlKSB7XG5cdFx0dmFyIHRpY2tzID0gW107XG5cdFx0aWYgKG9wdGlvbnMubWF4VGlja3MpIHtcblx0XHRcdHZhciBzdGVwU2l6ZSA9IG9wdGlvbnMuc3RlcFNpemU7XG5cdFx0XHR0aWNrcy5wdXNoKG9wdGlvbnMubWluICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbiA6IG5pY2VSYW5nZS5taW4pO1xuXHRcdFx0dmFyIGN1ciA9IG1vbWVudChuaWNlUmFuZ2UubWluKTtcblx0XHRcdHdoaWxlIChjdXIuYWRkKHN0ZXBTaXplLCBvcHRpb25zLnVuaXQpLnZhbHVlT2YoKSA8IG5pY2VSYW5nZS5tYXgpIHtcblx0XHRcdFx0dGlja3MucHVzaChjdXIudmFsdWVPZigpKTtcblx0XHRcdH1cblx0XHRcdHZhciByZWFsTWF4ID0gb3B0aW9ucy5tYXggfHwgbmljZVJhbmdlLm1heDtcblx0XHRcdGlmICh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSAhPT0gcmVhbE1heCkge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHJlYWxNYXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGlja3M7XG5cdH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRpY2tzLmdlbmVyYXRvcnMudGltZVxuXHQgKiBAcGFyYW0gb3B0aW9ucyB7SVRpbWVHZW5lcmF0b3JPcHRpb25zfSB0aGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGlvblxuXHQgKiBAcGFyYW0gZGF0YVJhbmdlIHtJUmFuZ2V9IHRoZSBkYXRhIHJhbmdlXG5cdCAqIEByZXR1cm4ge051bWJlcltdfSB0aWNrc1xuXHQgKi9cblx0Q2hhcnQuVGlja3MuZ2VuZXJhdG9ycy50aW1lID0gZnVuY3Rpb24ob3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdFx0dmFyIG5pY2VNaW47XG5cdFx0dmFyIG5pY2VNYXg7XG5cdFx0dmFyIGlzb1dlZWtkYXkgPSBvcHRpb25zLmlzb1dlZWtkYXk7XG5cdFx0aWYgKG9wdGlvbnMudW5pdCA9PT0gJ3dlZWsnICYmIGlzb1dlZWtkYXkgIT09IGZhbHNlKSB7XG5cdFx0XHRuaWNlTWluID0gbW9tZW50KGRhdGFSYW5nZS5taW4pLnN0YXJ0T2YoJ2lzb1dlZWsnKS5pc29XZWVrZGF5KGlzb1dlZWtkYXkpLnZhbHVlT2YoKTtcblx0XHRcdG5pY2VNYXggPSBtb21lbnQoZGF0YVJhbmdlLm1heCkuc3RhcnRPZignaXNvV2VlaycpLmlzb1dlZWtkYXkoaXNvV2Vla2RheSk7XG5cdFx0XHRpZiAoZGF0YVJhbmdlLm1heCAtIG5pY2VNYXggPiAwKSB7XG5cdFx0XHRcdG5pY2VNYXguYWRkKDEsICd3ZWVrJyk7XG5cdFx0XHR9XG5cdFx0XHRuaWNlTWF4ID0gbmljZU1heC52YWx1ZU9mKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VNaW4gPSBtb21lbnQoZGF0YVJhbmdlLm1pbikuc3RhcnRPZihvcHRpb25zLnVuaXQpLnZhbHVlT2YoKTtcblx0XHRcdG5pY2VNYXggPSBtb21lbnQoZGF0YVJhbmdlLm1heCkuc3RhcnRPZihvcHRpb25zLnVuaXQpO1xuXHRcdFx0aWYgKGRhdGFSYW5nZS5tYXggLSBuaWNlTWF4ID4gMCkge1xuXHRcdFx0XHRuaWNlTWF4LmFkZCgxLCBvcHRpb25zLnVuaXQpO1xuXHRcdFx0fVxuXHRcdFx0bmljZU1heCA9IG5pY2VNYXgudmFsdWVPZigpO1xuXHRcdH1cblx0XHRyZXR1cm4gZ2VuZXJhdGVUaWNrcyhvcHRpb25zLCBkYXRhUmFuZ2UsIHtcblx0XHRcdG1pbjogbmljZU1pbixcblx0XHRcdG1heDogbmljZU1heFxuXHRcdH0pO1xuXHR9O1xuXG5cdHZhciBUaW1lU2NhbGUgPSBDaGFydC5TY2FsZS5leHRlbmQoe1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFtb21lbnQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDaGFydC5qcyAtIE1vbWVudC5qcyBjb3VsZCBub3QgYmUgZm91bmQhIFlvdSBtdXN0IGluY2x1ZGUgaXQgYmVmb3JlIENoYXJ0LmpzIHRvIHVzZSB0aGUgdGltZSBzY2FsZS4gRG93bmxvYWQgYXQgaHR0cHM6Ly9tb21lbnRqcy5jb20nKTtcblx0XHRcdH1cblxuXHRcdFx0Q2hhcnQuU2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0XHR9LFxuXHRcdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblxuXHRcdFx0Ly8gV2Ugc3RvcmUgdGhlIGRhdGEgcmFuZ2UgYXMgdW5peCBtaWxsaXNlY29uZCB0aW1lc3RhbXBzIHNvIGRhdGFNaW4gYW5kIGRhdGFNYXggd2lsbCBhbHdheXMgYmUgaW50ZWdlcnMuXG5cdFx0XHR2YXIgZGF0YU1pbiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXHRcdFx0dmFyIGRhdGFNYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcblxuXHRcdFx0dmFyIGNoYXJ0RGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0XHR2YXIgcGFyc2VkRGF0YSA9IHtcblx0XHRcdFx0bGFiZWxzOiBbXSxcblx0XHRcdFx0ZGF0YXNldHM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgdGltZXN0YW1wO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2goY2hhcnREYXRhLmxhYmVscywgZnVuY3Rpb24obGFiZWwsIGxhYmVsSW5kZXgpIHtcblx0XHRcdFx0dmFyIGxhYmVsTW9tZW50ID0gcGFyc2VUaW1lKG1lLCBsYWJlbCk7XG5cblx0XHRcdFx0aWYgKGxhYmVsTW9tZW50LmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gcm91bmQgdGhlIHRpbWVcblx0XHRcdFx0XHRpZiAodGltZU9wdHMucm91bmQpIHtcblx0XHRcdFx0XHRcdGxhYmVsTW9tZW50LnN0YXJ0T2YodGltZU9wdHMucm91bmQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRpbWVzdGFtcCA9IGxhYmVsTW9tZW50LnZhbHVlT2YoKTtcblx0XHRcdFx0XHRkYXRhTWluID0gTWF0aC5taW4odGltZXN0YW1wLCBkYXRhTWluKTtcblx0XHRcdFx0XHRkYXRhTWF4ID0gTWF0aC5tYXgodGltZXN0YW1wLCBkYXRhTWF4KTtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoaXMgdmFsdWUgZm9yIGxhdGVyXG5cdFx0XHRcdFx0cGFyc2VkRGF0YS5sYWJlbHNbbGFiZWxJbmRleF0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzLmVhY2goY2hhcnREYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGFzZXQuZGF0YVswXSA9PT0gJ29iamVjdCcgJiYgZGF0YXNldC5kYXRhWzBdICE9PSBudWxsICYmIG1lLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0XHRcdC8vIFdlIGhhdmUgcG90ZW50aWFsIHBvaW50IGRhdGEsIHNvIHdlIG5lZWQgdG8gcGFyc2UgdGhpc1xuXHRcdFx0XHRcdGhlbHBlcnMuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBkYXRhSW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciBkYXRhTW9tZW50ID0gcGFyc2VUaW1lKG1lLCBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhTW9tZW50LmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGltZU9wdHMucm91bmQpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhTW9tZW50LnN0YXJ0T2YodGltZU9wdHMucm91bmQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGltZXN0YW1wID0gZGF0YU1vbWVudC52YWx1ZU9mKCk7XG5cdFx0XHRcdFx0XHRcdGRhdGFNaW4gPSBNYXRoLm1pbih0aW1lc3RhbXAsIGRhdGFNaW4pO1xuXHRcdFx0XHRcdFx0XHRkYXRhTWF4ID0gTWF0aC5tYXgodGltZXN0YW1wLCBkYXRhTWF4KTtcblx0XHRcdFx0XHRcdFx0dGltZXN0YW1wc1tkYXRhSW5kZXhdID0gdGltZXN0YW1wO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFdlIGhhdmUgbm8geCBjb29yZGluYXRlcywgc28gdXNlIHRoZSBvbmVzIGZyb20gdGhlIGxhYmVsc1xuXHRcdFx0XHRcdHRpbWVzdGFtcHMgPSBwYXJzZWREYXRhLmxhYmVscy5zbGljZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyc2VkRGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdID0gdGltZXN0YW1wcztcblx0XHRcdH0pO1xuXG5cdFx0XHRtZS5kYXRhTWluID0gZGF0YU1pbjtcblx0XHRcdG1lLmRhdGFNYXggPSBkYXRhTWF4O1xuXHRcdFx0bWUuX3BhcnNlZERhdGEgPSBwYXJzZWREYXRhO1xuXHRcdH0sXG5cdFx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXG5cdFx0XHR2YXIgbWluVGltZXN0YW1wO1xuXHRcdFx0dmFyIG1heFRpbWVzdGFtcDtcblx0XHRcdHZhciBkYXRhTWluID0gbWUuZGF0YU1pbjtcblx0XHRcdHZhciBkYXRhTWF4ID0gbWUuZGF0YU1heDtcblxuXHRcdFx0aWYgKHRpbWVPcHRzLm1pbikge1xuXHRcdFx0XHR2YXIgbWluTW9tZW50ID0gcGFyc2VUaW1lKG1lLCB0aW1lT3B0cy5taW4pO1xuXHRcdFx0XHRpZiAodGltZU9wdHMucm91bmQpIHtcblx0XHRcdFx0XHRtaW5Nb21lbnQucm91bmQodGltZU9wdHMucm91bmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1pblRpbWVzdGFtcCA9IG1pbk1vbWVudC52YWx1ZU9mKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aW1lT3B0cy5tYXgpIHtcblx0XHRcdFx0bWF4VGltZXN0YW1wID0gcGFyc2VUaW1lKG1lLCB0aW1lT3B0cy5tYXgpLnZhbHVlT2YoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0TGFiZWxDYXBhY2l0eShtaW5UaW1lc3RhbXAgfHwgZGF0YU1pbik7XG5cdFx0XHR2YXIgdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdCh0aW1lT3B0cy5taW5Vbml0LCBtaW5UaW1lc3RhbXAgfHwgZGF0YU1pbiwgbWF4VGltZXN0YW1wIHx8IGRhdGFNYXgsIG1heFRpY2tzKTtcblx0XHRcdG1lLmRpc3BsYXlGb3JtYXQgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0c1t1bml0XTtcblxuXHRcdFx0dmFyIHN0ZXBTaXplID0gdGltZU9wdHMuc3RlcFNpemUgfHwgZGV0ZXJtaW5lU3RlcFNpemUobWluVGltZXN0YW1wIHx8IGRhdGFNaW4sIG1heFRpbWVzdGFtcCB8fCBkYXRhTWF4LCB1bml0LCBtYXhUaWNrcyk7XG5cdFx0XHRtZS50aWNrcyA9IENoYXJ0LlRpY2tzLmdlbmVyYXRvcnMudGltZSh7XG5cdFx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcblx0XHRcdFx0bWluOiBtaW5UaW1lc3RhbXAsXG5cdFx0XHRcdG1heDogbWF4VGltZXN0YW1wLFxuXHRcdFx0XHRzdGVwU2l6ZTogc3RlcFNpemUsXG5cdFx0XHRcdHVuaXQ6IHVuaXQsXG5cdFx0XHRcdGlzb1dlZWtkYXk6IHRpbWVPcHRzLmlzb1dlZWtkYXlcblx0XHRcdH0sIHtcblx0XHRcdFx0bWluOiBkYXRhTWluLFxuXHRcdFx0XHRtYXg6IGRhdGFNYXhcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRcdG1lLm1heCA9IGhlbHBlcnMubWF4KG1lLnRpY2tzKTtcblx0XHRcdG1lLm1pbiA9IGhlbHBlcnMubWluKG1lLnRpY2tzKTtcblx0XHR9LFxuXHRcdC8vIEdldCB0b29sdGlwIGxhYmVsXG5cdFx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBsYWJlbCA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzICYmIGluZGV4IDwgbWUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoID8gbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XG5cdFx0XHR2YXIgdmFsdWUgPSBtZS5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcm1hdCBuaWNlbHlcblx0XHRcdGlmIChtZS5vcHRpb25zLnRpbWUudG9vbHRpcEZvcm1hdCkge1xuXHRcdFx0XHRsYWJlbCA9IHBhcnNlVGltZShtZSwgbGFiZWwpLmZvcm1hdChtZS5vcHRpb25zLnRpbWUudG9vbHRpcEZvcm1hdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9LFxuXHRcdC8vIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHRcdHRpY2tGb3JtYXRGdW5jdGlvbjogZnVuY3Rpb24odGljaywgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgZm9ybWF0dGVkVGljayA9IHRpY2suZm9ybWF0KHRoaXMuZGlzcGxheUZvcm1hdCk7XG5cdFx0XHR2YXIgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmNhbGxiYWNrLCB0aWNrT3B0cy51c2VyQ2FsbGJhY2spO1xuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGZvcm1hdHRlZFRpY2ssIGluZGV4LCB0aWNrcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm9ybWF0dGVkVGljaztcblx0XHR9LFxuXHRcdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHRtZS50aWNrc0FzVGltZXN0YW1wcyA9IG1lLnRpY2tzO1xuXHRcdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAoZnVuY3Rpb24odGljaykge1xuXHRcdFx0XHRyZXR1cm4gbW9tZW50KHRpY2spO1xuXHRcdFx0fSkubWFwKG1lLnRpY2tGb3JtYXRGdW5jdGlvbiwgbWUpO1xuXHRcdH0sXG5cdFx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciBlcG9jaFdpZHRoID0gbWUubWF4IC0gbWUubWluO1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBlcG9jaFdpZHRoID8gKG9mZnNldCAtIG1lLm1pbikgLyBlcG9jaFdpZHRoIDogMDtcblxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChtZS53aWR0aCAqIGRlY2ltYWwpO1xuXHRcdFx0XHRyZXR1cm4gbWUubGVmdCArIE1hdGgucm91bmQodmFsdWVPZmZzZXQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKG1lLmhlaWdodCAqIGRlY2ltYWwpO1xuXHRcdFx0cmV0dXJuIG1lLnRvcCArIE1hdGgucm91bmQoaGVpZ2h0T2Zmc2V0KTtcblx0XHR9LFxuXHRcdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdFx0dmFyIG9mZnNldCA9IG51bGw7XG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvZmZzZXQgPSBtZS5fcGFyc2VkRGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9mZnNldCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIXZhbHVlIHx8ICF2YWx1ZS5pc1ZhbGlkKSB7XG5cdFx0XHRcdFx0Ly8gbm90IGFscmVhZHkgYSBtb21lbnQgb2JqZWN0XG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZVRpbWUobWUsIG1lLmdldFJpZ2h0VmFsdWUodmFsdWUpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1ZhbGlkICYmIHZhbHVlLmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHZhbHVlLnZhbHVlT2YoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2Zmc2V0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldChvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JPZmZzZXQodGhpcy50aWNrc0FzVGltZXN0YW1wc1tpbmRleF0pO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdFx0dmFyIG9mZnNldCA9IChwaXhlbCAtIChtZS5pc0hvcml6b250YWwoKSA/IG1lLmxlZnQgOiBtZS50b3ApKSAvIGlubmVyRGltZW5zaW9uO1xuXHRcdFx0cmV0dXJuIG1vbWVudChtZS5taW4gKyAob2Zmc2V0ICogKG1lLm1heCAtIG1lLm1pbikpKTtcblx0XHR9LFxuXHRcdC8vIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0XHRnZXRMYWJlbFdpZHRoOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0dmFyIG1lID0gdGhpcztcblx0XHRcdHZhciB0aWNrcyA9IG1lLm9wdGlvbnMudGlja3M7XG5cblx0XHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhoZWxwZXJzLnRvUmFkaWFucyh0aWNrcy5tYXhSb3RhdGlvbikpO1xuXHRcdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oaGVscGVycy50b1JhZGlhbnModGlja3MubWF4Um90YXRpb24pKTtcblx0XHRcdHZhciB0aWNrRm9udFNpemUgPSBoZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0KHRpY2tzLmZvbnRTaXplLCBDaGFydC5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHRcdH0sXG5cdFx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRcdG1lLmRpc3BsYXlGb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XHQvLyBQaWNrIHRoZSBsb25nZXN0IGZvcm1hdCBmb3IgZ3Vlc3RpbWF0aW9uXG5cdFx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKG1vbWVudChleGFtcGxlVGltZSksIDAsIFtdKTtcblx0XHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmdldExhYmVsV2lkdGgoZXhhbXBsZUxhYmVsKTtcblxuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdFx0dmFyIGxhYmVsQ2FwYWNpdHkgPSBpbm5lcldpZHRoIC8gdGlja0xhYmVsV2lkdGg7XG5cdFx0XHRyZXR1cm4gbGFiZWxDYXBhY2l0eTtcblx0XHR9XG5cdH0pO1xuXHRDaGFydC5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUoJ3RpbWUnLCBUaW1lU2NhbGUsIGRlZmF1bHRDb25maWcpO1xuXG59O1xuIiwiLyogTUlUIGxpY2Vuc2UgKi9cclxudmFyIGNvbG9yTmFtZXMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgZ2V0UmdiYTogZ2V0UmdiYSxcclxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcclxuICAgZ2V0UmdiOiBnZXRSZ2IsXHJcbiAgIGdldEhzbDogZ2V0SHNsLFxyXG4gICBnZXRId2I6IGdldEh3YixcclxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxyXG5cclxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXHJcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxyXG4gICByZ2JhU3RyaW5nOiByZ2JhU3RyaW5nLFxyXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxyXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXHJcbiAgIGhzbFN0cmluZzogaHNsU3RyaW5nLFxyXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxyXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcclxuICAga2V5d29yZDoga2V5d29yZFxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xyXG4gICBpZiAoIXN0cmluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezN9KSQvLFxyXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fSkkLyxcclxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkLyxcclxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvLFxyXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xyXG5cclxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcclxuICAgICAgIGEgPSAxLFxyXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicik7XHJcbiAgIGlmIChtYXRjaCkge1xyXG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XHJcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcclxuICAgfVxyXG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XHJcbiAgICAgIH1cclxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xyXG4gICB9XHJcbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XHJcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcclxuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcclxuICAgICAgfVxyXG4gICAgICByZ2IgPSBjb2xvck5hbWVzW21hdGNoWzFdXTtcclxuICAgICAgaWYgKCFyZ2IpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgIH1cclxuXHJcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcclxuICAgfVxyXG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XHJcbiAgICAgIGEgPSAxO1xyXG4gICB9XHJcbiAgIGVsc2Uge1xyXG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XHJcbiAgIH1cclxuICAgcmdiWzNdID0gYTtcclxuICAgcmV0dXJuIHJnYjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcclxuICAgaWYgKCFzdHJpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XHJcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xyXG4gICBpZiAobWF0Y2gpIHtcclxuICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XHJcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxyXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxyXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxyXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XHJcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XHJcbiAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SHdiKHN0cmluZykge1xyXG4gICBpZiAoIXN0cmluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgIH1cclxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XHJcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xyXG4gICBpZiAobWF0Y2gpIHtcclxuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xyXG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcclxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcclxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcclxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xyXG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xyXG4gICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFJnYihzdHJpbmcpIHtcclxuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XHJcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcclxuICB2YXIgaHNsYSA9IGdldEhzbGEoc3RyaW5nKTtcclxuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcclxuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XHJcbiAgIGlmICh2YWxzKSB7XHJcbiAgICAgIHJldHVybiB2YWxzWzNdO1xyXG4gICB9XHJcbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRIc2xhKHN0cmluZykpIHtcclxuICAgICAgcmV0dXJuIHZhbHNbM107XHJcbiAgIH1cclxuICAgZWxzZSBpZiAodmFscyA9IGdldEh3YihzdHJpbmcpKSB7XHJcbiAgICAgIHJldHVybiB2YWxzWzNdO1xyXG4gICB9XHJcbn1cclxuXHJcbi8vIGdlbmVyYXRvcnNcclxuZnVuY3Rpb24gaGV4U3RyaW5nKHJnYikge1xyXG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiWzBdKSArIGhleERvdWJsZShyZ2JbMV0pXHJcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiWzJdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XHJcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XHJcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcclxuICAgfVxyXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl0gKyBcIilcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSkge1xyXG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XHJcbiAgIH1cclxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxyXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xyXG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xyXG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xyXG4gICB9XHJcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXHJcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXHJcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XHJcblxyXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcclxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcclxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcclxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcclxuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xyXG4gICBpZiAoYWxwaGEgPCAxIHx8IChoc2xhWzNdICYmIGhzbGFbM10gPCAxKSkge1xyXG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XHJcbiAgIH1cclxuICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSlcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSkge1xyXG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XHJcbiAgIH1cclxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXHJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xyXG59XHJcblxyXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxyXG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXHJcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XHJcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGFscGhhID0gKGh3YlszXSAhPT0gdW5kZWZpbmVkID8gaHdiWzNdIDogMSk7XHJcbiAgIH1cclxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXHJcbiAgICAgICAgICAgKyAoYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBhbHBoYSAhPT0gMSA/IFwiLCBcIiArIGFscGhhIDogXCJcIikgKyBcIilcIjtcclxufVxyXG5cclxuZnVuY3Rpb24ga2V5d29yZChyZ2IpIHtcclxuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XHJcbn1cclxuXHJcbi8vIGhlbHBlcnNcclxuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xyXG4gICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XHJcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xyXG59XHJcblxyXG5cclxuLy9jcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcclxudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xyXG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcclxuICAgcmV2ZXJzZU5hbWVzW2NvbG9yTmFtZXNbbmFtZV1dID0gbmFtZTtcclxufVxyXG4iLCIvKiBNSVQgbGljZW5zZSAqL1xudmFyIGNvbnZlcnQgPSByZXF1aXJlKCdjb2xvci1jb252ZXJ0Jyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnY2hhcnRqcy1jb2xvci1zdHJpbmcnKTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaik7XG5cdH1cblxuXHR0aGlzLnZhbGlkID0gZmFsc2U7XG5cdHRoaXMudmFsdWVzID0ge1xuXHRcdHJnYjogWzAsIDAsIDBdLFxuXHRcdGhzbDogWzAsIDAsIDBdLFxuXHRcdGhzdjogWzAsIDAsIDBdLFxuXHRcdGh3YjogWzAsIDAsIDBdLFxuXHRcdGNteWs6IFswLCAwLCAwLCAwXSxcblx0XHRhbHBoYTogMVxuXHR9O1xuXG5cdC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcblx0dmFyIHZhbHM7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhbHMgPSBzdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gc3RyaW5nLmdldEhzbGEob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IHN0cmluZy5nZXRId2Iob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHRcdHZhbHMgPSBvYmo7XG5cdFx0aWYgKHZhbHMuciAhPT0gdW5kZWZpbmVkIHx8IHZhbHMucmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMubCAhPT0gdW5kZWZpbmVkIHx8IHZhbHMubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudiAhPT0gdW5kZWZpbmVkIHx8IHZhbHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzdicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy53ICE9PSB1bmRlZmluZWQgfHwgdmFscy53aGl0ZW5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5jICE9PSB1bmRlZmluZWQgfHwgdmFscy5jeWFuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdjbXlrJywgdmFscyk7XG5cdFx0fVxuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0fSxcblx0cmdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ3JnYicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc2wnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc3Y6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHN2JywgYXJndW1lbnRzKTtcblx0fSxcblx0aHdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2h3YicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNteWs6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnY215aycsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0cmdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuXHR9LFxuXHRoc2xBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG5cdH0sXG5cdGhzdkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcblx0fSxcblx0aHdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcy5od2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcy5od2I7XG5cdH0sXG5cdGNteWtBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuXHR9LFxuXHRyZ2JhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5yZ2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0aHNsYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMuaHNsLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIHZhbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMCwgdmFsKTtcblx0fSxcblx0Z3JlZW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMiwgdmFsKTtcblx0fSxcblx0aHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dmFsICU9IDM2MDtcblx0XHRcdHZhbCA9IHZhbCA8IDAgPyAzNjAgKyB2YWwgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDAsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAxLCB2YWwpO1xuXHR9LFxuXHRsaWdodG5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAyLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9udjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDEsIHZhbCk7XG5cdH0sXG5cdHdoaXRlbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsYWNrbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDIsIHZhbCk7XG5cdH0sXG5cdHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMiwgdmFsKTtcblx0fSxcblx0Y3lhbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAwLCB2YWwpO1xuXHR9LFxuXHRtYWdlbnRhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDEsIHZhbCk7XG5cdH0sXG5cdHllbGxvdzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAyLCB2YWwpO1xuXHR9LFxuXHRibGFjazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAzLCB2YWwpO1xuXHR9LFxuXG5cdGhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcucmdiU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRyZ2JhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZ2JhU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLmhzbFN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBzdHJpbmcuaHNsYVN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gc3RyaW5nLmtleXdvcmQodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cblx0cmdiTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHRyZXR1cm4gKHJnYlswXSA8PCAxNikgfCAocmdiWzFdIDw8IDgpIHwgcmdiWzJdO1xuXHR9LFxuXG5cdGx1bWlub3NpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgbHVtID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjaGFuID0gcmdiW2ldIC8gMjU1O1xuXHRcdFx0bHVtW2ldID0gKGNoYW4gPD0gMC4wMzkyOCkgPyBjaGFuIC8gMTIuOTIgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG5cdFx0dmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHR2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cdFx0aWYgKGx1bTEgPiBsdW0yKSB7XG5cdFx0XHRyZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSk7XG5cdFx0fVxuXHRcdHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcblx0fSxcblxuXHRsZXZlbDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuXHRcdGlmIChjb250cmFzdFJhdGlvID49IDcuMSkge1xuXHRcdFx0cmV0dXJuICdBQUEnO1xuXHRcdH1cblxuXHRcdHJldHVybiAoY29udHJhc3RSYXRpbyA+PSA0LjUpID8gJ0FBJyA6ICcnO1xuXHR9LFxuXG5cdGRhcms6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuXHRcdHJldHVybiB5aXEgPCAxMjg7XG5cdH0sXG5cblx0bGlnaHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuZGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gMjU1IC0gdGhpcy52YWx1ZXMucmdiW2ldO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgcmdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsaWdodGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSArPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkYXJrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdIC09IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSArPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZXNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSAtPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3aGl0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzFdICs9IGh3YlsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGJsYWNrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzJdICs9IGh3YlsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdyZXlzY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcblx0XHR2YXIgdmFsID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIFt2YWwsIHZhbCwgdmFsXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xlYXJlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgLSAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9wYXF1ZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhICsgKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHR2YXIgaHVlID0gKGhzbFswXSArIGRlZ3JlZXMpICUgMzYwO1xuXHRcdGhzbFswXSA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvcnRlZCBmcm9tIHNhc3MgaW1wbGVtZW50YXRpb24gaW4gQ1xuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0ICovXG5cdG1peDogZnVuY3Rpb24gKG1peGluQ29sb3IsIHdlaWdodCkge1xuXHRcdHZhciBjb2xvcjEgPSB0aGlzO1xuXHRcdHZhciBjb2xvcjIgPSBtaXhpbkNvbG9yO1xuXHRcdHZhciBwID0gd2VpZ2h0ID09PSB1bmRlZmluZWQgPyAwLjUgOiB3ZWlnaHQ7XG5cblx0XHR2YXIgdyA9IDIgKiBwIC0gMTtcblx0XHR2YXIgYSA9IGNvbG9yMS5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cblx0XHR2YXIgdzEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHR2YXIgdzIgPSAxIC0gdzE7XG5cblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0LnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKVxuXHRcdFx0KVxuXHRcdFx0LmFscGhhKGNvbG9yMS5hbHBoYSgpICogcCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSBwKSk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmdiKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBOT1RFKFNCKTogdXNpbmcgbm9kZS1jbG9uZSBjcmVhdGVzIGEgZGVwZW5kZW5jeSB0byBCdWZmZXIgd2hlbiB1c2luZyBicm93c2VyaWZ5LFxuXHRcdC8vIG1ha2luZyB0aGUgZmluYWwgYnVpbGQgd2F5IHRvIGJpZyB0byBlbWJlZCBpbiBDaGFydC5qcy4gU28gbGV0J3MgZG8gaXQgbWFudWFsbHksXG5cdFx0Ly8gYXNzdW1pbmcgdGhhdCB2YWx1ZXMgdG8gY2xvbmUgYXJlIDEgZGltZW5zaW9uIGFycmF5cyBjb250YWluaW5nIG9ubHkgbnVtYmVycyxcblx0XHQvLyBleGNlcHQgJ2FscGhhJyB3aGljaCBpcyBhIG51bWJlci5cblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbG9yKCk7XG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMudmFsdWVzO1xuXHRcdHZhciB0YXJnZXQgPSByZXN1bHQudmFsdWVzO1xuXHRcdHZhciB2YWx1ZSwgdHlwZTtcblxuXHRcdGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHZhbHVlID0gc291cmNlW3Byb3BdO1xuXHRcdFx0XHR0eXBlID0gKHt9KS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZS5zbGljZSgwKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ3VuZXhwZWN0ZWQgY29sb3IgdmFsdWU6JywgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlLnNwYWNlcyA9IHtcblx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0aHN2OiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ3ZhbHVlJ10sXG5cdGh3YjogWydodWUnLCAnd2hpdGVuZXNzJywgJ2JsYWNrbmVzcyddLFxuXHRjbXlrOiBbJ2N5YW4nLCAnbWFnZW50YScsICd5ZWxsb3cnLCAnYmxhY2snXVxufTtcblxuQ29sb3IucHJvdG90eXBlLm1heGVzID0ge1xuXHRyZ2I6IFsyNTUsIDI1NSwgMjU1XSxcblx0aHNsOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGhzdjogWzM2MCwgMTAwLCAxMDBdLFxuXHRod2I6IFszNjAsIDEwMCwgMTAwXSxcblx0Y215azogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgdmFscyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHR2YWxzW3NwYWNlLmNoYXJBdChpKV0gPSB2YWx1ZXNbc3BhY2VdW2ldO1xuXHR9XG5cblx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdHZhbHMuYSA9IHZhbHVlcy5hbHBoYTtcblx0fVxuXG5cdC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG5cdHJldHVybiB2YWxzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSwgdmFscykge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciBzcGFjZXMgPSB0aGlzLnNwYWNlcztcblx0dmFyIG1heGVzID0gdGhpcy5tYXhlcztcblx0dmFyIGFscGhhID0gMTtcblx0dmFyIGk7XG5cblx0dGhpcy52YWxpZCA9IHRydWU7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0YWxwaGEgPSB2YWxzO1xuXHR9IGVsc2UgaWYgKHZhbHMubGVuZ3RoKSB7XG5cdFx0Ly8gWzEwLCAxMCwgMTBdXG5cdFx0dmFsdWVzW3NwYWNlXSA9IHZhbHMuc2xpY2UoMCwgc3BhY2UubGVuZ3RoKTtcblx0XHRhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlLmNoYXJBdCgwKV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbc3BhY2UuY2hhckF0KGkpXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlc1tzcGFjZV1bMF1dICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cblx0XHR2YXIgY2hhbnMgPSBzcGFjZXNbc3BhY2VdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tjaGFuc1tpXV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmFscGhhO1xuXHR9XG5cblx0dmFsdWVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGFscGhhID09PSB1bmRlZmluZWQgPyB2YWx1ZXMuYWxwaGEgOiBhbHBoYSkpKTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgY2FwcGVkO1xuXG5cdC8vIGNhcCB2YWx1ZXMgb2YgdGhlIHNwYWNlIHByaW9yIGNvbnZlcnRpbmcgYWxsIHZhbHVlc1xuXHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHZhbHVlc1tzcGFjZV1baV0pKTtcblx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuXHR9XG5cblx0Ly8gY29udmVydCB0byBhbGwgdGhlIG90aGVyIGNvbG9yIHNwYWNlc1xuXHRmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcblx0XHRpZiAoc25hbWUgIT09IHNwYWNlKSB7XG5cdFx0XHR2YWx1ZXNbc25hbWVdID0gY29udmVydFtzcGFjZV1bc25hbWVdKHZhbHVlc1tzcGFjZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24gKHNwYWNlLCBhcmdzKSB7XG5cdHZhciB2YWxzID0gYXJnc1swXTtcblxuXHRpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmdiKClcblx0XHRyZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuXHR9XG5cblx0Ly8gY29sb3IucmdiKDEwLCAxMCwgMTApXG5cdGlmICh0eXBlb2YgdmFscyA9PT0gJ251bWJlcicpIHtcblx0XHR2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFscyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoc3BhY2UsIGluZGV4LCB2YWwpIHtcblx0dmFyIHN2YWx1ZXMgPSB0aGlzLnZhbHVlc1tzcGFjZV07XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJlZCgpXG5cdFx0cmV0dXJuIHN2YWx1ZXNbaW5kZXhdO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gc3ZhbHVlc1tpbmRleF0pIHtcblx0XHQvLyBjb2xvci5yZWQoY29sb3IucmVkKCkpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBjb2xvci5yZWQoMTAwKVxuXHRzdmFsdWVzW2luZGV4XSA9IHZhbDtcblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHN2YWx1ZXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5Db2xvciA9IENvbG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLyogTUlUIGxpY2Vuc2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJod2I6IHJnYjJod2IsXG4gIHJnYjJjbXlrOiByZ2IyY215ayxcbiAgcmdiMmtleXdvcmQ6IHJnYjJrZXl3b3JkLFxuICByZ2IyeHl6OiByZ2IyeHl6LFxuICByZ2IybGFiOiByZ2IybGFiLFxuICByZ2IybGNoOiByZ2IybGNoLFxuXG4gIGhzbDJyZ2I6IGhzbDJyZ2IsXG4gIGhzbDJoc3Y6IGhzbDJoc3YsXG4gIGhzbDJod2I6IGhzbDJod2IsXG4gIGhzbDJjbXlrOiBoc2wyY215ayxcbiAgaHNsMmtleXdvcmQ6IGhzbDJrZXl3b3JkLFxuXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIGhzdjJoc2w6IGhzdjJoc2wsXG4gIGhzdjJod2I6IGhzdjJod2IsXG4gIGhzdjJjbXlrOiBoc3YyY215ayxcbiAgaHN2MmtleXdvcmQ6IGhzdjJrZXl3b3JkLFxuXG4gIGh3YjJyZ2I6IGh3YjJyZ2IsXG4gIGh3YjJoc2w6IGh3YjJoc2wsXG4gIGh3YjJoc3Y6IGh3YjJoc3YsXG4gIGh3YjJjbXlrOiBod2IyY215ayxcbiAgaHdiMmtleXdvcmQ6IGh3YjJrZXl3b3JkLFxuXG4gIGNteWsycmdiOiBjbXlrMnJnYixcbiAgY215azJoc2w6IGNteWsyaHNsLFxuICBjbXlrMmhzdjogY215azJoc3YsXG4gIGNteWsyaHdiOiBjbXlrMmh3YixcbiAgY215azJrZXl3b3JkOiBjbXlrMmtleXdvcmQsXG5cbiAga2V5d29yZDJyZ2I6IGtleXdvcmQycmdiLFxuICBrZXl3b3JkMmhzbDoga2V5d29yZDJoc2wsXG4gIGtleXdvcmQyaHN2OiBrZXl3b3JkMmhzdixcbiAga2V5d29yZDJod2I6IGtleXdvcmQyaHdiLFxuICBrZXl3b3JkMmNteWs6IGtleXdvcmQyY215ayxcbiAga2V5d29yZDJsYWI6IGtleXdvcmQybGFiLFxuICBrZXl3b3JkMnh5ejoga2V5d29yZDJ4eXosXG5cbiAgeHl6MnJnYjogeHl6MnJnYixcbiAgeHl6MmxhYjogeHl6MmxhYixcbiAgeHl6MmxjaDogeHl6MmxjaCxcblxuICBsYWIyeHl6OiBsYWIyeHl6LFxuICBsYWIycmdiOiBsYWIycmdiLFxuICBsYWIybGNoOiBsYWIybGNoLFxuXG4gIGxjaDJsYWI6IGxjaDJsYWIsXG4gIGxjaDJ4eXo6IGxjaDJ4eXosXG4gIGxjaDJyZ2I6IGxjaDJyZ2Jcbn1cblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYlswXS8yNTUsXG4gICAgICBnID0gcmdiWzFdLzI1NSxcbiAgICAgIGIgPSByZ2JbMl0vMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgbDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKS8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgbCA9IChtaW4gKyBtYXgpIC8gMjtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBzID0gMDtcbiAgZWxzZSBpZiAobCA8PSAwLjUpXG4gICAgcyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIGVsc2VcbiAgICBzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cbiAgcmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmhzdihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIHY7XG5cbiAgaWYgKG1heCA9PSAwKVxuICAgIHMgPSAwO1xuICBlbHNlXG4gICAgcyA9IChkZWx0YS9tYXggKiAxMDAwKS8xMDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG4gIHJldHVybiBbaCwgcywgdl07XG59XG5cbmZ1bmN0aW9uIHJnYjJod2IocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBoID0gcmdiMmhzbChyZ2IpWzBdLFxuICAgICAgdyA9IDEvMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpLFxuICAgICAgYiA9IDEgLSAxLzI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyY215ayhyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NSxcbiAgICAgIGMsIG0sIHksIGs7XG5cbiAgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2Iya2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShyZ2IpXTtcbn1cblxuZnVuY3Rpb24gcmdiMnh5eihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcbiAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG4gIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG4gIHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuICB2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcbiAgdmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cbiAgcmV0dXJuIFt4ICogMTAwLCB5ICoxMDAsIHogKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IybGFiKHJnYikge1xuICB2YXIgeHl6ID0gcmdiMnh5eihyZ2IpLFxuICAgICAgICB4ID0geHl6WzBdLFxuICAgICAgICB5ID0geHl6WzFdLFxuICAgICAgICB6ID0geHl6WzJdLFxuICAgICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHJnYjJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wycmdiKGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSAvIDM2MCxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgdDEsIHQyLCB0MywgcmdiLCB2YWw7XG5cbiAgaWYgKHMgPT0gMCkge1xuICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIGlmIChsIDwgMC41KVxuICAgIHQyID0gbCAqICgxICsgcyk7XG4gIGVsc2VcbiAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gIHQxID0gMiAqIGwgLSB0MjtcblxuICByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdDMgPSBoICsgMSAvIDMgKiAtIChpIC0gMSk7XG4gICAgdDMgPCAwICYmIHQzKys7XG4gICAgdDMgPiAxICYmIHQzLS07XG5cbiAgICBpZiAoNiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgIGVsc2UgaWYgKDIgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MjtcbiAgICBlbHNlIGlmICgzICogdDMgPCAyKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgIGVsc2VcbiAgICAgIHZhbCA9IHQxO1xuXG4gICAgcmdiW2ldID0gdmFsICogMjU1O1xuICB9XG5cbiAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gaHNsMmhzdihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0sXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHN2LCB2O1xuXG4gIGlmKGwgPT09IDApIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZG8gY2FsYyBvbiBibGFja1xuICAgICAgLy8gYWxzbyBhdm9pZHMgZGl2aWRlIGJ5IDAgZXJyb3JcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBsICo9IDI7XG4gIHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHYgPSAobCArIHMpIC8gMjtcbiAgc3YgPSAoMiAqIHMpIC8gKGwgKyBzKTtcbiAgcmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzbDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzbDJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIGhzdjJyZ2IoaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdIC8gNjAsXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cbiAgdmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKSxcbiAgICAgIHAgPSAyNTUgKiB2ICogKDEgLSBzKSxcbiAgICAgIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKSxcbiAgICAgIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKSxcbiAgICAgIHYgPSAyNTUgKiB2O1xuXG4gIHN3aXRjaChoaSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBbdiwgdCwgcF07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW3AsIHYsIHRdO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBbcCwgcSwgdl07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gW3YsIHAsIHFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhzdjJoc2woaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBzbCwgbDtcblxuICBsID0gKDIgLSBzKSAqIHY7XG4gIHNsID0gcyAqIHY7XG4gIHNsIC89IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICBzbCA9IHNsIHx8IDA7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzdjJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc3YycmdiKGFyZ3MpKVxufVxuXG5mdW5jdGlvbiBoc3YyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc3YycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHN2MmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHN2MnJnYihhcmdzKSk7XG59XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuZnVuY3Rpb24gaHdiMnJnYihod2IpIHtcbiAgdmFyIGggPSBod2JbMF0gLyAzNjAsXG4gICAgICB3aCA9IGh3YlsxXSAvIDEwMCxcbiAgICAgIGJsID0gaHdiWzJdIC8gMTAwLFxuICAgICAgcmF0aW8gPSB3aCArIGJsLFxuICAgICAgaSwgdiwgZiwgbjtcblxuICAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG4gIGlmIChyYXRpbyA+IDEpIHtcbiAgICB3aCAvPSByYXRpbztcbiAgICBibCAvPSByYXRpbztcbiAgfVxuXG4gIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgdiA9IDEgLSBibDtcbiAgZiA9IDYgKiBoIC0gaTtcbiAgaWYgKChpICYgMHgwMSkgIT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBuID0gd2ggKyBmICogKHYgLSB3aCk7ICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2Iya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJyZ2IoY215aykge1xuICB2YXIgYyA9IGNteWtbMF0gLyAxMDAsXG4gICAgICBtID0gY215a1sxXSAvIDEwMCxcbiAgICAgIHkgPSBjbXlrWzJdIC8gMTAwLFxuICAgICAgayA9IGNteWtbM10gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGNteWsyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChjbXlrMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24geHl6MnJnYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0gLyAxMDAsXG4gICAgICB5ID0geHl6WzFdIC8gMTAwLFxuICAgICAgeiA9IHh5elsyXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IHIgPSAociAqIDEyLjkyKTtcblxuICBnID0gZyA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogZyA9IChnICogMTIuOTIpO1xuXG4gIGIgPSBiID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBiID0gKGIgKiAxMi45Mik7XG5cbiAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSxcbiAgICAgIHkgPSB4eXpbMV0sXG4gICAgICB6ID0geHl6WzJdLFxuICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHh5ejJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaCh4eXoybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIHgsIHksIHosIHkyO1xuXG4gIGlmIChsIDw9IDgpIHtcbiAgICB5ID0gKGwgKiAxMDApIC8gOTAzLjM7XG4gICAgeTIgPSAoNy43ODcgKiAoeSAvIDEwMCkpICsgKDE2IC8gMTE2KTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMTAwICogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpO1xuICAgIHkyID0gTWF0aC5wb3coeSAvIDEwMCwgMS8zKTtcbiAgfVxuXG4gIHggPSB4IC8gOTUuMDQ3IDw9IDAuMDA4ODU2ID8geCA9ICg5NS4wNDcgKiAoKGEgLyA1MDApICsgeTIgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDk1LjA0NyAqIE1hdGgucG93KChhIC8gNTAwKSArIHkyLCAzKTtcblxuICB6ID0geiAvIDEwOC44ODMgPD0gMC4wMDg4NTkgPyB6ID0gKDEwOC44ODMgKiAoeTIgLSAoYiAvIDIwMCkgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDEwOC44ODMgKiBNYXRoLnBvdyh5MiAtIChiIC8gMjAwKSwgMyk7XG5cbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuZnVuY3Rpb24gbGFiMmxjaChsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIGhyLCBoLCBjO1xuXG4gIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59XG5cbmZ1bmN0aW9uIGxhYjJyZ2IoYXJncykge1xuICByZXR1cm4geHl6MnJnYihsYWIyeHl6KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMmxhYihsY2gpIHtcbiAgdmFyIGwgPSBsY2hbMF0sXG4gICAgICBjID0gbGNoWzFdLFxuICAgICAgaCA9IGxjaFsyXSxcbiAgICAgIGEsIGIsIGhyO1xuXG4gIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIGxjaDJ4eXooYXJncykge1xuICByZXR1cm4gbGFiMnh5eihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMnJnYihhcmdzKSB7XG4gIHJldHVybiBsYWIycmdiKGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnJnYihrZXl3b3JkKSB7XG4gIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3Yoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJsYWIoYXJncykge1xuICByZXR1cm4gcmdiMmxhYihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJ4eXooa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG52YXIgY3NzS2V5d29yZHMgPSB7XG4gIGFsaWNlYmx1ZTogIFsyNDAsMjQ4LDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwyMzUsMjE1XSxcbiAgYXF1YTogWzAsMjU1LDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsMjU1LDIxMl0sXG4gIGF6dXJlOiAgWzI0MCwyNTUsMjU1XSxcbiAgYmVpZ2U6ICBbMjQ1LDI0NSwyMjBdLFxuICBiaXNxdWU6IFsyNTUsMjI4LDE5Nl0sXG4gIGJsYWNrOiAgWzAsMCwwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsMjM1LDIwNV0sXG4gIGJsdWU6IFswLDAsMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCw0MywyMjZdLFxuICBicm93bjogIFsxNjUsNDIsNDJdLFxuICBidXJseXdvb2Q6ICBbMjIyLDE4NCwxMzVdLFxuICBjYWRldGJsdWU6ICBbOTUsMTU4LDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsMjU1LDBdLFxuICBjaG9jb2xhdGU6ICBbMjEwLDEwNSwzMF0sXG4gIGNvcmFsOiAgWzI1NSwxMjcsODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwxNDksMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsMjQ4LDIyMF0sXG4gIGNyaW1zb246ICBbMjIwLDIwLDYwXSxcbiAgY3lhbjogWzAsMjU1LDI1NV0sXG4gIGRhcmtibHVlOiBbMCwwLDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwxMzksMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogIFsxODQsMTM0LDExXSxcbiAgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtncmVlbjogIFswLDEwMCwwXSxcbiAgZGFya2dyZXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtraGFraTogIFsxODksMTgzLDEwN10sXG4gIGRhcmttYWdlbnRhOiAgWzEzOSwwLDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSxcbiAgZGFya3JlZDogIFsxMzksMCwwXSxcbiAgZGFya3NhbG1vbjogWzIzMywxNTAsMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLDE4OCwxNDNdLFxuICBkYXJrc2xhdGVibHVlOiAgWzcyLDYxLDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6ICBbNDcsNzksNzldLFxuICBkYXJrc2xhdGVncmV5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3R1cnF1b2lzZTogIFswLDIwNiwyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LDAsMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsMjAsMTQ3XSxcbiAgZGVlcHNreWJsdWU6ICBbMCwxOTEsMjU1XSxcbiAgZGltZ3JheTogIFsxMDUsMTA1LDEwNV0sXG4gIGRpbWdyZXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsMTQ0LDI1NV0sXG4gIGZpcmVicmljazogIFsxNzgsMzQsMzRdLFxuICBmbG9yYWx3aGl0ZTogIFsyNTUsMjUwLDI0MF0sXG4gIGZvcmVzdGdyZWVuOiAgWzM0LDEzOSwzNF0sXG4gIGZ1Y2hzaWE6ICBbMjU1LDAsMjU1XSxcbiAgZ2FpbnNib3JvOiAgWzIyMCwyMjAsMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwyNDgsMjU1XSxcbiAgZ29sZDogWzI1NSwyMTUsMF0sXG4gIGdvbGRlbnJvZDogIFsyMTgsMTY1LDMyXSxcbiAgZ3JheTogWzEyOCwxMjgsMTI4XSxcbiAgZ3JlZW46ICBbMCwxMjgsMF0sXG4gIGdyZWVueWVsbG93OiAgWzE3MywyNTUsNDddLFxuICBncmV5OiBbMTI4LDEyOCwxMjhdLFxuICBob25leWRldzogWzI0MCwyNTUsMjQwXSxcbiAgaG90cGluazogIFsyNTUsMTA1LDE4MF0sXG4gIGluZGlhbnJlZDogIFsyMDUsOTIsOTJdLFxuICBpbmRpZ286IFs3NSwwLDEzMF0sXG4gIGl2b3J5OiAgWzI1NSwyNTUsMjQwXSxcbiAga2hha2k6ICBbMjQwLDIzMCwxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwyMzAsMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogIFsyNTUsMjQwLDI0NV0sXG4gIGxhd25ncmVlbjogIFsxMjQsMjUyLDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsMjUwLDIwNV0sXG4gIGxpZ2h0Ymx1ZTogIFsxNzMsMjE2LDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsMTI4LDEyOF0sXG4gIGxpZ2h0Y3lhbjogIFsyMjQsMjU1LDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLFxuICBsaWdodGdyYXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LDIzOCwxNDRdLFxuICBsaWdodGdyZXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodHBpbms6ICBbMjU1LDE4MiwxOTNdLFxuICBsaWdodHNhbG1vbjogIFsyNTUsMTYwLDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46ICBbMzIsMTc4LDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwyMDYsMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwxOTYsMjIyXSxcbiAgbGlnaHR5ZWxsb3c6ICBbMjU1LDI1NSwyMjRdLFxuICBsaW1lOiBbMCwyNTUsMF0sXG4gIGxpbWVncmVlbjogIFs1MCwyMDUsNTBdLFxuICBsaW5lbjogIFsyNTAsMjQwLDIzMF0sXG4gIG1hZ2VudGE6ICBbMjU1LDAsMjU1XSxcbiAgbWFyb29uOiBbMTI4LDAsMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLDAsMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiAgWzEyMywxMDQsMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICBbMCwyNTAsMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiAgWzcyLDIwOSwyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6ICBbMTk5LDIxLDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LDI1LDExMl0sXG4gIG1pbnRjcmVhbTogIFsyNDUsMjU1LDI1MF0sXG4gIG1pc3R5cm9zZTogIFsyNTUsMjI4LDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxuICBuYXZham93aGl0ZTogIFsyNTUsMjIyLDE3M10sXG4gIG5hdnk6IFswLDAsMTI4XSxcbiAgb2xkbGFjZTogIFsyNTMsMjQ1LDIzMF0sXG4gIG9saXZlOiAgWzEyOCwxMjgsMF0sXG4gIG9saXZlZHJhYjogIFsxMDcsMTQyLDM1XSxcbiAgb3JhbmdlOiBbMjU1LDE2NSwwXSxcbiAgb3JhbmdlcmVkOiAgWzI1NSw2OSwwXSxcbiAgb3JjaGlkOiBbMjE4LDExMiwyMTRdLFxuICBwYWxlZ29sZGVucm9kOiAgWzIzOCwyMzIsMTcwXSxcbiAgcGFsZWdyZWVuOiAgWzE1MiwyNTEsMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogIFsxNzUsMjM4LDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6ICBbMjE5LDExMiwxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLFxuICBwZWFjaHB1ZmY6ICBbMjU1LDIxOCwxODVdLFxuICBwZXJ1OiBbMjA1LDEzMyw2M10sXG4gIHBpbms6IFsyNTUsMTkyLDIwM10sXG4gIHBsdW06IFsyMjEsMTYwLDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsMjI0LDIzMF0sXG4gIHB1cnBsZTogWzEyOCwwLDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6ICBbMjU1LDAsMF0sXG4gIHJvc3licm93bjogIFsxODgsMTQzLDE0M10sXG4gIHJveWFsYmx1ZTogIFs2NSwxMDUsMjI1XSxcbiAgc2FkZGxlYnJvd246ICBbMTM5LDY5LDE5XSxcbiAgc2FsbW9uOiBbMjUwLDEyOCwxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LDE2NCw5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsMTM5LDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsMjQ1LDIzOF0sXG4gIHNpZW5uYTogWzE2MCw4Miw0NV0sXG4gIHNpbHZlcjogWzE5MiwxOTIsMTkyXSxcbiAgc2t5Ymx1ZTogIFsxMzUsMjA2LDIzNV0sXG4gIHNsYXRlYmx1ZTogIFsxMDYsOTAsMjA1XSxcbiAgc2xhdGVncmF5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc2xhdGVncmV5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc25vdzogWzI1NSwyNTAsMjUwXSxcbiAgc3ByaW5nZ3JlZW46ICBbMCwyNTUsMTI3XSxcbiAgc3RlZWxibHVlOiAgWzcwLDEzMCwxODBdLFxuICB0YW46ICBbMjEwLDE4MCwxNDBdLFxuICB0ZWFsOiBbMCwxMjgsMTI4XSxcbiAgdGhpc3RsZTogIFsyMTYsMTkxLDIxNl0sXG4gIHRvbWF0bzogWzI1NSw5OSw3MV0sXG4gIHR1cnF1b2lzZTogIFs2NCwyMjQsMjA4XSxcbiAgdmlvbGV0OiBbMjM4LDEzMCwyMzhdLFxuICB3aGVhdDogIFsyNDUsMjIyLDE3OV0sXG4gIHdoaXRlOiAgWzI1NSwyNTUsMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSxcbiAgeWVsbG93OiBbMjU1LDI1NSwwXSxcbiAgeWVsbG93Z3JlZW46ICBbMTU0LDIwNSw1MF1cbn07XG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuICByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkoY3NzS2V5d29yZHNba2V5XSldID0ga2V5O1xufVxuIiwidmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZShcIi4vY29udmVyc2lvbnNcIik7XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufVxuXG5mb3IgKHZhciBmdW5jIGluIGNvbnZlcnNpb25zKSB7XG4gIC8vIGV4cG9ydCBSYXcgdmVyc2lvbnNcbiAgY29udmVydFtmdW5jICsgXCJSYXdcIl0gPSAgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBhY2NlcHQgYXJyYXkgb3IgcGxhaW4gYXJnc1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICB9XG4gIH0pKGZ1bmMpO1xuXG4gIHZhciBwYWlyID0gLyhcXHcrKTIoXFx3KykvLmV4ZWMoZnVuYyksXG4gICAgICBmcm9tID0gcGFpclsxXSxcbiAgICAgIHRvID0gcGFpclsyXTtcblxuICAvLyBleHBvcnQgcmdiMmhzbCBhbmQgW1wicmdiXCJdW1wiaHNsXCJdXG4gIGNvbnZlcnRbZnJvbV0gPSBjb252ZXJ0W2Zyb21dIHx8IHt9O1xuXG4gIGNvbnZlcnRbZnJvbV1bdG9dID0gY29udmVydFtmdW5jXSA9IChmdW5jdGlvbihmdW5jKSB7IFxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHZhciB2YWwgPSBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHZhbDsgLy8ga2V5d29yZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsW2ldID0gTWF0aC5yb3VuZCh2YWxbaV0pO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pKGZ1bmMpO1xufVxuXG5cbi8qIENvbnZlcnRlciBkb2VzIGxhenkgY29udmVyc2lvbiBhbmQgY2FjaGluZyAqL1xudmFyIENvbnZlcnRlciA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5jb252cyA9IHt9O1xufTtcblxuLyogRWl0aGVyIGdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlIG9yXG4gIHNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBkZXBlbmRpbmcgb24gYXJncyAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5yb3V0ZVNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWx1ZXMgPSBhcmdzWzBdO1xuICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7ICAgICAgICBcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWx1ZXMpO1xufTtcbiAgXG4vKiBTZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgaW52YWxpZGF0aW5nIGNhY2hlICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWx1ZXMpIHtcbiAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgIHRoaXMuY29udnMgPSB7fTtcbiAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFsdWVzO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBHZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZS4gSWYgdGhlcmUncyBhbHJlYWR5XG4gIGEgY29udmVyc2lvbiBmb3IgdGhlIHNwYWNlLCBmZXRjaCBpdCwgb3RoZXJ3aXNlXG4gIGNvbXB1dGUgaXQgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UpIHtcbiAgIHZhciB2YWxzID0gdGhpcy5jb252c1tzcGFjZV07XG4gICBpZiAoIXZhbHMpIHtcbiAgICAgIHZhciBmc3BhY2UgPSB0aGlzLnNwYWNlLFxuICAgICAgICAgIGZyb20gPSB0aGlzLmNvbnZzW2ZzcGFjZV07XG4gICAgICB2YWxzID0gY29udmVydFtmc3BhY2VdW3NwYWNlXShmcm9tKTtcblxuICAgICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWxzO1xuICAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbltcInJnYlwiLCBcImhzbFwiLCBcImhzdlwiLCBcImNteWtcIiwgXCJrZXl3b3JkXCJdLmZvckVhY2goZnVuY3Rpb24oc3BhY2UpIHtcbiAgIENvbnZlcnRlci5wcm90b3R5cGVbc3BhY2VdID0gZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVTcGFjZShzcGFjZSwgYXJndW1lbnRzKTtcbiAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7IiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXHJcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxyXG5cdFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXHJcblx0XCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXHJcblx0XCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXHJcblx0XCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxyXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxyXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxyXG5cdFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcclxuXHRcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXHJcblx0XCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxyXG5cdFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcclxuXHRcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcclxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcclxuXHRcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcclxuXHRcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxyXG5cdFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxyXG5cdFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxyXG5cdFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxyXG5cdFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXHJcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxyXG5cdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcclxuXHRcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcclxuXHRcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXHJcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxyXG5cdFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcclxuXHRcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcclxuXHRcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXHJcblx0XCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxyXG5cdFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXHJcblx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxyXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxyXG5cdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcclxuXHRcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcclxuXHRcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxyXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcclxuXHRcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxyXG5cdFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXHJcblx0XCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXHJcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxyXG5cdFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcclxuXHRcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxyXG5cdFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxyXG5cdFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxyXG5cdFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJncmVlblwiOiBbMCwgMTI4LCAwXSxcclxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxyXG5cdFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXHJcblx0XCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcclxuXHRcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxyXG5cdFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcclxuXHRcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcclxuXHRcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcclxuXHRcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcclxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxyXG5cdFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXHJcblx0XCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxyXG5cdFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcclxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxyXG5cdFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcclxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcclxuXHRcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcclxuXHRcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxyXG5cdFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxyXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcclxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXHJcblx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXHJcblx0XCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXHJcblx0XCJsaW1lXCI6IFswLCAyNTUsIDBdLFxyXG5cdFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXHJcblx0XCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXHJcblx0XCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXHJcblx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcclxuXHRcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXHJcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXHJcblx0XCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxyXG5cdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXHJcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxyXG5cdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcclxuXHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcclxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcclxuXHRcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxyXG5cdFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcclxuXHRcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXHJcblx0XCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXHJcblx0XCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXHJcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxyXG5cdFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXHJcblx0XCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxyXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxyXG5cdFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXHJcblx0XCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxyXG5cdFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcclxuXHRcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxyXG5cdFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcclxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxyXG5cdFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXHJcblx0XCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcclxuXHRcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXHJcblx0XCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxyXG5cdFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXHJcblx0XCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcclxuXHRcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxyXG5cdFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXHJcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxyXG5cdFwicmVkXCI6IFsyNTUsIDAsIDBdLFxyXG5cdFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcclxuXHRcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcclxuXHRcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXHJcblx0XCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxyXG5cdFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcclxuXHRcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXHJcblx0XCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXHJcblx0XCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcclxuXHRcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXHJcblx0XCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcclxuXHRcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcclxuXHRcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXHJcblx0XCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxyXG5cdFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxyXG5cdFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcclxuXHRcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcclxuXHRcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxyXG5cdFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXHJcblx0XCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXHJcblx0XCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxyXG5cdFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxyXG5cdFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxyXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXHJcblx0XCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcclxuXHRcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXHJcbn07XHJcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xOC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIHZhciBrO1xuICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgLy8gZXZlbiBpZiBpdHMgbm90IG93biBwcm9wZXJ0eSBJJ2Qgc3RpbGwgY2FsbCBpdCBub24tZW1wdHlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgIH1cbiAgICByZXR1cm4gbS5fcGY7XG59XG5cbnZhciBzb21lO1xuaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xufSBlbHNlIHtcbiAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG52YXIgc29tZSQxID0gc29tZTtcblxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUkMS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbmZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xufVxuXG52YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4vLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgLy8gb2JqZWN0cy5cbiAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xufVxuXG5mdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgIHZhbHVlID0gMDtcblxuICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgZm4pO1xufVxuXG52YXIgZGVwcmVjYXRpb25zID0ge307XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgfVxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB9XG59XG5cbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgdmFyIHByb3AsIGk7XG4gICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgfVxufVxuXG52YXIga2V5cztcblxuaWYgKE9iamVjdC5rZXlzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xufSBlbHNlIHtcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5cbnZhciBrZXlzJDEgPSBrZXlzO1xuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgIHNhbWVFbHNlIDogJ0wnXG59O1xuXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG59XG5cbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbn1cblxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xufVxuXG52YXIgYWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xufVxuXG52YXIgcHJpb3JpdGllcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xufVxuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbnZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4vLyB0b2tlbjogICAgJ00nXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4vLyBvcmRpbmFsOiAgJ01vJ1xuLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgfVxuICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbmZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICB2YXIgaSA9IDU7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgfVxuXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxudmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xudmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbnZhciByZWdleGVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cblxudmFyIFlFQVIgPSAwO1xudmFyIE1PTlRIID0gMTtcbnZhciBEQVRFID0gMjtcbnZhciBIT1VSID0gMztcbnZhciBNSU5VVEUgPSA0O1xudmFyIFNFQ09ORCA9IDU7XG52YXIgTUlMTElTRUNPTkQgPSA2O1xudmFyIFdFRUsgPSA3O1xudmFyIFdFRUtEQVkgPSA4O1xuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxudmFyIGluZGV4T2YkMSA9IGluZGV4T2Y7XG5cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xudmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIG1vbTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbmFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG5hZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufVxuXG4vLyBIT09LU1xuXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG59O1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuLy8gbW9udGhzXG4vLyB3ZWVrXG4vLyB3ZWVrZGF5c1xuLy8gbWVyaWRpZW1cbnZhciBiYXNlQ29uZmlnID0ge1xuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzJDEobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGlzbyA4NjAxIHJlZ2V4XG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xudmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxudmFyIGlzb0RhdGVzID0gW1xuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXG5dO1xuXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG52YXIgaXNvVGltZXMgPSBbXG4gICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgWydISCcsIC9cXGRcXGQvXVxuXTtcblxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbnZhciBiYXNpY1JmY1JlZ2V4ID0gL14oKD86TW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkP1xcZFxccyg/OkphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyg/OlxcZFxcZCk/XFxkXFxkXFxzKShcXGRcXGQ6XFxkXFxkKShcXDpcXGRcXGQpPyhcXHMoPzpVVHxHTVR8W0VDTVBdW1NEXVR8W0EtSUstWmEtaWstel18WystXVxcZHs0fSkpJC87XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBzdHJpbmcsIG1hdGNoLCBkYXlGb3JtYXQsXG4gICAgICAgIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuICAgIHZhciB0aW1lem9uZXMgPSB7XG4gICAgICAgICcgR01UJzogJyArMDAwMCcsXG4gICAgICAgICcgRURUJzogJyAtMDQwMCcsXG4gICAgICAgICcgRVNUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ0RUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ1NUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTURUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTVNUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUERUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUFNUJzogJyAtMDgwMCdcbiAgICB9O1xuICAgIHZhciBtaWxpdGFyeSA9ICdZWFdWVVRTUlFQT05aQUJDREVGR0hJS0xNJztcbiAgICB2YXIgdGltZXpvbmUsIHRpbWV6b25lSW5kZXg7XG5cbiAgICBzdHJpbmcgPSBjb25maWcuX2lcbiAgICAgICAgLnJlcGxhY2UoL1xcKFteXFwpXSpcXCl8W1xcblxcdF0vZywgJyAnKSAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykgLy8gUmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAucmVwbGFjZSgvXlxcc3xcXHMkL2csICcnKTsgLy8gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICAgIG1hdGNoID0gYmFzaWNSZmNSZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZGF5Rm9ybWF0ID0gbWF0Y2hbMV0gPyAnZGRkJyArICgobWF0Y2hbMV0ubGVuZ3RoID09PSA1KSA/ICcsICcgOiAnICcpIDogJyc7XG4gICAgICAgIGRhdGVGb3JtYXQgPSAnRCBNTU0gJyArICgobWF0Y2hbMl0ubGVuZ3RoID4gMTApID8gJ1lZWVkgJyA6ICdZWSAnKTtcbiAgICAgICAgdGltZUZvcm1hdCA9ICdISDptbScgKyAobWF0Y2hbNF0gPyAnOnNzJyA6ICcnKTtcblxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgIGlmIChtYXRjaFsxXSkgeyAvLyBkYXkgb2Ygd2VlayBnaXZlblxuICAgICAgICAgICAgdmFyIG1vbWVudERhdGUgPSBuZXcgRGF0ZShtYXRjaFsyXSk7XG4gICAgICAgICAgICB2YXIgbW9tZW50RGF5ID0gWydTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXVttb21lbnREYXRlLmdldERheSgpXTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnN1YnN0cigwLDMpICE9PSBtb21lbnREYXkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobWF0Y2hbNV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIG1pbGl0YXJ5XG4gICAgICAgICAgICAgICAgaWYgKHRpbWV6b25lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSAnICswMDAwJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZUluZGV4ID0gbWlsaXRhcnkuaW5kZXhPZihtYXRjaFs1XVsxXS50b1VwcGVyQ2FzZSgpKSAtIDEyO1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZSA9ICgodGltZXpvbmVJbmRleCA8IDApID8gJyAtJyA6ICcgKycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgoJycgKyB0aW1lem9uZUluZGV4KS5yZXBsYWNlKC9eLT8vLCAnMCcpKS5tYXRjaCgvLi4kLylbMF0gKyAnMDAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogLy8gWm9uZVxuICAgICAgICAgICAgICAgIHRpbWV6b25lID0gdGltZXpvbmVzW21hdGNoWzVdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIFVUIG9yICsvLTk5OTlcbiAgICAgICAgICAgICAgICB0aW1lem9uZSA9IHRpbWV6b25lc1snIEdNVCddO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoWzVdID0gdGltZXpvbmU7XG4gICAgICAgIGNvbmZpZy5faSA9IG1hdGNoLnNwbGljZSgxKS5qb2luKCcnKTtcbiAgICAgICAgdHpGb3JtYXQgPSAnIFpaJztcbiAgICAgICAgY29uZmlnLl9mID0gZGF5Rm9ybWF0ICsgZGF0ZUZvcm1hdCArIHRpbWVGb3JtYXQgKyB0ekZvcm1hdDtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgfVxuICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbn1cblxuLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4vLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4vLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICB9XG5cbiAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICB3ID0gY29uZmlnLl93O1xuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgZG93ID0gMTtcbiAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG59XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbmhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG5ob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uZmlnLl9hID0gW107XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG59XG5cblxuZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgdmFyIGlzUG07XG5cbiAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbiAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgaSxcbiAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgIH0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgIH0gIGVsc2Uge1xuICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICBjLl9sID0gbG9jYWxlO1xuICAgIGMuX2kgPSBpbnB1dDtcbiAgICBjLl9mID0gZm9ybWF0O1xuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xufVxuXG52YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbnZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbi8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbi8vXG4vLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4vLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgdmFyIHJlcywgaTtcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICB9XG4gICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICB9XG4gICAgcmVzID0gbW9tZW50c1swXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbmZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBtYXggKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xufVxuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xufTtcblxudmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgaWYgKCEob3JkZXJpbmcuaW5kZXhPZihrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xufVxuXG5mdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgIHdlZWtzICogNztcbiAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgdGhpcy5fYnViYmxlKCk7XG59XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgfVxufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgfSk7XG59XG5cbm9mZnNldCgnWicsICc6Jyk7XG5vZmZzZXQoJ1paJywgJycpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyB0aW1lem9uZSBjaHVua2VyXG4vLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgMCA6XG4gICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xufVxuXG4vLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgIHZhciByZXMsIGRpZmY7XG4gICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbn1cblxuLy8gSE9PS1NcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG5ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gTU9NRU5UU1xuXG4vLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4vLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4vLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4vL1xuLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4vLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbi8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbi8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbmZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICBsb2NhbEFkanVzdDtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIHZhciBjID0ge307XG5cbiAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgaWYgKGMuX2EpIHtcbiAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbn1cblxuZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG59XG5cbi8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxudmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICBzaWduLFxuICAgICAgICByZXQsXG4gICAgICAgIGRpZmZSZXM7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbmNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xufVxuXG5mdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgIC0tcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgfVxuXG4gICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAoZGF5cykge1xuICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgfVxufVxuXG52YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG52YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgIGlucHV0TXM7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgdmFyIHRoYXQsXG4gICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRlbHRhIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgfVxuXG4gICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xufVxuXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgfVxuXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgIH1cbiAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgfVxuXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG59XG5cbmZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xufVxuXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xufVxuXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG59KTtcblxuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbnZhciB0b2tlbjtcbmZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xufVxuXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG59XG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xufVxuXG52YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG5wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbnByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbnByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG5wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG5wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xucHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG5wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG5wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG5wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xucHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbnByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xucHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG5wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG5wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xucHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG5wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbnByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbnByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG5wcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbnByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xucHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xucHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xucHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xucHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xucHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbnByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4vLyBZZWFyXG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4vLyBXZWVrIFllYXJcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4vLyBRdWFydGVyXG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4vLyBNb250aFxucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbi8vIFdlZWtcbnByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG5wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4vLyBEYXlcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbi8vIEhvdXJcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbi8vIE1pbnV0ZVxucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuLy8gU2Vjb25kXG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4vLyBNaWxsaXNlY29uZFxucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuLy8gT2Zmc2V0XG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG5wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbnByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xucHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbi8vIFRpbWV6b25lXG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4vLyBNb250aFxucHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG5wcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xucHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbnByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4vLyBXZWVrXG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4vLyBEYXkgb2YgV2Vla1xucHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbnByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG5wcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG5wcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbnByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbnByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4vLyBIb3Vyc1xucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8vICgpXG4vLyAoNSlcbi8vIChmbXQsIDUpXG4vLyAoZm10KVxuLy8gKHRydWUpXG4vLyAodHJ1ZSwgNSlcbi8vICh0cnVlLCBmbXQsIDUpXG4vLyAodHJ1ZSwgZm10KVxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbn1cblxuZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICB9XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBhYnMgKCkge1xuICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG5mdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbn1cblxuZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWJibGUgKCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgIG1vbnRocyA9IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG4gICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5Nztcbn1cblxuZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbn1cblxuZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5cztcbiAgICB2YXIgbW9udGhzO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICB9O1xufVxuXG52YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG52YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbnZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xudmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG52YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbnZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xudmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG52YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xudmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbnZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG5mdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxufTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbmZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICBhWzRdID0gbG9jYWxlO1xuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICB9XG4gICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG52YXIgYWJzJDEgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHZhciBZID0geWVhcnM7XG4gICAgdmFyIE0gPSBtb250aHM7XG4gICAgdmFyIEQgPSBkYXlzO1xuICAgIHZhciBoID0gaG91cnM7XG4gICAgdmFyIG0gPSBtaW51dGVzO1xuICAgIHZhciBzID0gc2Vjb25kcztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgJ1AnICtcbiAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG59XG5cbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5wcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xucHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbnByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbnByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xucHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xucHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbnByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG5wcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbnByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG5wcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbnByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbnByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xucHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbnByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG5wcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG5wcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xucHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG5wcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbnByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbnByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xucHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xucHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbnByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbnByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbnByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG5wcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xucHJvdG8kMi5sYW5nID0gbGFuZztcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbmFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbmFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbn0pO1xuYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbmhvb2tzLnZlcnNpb24gPSAnMi4xOC4xJztcblxuc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG5ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbmhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbmhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG5ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG5ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbmhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG5yZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgXG4gIC8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gICAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gICAgfVxuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAoc2VsZi5fc3RhdGUgPT09IDEgPyByZXNvbHZlIDogcmVqZWN0KShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl92YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChzZWxmLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICBzZWxmLl9zdGF0ZSA9IDI7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fZGVmZXJyZWRzW2ldKTtcbiAgICB9XG4gICAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICAgKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAgICpcbiAgICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICAgKi9cbiAgZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHJlamVjdChzZWxmLCBleCk7XG4gICAgfVxuICB9XG5cbiAgUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBwcm9tID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShub29wKTtcblxuICAgIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbSkpO1xuICAgIHJldHVybiBwcm9tO1xuICB9O1xuXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3QodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9KSB8fFxuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICAgIH07XG5cbiAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1tZWRpYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldEltbWVkaWF0ZUZuID0gZnVuY3Rpb24gX3NldEltbWVkaWF0ZUZuKGZuKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSBmbjtcbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF9zZXRVbmhhbmRsZWRSZWplY3Rpb25Gbihmbikge1xuICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZm47XG4gIH07XG4gIFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4gIH0gZWxzZSBpZiAoIXJvb3QuUHJvbWlzZSkge1xuICAgIHJvb3QuUHJvbWlzZSA9IFByb21pc2U7XG4gIH1cblxufSkodGhpcyk7XG4iLCIvKlxuICogc21vb3Roc2Nyb2xsIHBvbHlmaWxsIC0gdjAuMy41XG4gKiBodHRwczovL2lhbWR1c3Rhbi5naXRodWIuaW8vc21vb3Roc2Nyb2xsXG4gKiAyMDE2IChjKSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24odywgZCwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKlxuICAgKiBhbGlhc2VzXG4gICAqIHc6IHdpbmRvdyBnbG9iYWwgb2JqZWN0XG4gICAqIGQ6IGRvY3VtZW50XG4gICAqIHVuZGVmaW5lZDogdW5kZWZpbmVkXG4gICAqL1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIHJldHVybiB3aGVuIHNjcm9sbEJlaGF2aW9yIGludGVyZmFjZSBpcyBzdXBwb3J0ZWRcbiAgICBpZiAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkLmRvY3VtZW50RWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogZ2xvYmFsc1xuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLypcbiAgICAgKiBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgICAqL1xuICAgIHZhciBub3cgPSB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XG4gICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGVhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHNtb290aCBiZWhhdmlvciBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqIEBtZXRob2Qgc2hvdWxkQmFpbE91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0geFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoeCkge1xuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgfHwgeCA9PT0gbnVsbFxuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSAnYXV0bydcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdpbnN0YW50Jykge1xuICAgICAgICAvLyBmaXJzdCBhcmcgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnXG4gICAgICAgICAgICAmJiB4LmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QgYW5kIGJlaGF2aW9yIGlzIHNtb290aFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yIHdoZW4gYmVoYXZpb3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmVoYXZpb3Igbm90IHZhbGlkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHZhciBpc0JvZHk7XG4gICAgICB2YXIgaGFzU2Nyb2xsYWJsZVNwYWNlO1xuICAgICAgdmFyIGhhc1Zpc2libGVPdmVyZmxvdztcblxuICAgICAgZG8ge1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gc2V0IGNvbmRpdGlvbiB2YXJpYWJsZXNcbiAgICAgICAgaXNCb2R5ID0gZWwgPT09IGQuYm9keTtcbiAgICAgICAgaGFzU2Nyb2xsYWJsZVNwYWNlID1cbiAgICAgICAgICBlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHQgfHxcbiAgICAgICAgICBlbC5jbGllbnRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgICBoYXNWaXNpYmxlT3ZlcmZsb3cgPVxuICAgICAgICAgIHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkub3ZlcmZsb3cgPT09ICd2aXNpYmxlJztcbiAgICAgIH0gd2hpbGUgKCFpc0JvZHkgJiYgIShoYXNTY3JvbGxhYmxlU3BhY2UgJiYgIWhhc1Zpc2libGVPdmVyZmxvdykpO1xuXG4gICAgICBpc0JvZHkgPSBoYXNTY3JvbGxhYmxlU3BhY2UgPSBoYXNWaXNpYmxlT3ZlcmZsb3cgPSBudWxsO1xuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WTtcbiAgICAgIHZhciBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBTQ1JPTExfVElNRTtcblxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXG4gICAgICB2YWx1ZSA9IGVhc2UoZWxhcHNlZCk7XG5cbiAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgICBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcblxuICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgIGlmIChjdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcbiAgICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcC5iaW5kKHcsIGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxzIHdpbmRvdyB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgICAqL1xuXG4gICAgLy8gdy5zY3JvbGwgYW5kIHcuc2Nyb2xsVG9cbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHcuc2Nyb2xsQnlcbiAgICB3LnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgKHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0KSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0udG9wICsgKHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIGFuZCBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCA9IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgfHwgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgPyBsZWZ0IDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHR5cGVvZiB0b3AgPT09ICdudW1iZXInID8gdG9wIDogdGhpcy5zY3JvbGxUb3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmcwID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKHtcbiAgICAgICAgICBsZWZ0OiBhcmcwLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhcmcwLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiBhcmcwLmJlaGF2aW9yXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoXG4gICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ICsgYXJnMCxcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvcCArIGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcbiAgICAgICAgLy8gcmV2ZWFsIHBhcmVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBjbGllbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gY29tbW9uanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgcG9seWZpbGw6IHBvbHlmaWxsIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2xvYmFsXG4gICAgcG9seWZpbGwoKTtcbiAgfVxufSkod2luZG93LCBkb2N1bWVudCk7XG4iLCJleHBvcnQgY29uc3QgdG9BcnJheSA9IGFycmF5TGlrZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5TGlrZSkpIHtcbiAgICByZXR1cm4gYXJyYXlMaWtlO1xuICB9XG5cbiAgaWYgKGFycmF5TGlrZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gIH1cblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbmV4cG9ydCBjb25zdCAkID0gKHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpID0+IChcbiAgdG9BcnJheShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChjb250ZXh0LCBzZWxlY3RvcikpXG4pO1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IgPSAoYmxvY2ssIGVsZW0sIG1vZE5hbWUsIG1vZFZhbCkgPT4gKFxuICBgJHtibG9ja31fXyR7ZWxlbX0ke21vZE5hbWUgPyAobW9kVmFsID8gYF8ke21vZE5hbWV9XyR7bW9kVmFsfWAgOiBgXyR7bW9kTmFtZX1gKSA6ICcnfWBcbik7XG5cbmV4cG9ydCBjb25zdCBidWlsZENsYXNzID0gKC4uLmFyZ3MpID0+IGAuJHtzZWxlY3RvciguLi5hcmdzKX1gO1xuXG5leHBvcnQgY2xhc3MgQkVNIGV4dGVuZHMgbnVsbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIG5vZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIGVsZW0obmFtZSwgbW9kTmFtZSwgbW9kVmFsKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpKTtcbiAgfVxuXG4gIGVsZW1zKG5hbWUsIG1vZE5hbWUsIG1vZFZhbCkge1xuICAgIHJldHVybiAkKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpLCB0aGlzLm5vZGUpO1xuICB9XG5cbiAgc2V0TW9kKGVsZW0sIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbE1vZChlbGVtLCBlbGVtTmFtZSwgbW9kTmFtZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lKSlcbiAgICApKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59IiwiaW1wb3J0IHsgQkVNIH0gZnJvbSAnLi9kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWVkYmFjayBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignZmVlZGJhY2snLCBub2RlKTtcblxuICAgIHRoaXMuJG5hbWUgPSB0aGlzLmVsZW0oJ25hbWUnKTtcbiAgICB0aGlzLiRtZXNzYWdlID0gdGhpcy5lbGVtKCdtZXNzYWdlJyk7XG4gICAgdGhpcy4kbWFpbFRvID0gdGhpcy5lbGVtKCdtYWlsdG8nKTtcblxuICAgIG5vZGUub25zdWJtaXQgPSAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLiRtYWlsVG8uaHJlZiA9IGBtYWlsdG86aW5mb0Buc3p1Lmdvdi51YT9zdWJqZWN0PdCX0LLQvtGA0L7RgtC90ZbQuSDQt9Cy4oCZ0Y/Qt9C+0Log0LLRltC0ICR7dGhpcy4kbmFtZS52YWx1ZX0mYm9keT0ke3RoaXMuJG1lc3NhZ2UudmFsdWV9YDtcbiAgICAgIHRoaXMuJG1haWxUby5jbGljaygpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCBQcm9taXNlIGZyb20gJ3Byb21pc2UtcG9seWZpbGwnO1xuaW1wb3J0IFNtb290aFNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcblxuXG5pbXBvcnQgeyAkIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCBOYXYgZnJvbSAnLi9uYXYnO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi90YWJzJztcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgU3RhdGlzdGljIGZyb20gJy4vc3RhdGlzdGljJztcbmltcG9ydCBGZWVkYmFjayBmcm9tICcuL2ZlZWRiYWNrJztcblxuaWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuICB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cblNtb290aFNjcm9sbC5wb2x5ZmlsbCgpO1xuXG4kKCcubmF2JykuZm9yRWFjaChub2RlID0+IG5ldyBOYXYobm9kZSkpO1xuJCgnLnRhYnMnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFRhYnMobm9kZSkpO1xuJCgnLnNsaWRlcicpLmZvckVhY2gobm9kZSA9PiBuZXcgU2xpZGVyKG5vZGUpKTtcbiQoJy5mZWVkYmFjaycpLmZvckVhY2gobm9kZSA9PiBuZXcgRmVlZGJhY2sobm9kZSkpO1xuXG5mZXRjaEpTT04oJ2RhdGEvc3RhdHMuanNvbicpLnRoZW4oZGF0YSA9PiB7XG4gICQoJy5tYXAnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IE1hcChub2RlLCBkYXRhLnNsaWNlKCkpKTtcbiAgLy8gJCgnLmRlY2xhcmF0aW9ucycpLmZvckVhY2gobm9kZSA9PiBuZXcgU3RhdGlzdGljKG5vZGUsIGRhdGEpKTtcbn0pO1xuXG5jb25zdCBSRUdJT05fX01BUCA9IHtcbiAgXCLQmtC40ZfQslwiOiA1MDIsXG4gIFwi0JvRg9GG0YzQulwiOiA1MjMsXG4gIFwi0JvRjNCy0L7QslwiOiA0MjMsXG4gIFwi0KPQttCz0L7RgNC+0LRcIjogMzI0LFxuICBcItCY0LLQsNC90L4t0KTRgNCw0L3QutC+0LLRgdC6XCI6IDIzMixcbiAgXCLQp9C10YDQvdC+0LLRhtGLXCI6IDI1MixcbiAgXCLQotC10YDQvdC+0L/QvtC70YxcIjogMjMyLFxuICBcItCg0L7QstC90L5cIjogMjAwLFxuICBcItCl0LzQtdC70YzQvdC40YbQutC40LlcIjogMTgyLFxuICBcItCW0LjRgtC+0LzQuNGAXCI6IDEzMixcbiAgXCLQktC40L3QvdC40YbQsFwiOiA5MixcbiAgXCLQp9C10YDQutCw0YHRgdGLXCI6IDgyLFxuICBcItCa0LjRgNC+0LLQvtCz0YDQsNC0XCI6IDY2LFxuICBcItCf0L7Qu9GC0LDQstCwXCI6IDUwLFxuICBcItCn0LXRgNC90LjQs9C+0LJcIjogMzIsXG4gIFwi0KHRg9C80LzRi1wiOiAxMixcbiAgXCLQpdCw0YDRjNC60L7QslwiOiA5LFxuICBcItCb0YPQs9Cw0L3RgdC6XCI6IDgsXG4gIFwi0JTQvdC10L/RgNC+0L/QtdGC0YDQvtCy0YHQulwiOiA3LFxuICBcItCU0L7QvdC10YbQulwiOiA2LFxuICBcItCX0LDQv9C+0YDQvtC20YzQtVwiOiA1LFxuICBcItCl0LXRgNGB0L7QvVwiOiA0LFxuICBcItCd0LjQutC+0LvQsNC10LJcIjogMyxcbiAgXCLQntC00LXRgdGB0LBcIjogMixcbiAgXCLQmtGA0YvQvFwiOiAxLFxufTtcblxuLy8gRGluYW1pY2FsIG51bWJlciBvZiBkZWNsYXJhaW9uLCBtaXMsIGRvY3RvcnNcbmNvbnN0IGRpbmFtaWNhbF9kZWNsYXJhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWNsYXJhdGlvbnNfX2dyYXBoLWNhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4vLyBjb25zdCBkaW5hbWljYWxfZG9jdG9ycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWNsYXJhdGlvbnNfX2dyYXBoLWNhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4vLyBjb25zdCBkaW5hbWljYWxfbWlzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlY2xhcmF0aW9uc19fZ3JhcGgtY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcblxuY29uc3QgREFUQSA9IHtcbiAgbGFiZWxzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIl0sXG4gIGRhdGFzZXRzOiBbe1xuICAgIGxhYmVsOiBcIk15IEZpcnN0IGRhdGFzZXRcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoOTgsIDE2NCwgMjQwKScsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2IoNzIsOTgsMjM3KScsXG4gICAgZGF0YTogWzAsIDEwLCAxMiwgMjIsIDI5LCAzMCwgNDVdLFxuICB9XVxufTtcblxuY29uc3QgY3VzdG9tVG9vbHRpcHMgPSBmdW5jdGlvbih0b29sdGlwKSB7XG4gIC8vIFRvb2x0aXAgRWxlbWVudFxuICBsZXQgdG9vbHRpcEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0anMtdG9vbHRpcCcpO1xuICBpZiAoIXRvb2x0aXBFbCkge1xuICAgIHRvb2x0aXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRvb2x0aXBFbC5pZCA9ICdjaGFydGpzLXRvb2x0aXAnO1xuICAgIHRvb2x0aXBFbC5pbm5lckhUTUwgPSBcIjx0YWJsZT48L3RhYmxlPlwiO1xuICAgIHRoaXMuX2NoYXJ0LmNhbnZhcy5vZmZzZXRQYXJlbnQuYXBwZW5kQ2hpbGQodG9vbHRpcEVsKTtcbiAgfVxuICAvLyBIaWRlIGlmIG5vIHRvb2x0aXBcbiAgaWYgKHRvb2x0aXAub3BhY2l0eSA9PT0gMCkge1xuICAgIHRvb2x0aXBFbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IGNhcmV0IFBvc2l0aW9uXG4gIHRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdhYm92ZScsICdiZWxvdycsICduby10cmFuc2Zvcm0nKTtcbiAgaWYgKHRvb2x0aXAueUFsaWduKSB7XG4gICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQodG9vbHRpcC55QWxpZ24pO1xuICB9IGVsc2Uge1xuICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCduby10cmFuc2Zvcm0nKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRCb2R5KGJvZHlJdGVtKSB7XG4gICAgcmV0dXJuIGJvZHlJdGVtLmxpbmVzO1xuICB9XG5cbiAgLy8gU2V0IFRleHRcbiAgaWYgKHRvb2x0aXAuYm9keSkge1xuICAgIGNvbnN0IHRpdGxlTGluZXMgPSB0b29sdGlwLnRpdGxlIHx8IFtdO1xuICAgIGNvbnN0IGJvZHlMaW5lcyA9IHRvb2x0aXAuYm9keS5tYXAoZ2V0Qm9keSk7XG4gICAgbGV0IGlubmVySHRtbCA9ICc8dGhlYWQ+JztcbiAgICB0aXRsZUxpbmVzLmZvckVhY2goZnVuY3Rpb24odGl0bGUpIHtcbiAgICAgIGlubmVySHRtbCArPSAnPHRyPjx0aD4nICsgdGl0bGUgKyAnPC90aD48L3RyPic7XG4gICAgfSk7XG4gICAgaW5uZXJIdG1sICs9ICc8L3RoZWFkPjx0Ym9keT4nO1xuICAgIGJvZHlMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGJvZHksIGkpIHtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IHRvb2x0aXAubGFiZWxDb2xvcnNbaV07XG4gICAgICBsZXQgc3R5bGUgPSAnYmFja2dyb3VuZDonICsgY29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIHN0eWxlICs9ICc7IGJvcmRlci1jb2xvcjonICsgY29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgc3R5bGUgKz0gJzsgYm9yZGVyLXdpZHRoOiAycHgnO1xuICAgICAgbGV0IHNwYW4gPSAnPHNwYW4gY2xhc3M9XCJjaGFydGpzLXRvb2x0aXAta2V5XCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+PC9zcGFuPic7XG4gICAgICBpbm5lckh0bWwgKz0gJzx0cj48dGQ+JyArIHNwYW4gKyBib2R5ICsgJzwvdGQ+PC90cj4nO1xuICAgIH0pO1xuICAgIGlubmVySHRtbCArPSAnPC90Ym9keT4nO1xuICAgIGxldCB0YWJsZVJvb3QgPSB0b29sdGlwRWwucXVlcnlTZWxlY3RvcigndGFibGUnKTtcbiAgICB0YWJsZVJvb3QuaW5uZXJIVE1MID0gaW5uZXJIdG1sO1xuICB9XG4gIGxldCBwb3NpdGlvblkgPSB0aGlzLl9ldmVudFBvc2l0aW9uLng7XG4gIGxldCBwb3NpdGlvblggPSB0aGlzLl9ldmVudFBvc2l0aW9uLnk7XG4gIGNvbnNvbGUubG9nKCdwb3NpdGlvbicsIHRoaXMsIHBvc2l0aW9uWSwgcG9zaXRpb25YKTtcbiAgY29uc29sZS5sb2coJ3Rvb2x0aXAnLCB0b29sdGlwLmNhcmV0WCwgdG9vbHRpcC5jYXJldFgpO1xuXG4gIC8vIERpc3BsYXksIHBvc2l0aW9uLCBhbmQgc2V0IHN0eWxlcyBmb3IgZm9udFxuICB0b29sdGlwRWwuc3R5bGUub3BhY2l0eSA9IDE7XG4gIHRvb2x0aXBFbC5zdHlsZS5sZWZ0ID0gcG9zaXRpb25YICsgdG9vbHRpcC5jYXJldFggKyAncHgnO1xuICB0b29sdGlwRWwuc3R5bGUudG9wID0gcG9zaXRpb25ZICsgdG9vbHRpcC5jYXJldFkgKyAncHgnO1xuICB0b29sdGlwRWwuc3R5bGUuZm9udEZhbWlseSA9IHRvb2x0aXAuX2ZvbnRGYW1pbHk7XG4gIHRvb2x0aXBFbC5zdHlsZS5mb250U2l6ZSA9IHRvb2x0aXAuZm9udFNpemU7XG4gIHRvb2x0aXBFbC5zdHlsZS5mb250U3R5bGUgPSB0b29sdGlwLl9mb250U3R5bGU7XG4gIHRvb2x0aXBFbC5zdHlsZS5wYWRkaW5nID0gdG9vbHRpcC55UGFkZGluZyArICdweCAnICsgdG9vbHRpcC54UGFkZGluZyArICdweCc7XG59O1xuXG5jb25zdCBkaW5hbWljYWxEZWNsYXJhdGlvbkNoYXJ0ID0gbmV3IENoYXJ0KGRpbmFtaWNhbF9kZWNsYXJhdGlvbiwge1xuICB0eXBlOiAnbGluZScsXG4gIGRhdGE6IERBVEEsXG4gIG9wdGlvbnM6IHtcbiAgICB0aXRsZToge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIHRleHQ6ICdDaGFydC5qcyBMaW5lIENoYXJ0IC0gQ3VzdG9tIFRvb2x0aXBzJyxcbiAgICB9LFxuICAgIHNjYWxlczoge1xuICAgICAgeEF4ZXM6IFt7XG4gICAgICAgIGdyaWRMaW5lczoge1xuICAgICAgICAgIGRyYXdCb3JkZXI6IGZhbHNlLFxuICAgICAgICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICAgICAgICB6ZXJvTGluZVdpZHRoOiAxLFxuICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgyMzIsMjMyLDIzMiwxKVwiLFxuICAgICAgICB9LFxuICAgICAgfV0sXG4gICAgICB5QXhlczogW3tcbiAgICAgICAgZ3JpZExpbmVzOiB7XG4gICAgICAgICAgZHJhd0JvcmRlcjogZmFsc2UsXG4gICAgICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgICAgIHplcm9MaW5lV2lkdGg6IDEsXG4gICAgICAgICAgemVyb0xpbmVDb2xvcjogXCJyZ2JhKDIzMiwyMzIsMjMyLDEpXCIsXG4gICAgICAgIH0sXG4gICAgICB9XVxuICAgIH0sXG4gICAgdG9vbHRpcHM6IHtcbiAgICAgIHBvc2l0aW9uOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxuICAgICAgeVBhZGRpbmc6IDMwLFxuICAgICAgeFBhZGRpbmc6IDMwLFxuICAgICAgY2FyZXRTaXplOiAxLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gICAgICB0aXRsZUZvbnRDb2xvcjogJyMwMDAnLFxuICAgICAgYm9keUZvbnRDb2xvcjogJyMwMDAnLFxuICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDEpJyxcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgY2FyZXRQYWRkaW5nOiA0MCxcbiAgICAgIGNvcm5lclJhZGl1czogMFxuICAgIH1cbiAgfVxufSk7XG5cblxuLy8gTnVtYmVyIG9mIGRlY2xhcmF0aW9ucywgbWlzLCBkb2N0b3JzXG5jb25zdCBOVU1CRVJfQllfUkVHSU9OX0RFQ0xBUkFUSU9OID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlY2xhcmF0aW9uc19udW1iZXJfX2dyYXBoLWNhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cbmNvbnN0IFJFR0lPTl9ERUNMQVJBVElPTlMgPSB7XG4gIGxhYmVsczogT2JqZWN0LmtleXMoUkVHSU9OX19NQVApLm1hcCggaSA9PiBpKSxcbiAgZGF0YXNldHM6IFt7XG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDk4LCAxNjQsIDI0MCknLFxuICAgIGJvcmRlckNvbG9yOiAncmdiKDcyLDk4LDIzNyknLFxuICAgIGRhdGE6IE9iamVjdC52YWx1ZXMoUkVHSU9OX19NQVApLm1hcCggaSA9PiBpKSxcbiAgfV0sXG59O1xuXG5cbmNvbnN0IE5VTUJFUl9CWV9SRUdJT04gPSBuZXcgQ2hhcnQoTlVNQkVSX0JZX1JFR0lPTl9ERUNMQVJBVElPTiwge1xuICB0eXBlOiAnaG9yaXpvbnRhbEJhcicsXG4gIGRhdGE6IFJFR0lPTl9ERUNMQVJBVElPTlMsXG4gIG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKHRoaXMuY2hhcnQpO1xuICAgIGxldCBjdHggPSB0aGlzLmNoYXJ0LmN0eDtcbiAgICBjdHguZm9udCA9IHRoaXMuc2NhbGUuZm9udDtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zY2FsZS50ZXh0Q29sb3I7XG4gICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG5cbiAgICB0aGlzLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YXNldCkgIHtcbiAgICAgIGRhdGFzZXQuYmFycy5mb3JFYWNoKGZ1bmN0aW9uKGJhcikge1xuICAgICAgICBjdHguZmlsbFRleHQoYmFyLnZhbHVlLCBiYXIueCwgYmFyLnkgLSA1KTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH0sXG4gIHNjYWxlTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgb3B0aW9uczoge1xuICAgIHRpdGxlOiB7XG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwVGVtcGxhdGU6IFwiPCU9IHZhbHVlICU+XCIsXG4gICAgc2NhbGVMaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgIHNjYWxlczoge1xuICAgICAgeEF4ZXM6IFt7XG4gICAgICAgIGdyaWRMaW5lczoge1xuICAgICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICBkcmF3Qm9yZGVyOiBmYWxzZSxcbiAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9XSxcbiAgICAgIHlBeGVzOiBbe1xuICAgICAgICBiYXJQZXJjZW50YWdlOiAwLjk1LFxuICAgICAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDEsXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgcGFkZGluZzogMjUsXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWRMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgIGRyYXdCb3JkZXI6IGZhbHNlLFxuICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9XVxuICAgIH0sXG4gICAgdG9vbHRpcHM6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDBcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDEsXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBjaGFydEluc3RhbmNlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICBjdHggPSBjaGFydEluc3RhbmNlLmN0eDtcbiAgICAgICAgY3R4LmZvbnQgPSBDaGFydC5oZWxwZXJzLmZvbnRTdHJpbmcoMTQsICc3MDAnLCAnR290aGFtUHJvJyk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuXG4gICAgICAgIHRoaXMuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhc2V0LCBpKSB7XG4gICAgICAgICAgbGV0IG1ldGEgPSBjaGFydEluc3RhbmNlLmNvbnRyb2xsZXIuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgbWV0YS5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGJhciwgaW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChkYXRhLCBiYXIuX21vZGVsLnggKyAyMCwgYmFyLl9tb2RlbC55ICsgNyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7IiwiaW1wb3J0IHsgQkVNLCBidWlsZENsYXNzIH0gZnJvbSAnLi9kb20nO1xuXG5jb25zdCBIT1ZFUl9ERUJPVU5DRV9USU1FT1VUID0gMjAwO1xuXG5jb25zdCBSRUdJT05fUE9JTlRfTUFQID0ge1xuICBcItCa0LjRl9CyXCI6IHsgbGVmdDogNDUzLCB0b3A6IDE3MCB9LFxuICBcItCb0YPRhtGM0LpcIjogeyBsZWZ0OiAxNTMsIHRvcDogMTAwIH0sXG4gIFwi0JvRjNCy0L7QslwiOiB7IGxlZnQ6IDgzLCB0b3A6IDIwNiB9LFxuICBcItCj0LbQs9C+0YDQvtC0XCI6IHsgbGVmdDogNDgsIHRvcDogMzEyIH0sXG4gIFwi0JjQstCw0L3Qvi3QpNGA0LDQvdC60L7QstGB0LpcIjogeyBsZWZ0OiAxNTMsIHRvcDogMzEyIH0sXG4gIFwi0KfQtdGA0L3QvtCy0YbRi1wiOiB7IGxlZnQ6IDIwNywgdG9wOiAzMjkgfSxcbiAgXCLQotC10YDQvdC+0L/QvtC70YxcIjogeyBsZWZ0OiAxODgsIHRvcDogMjQxIH0sXG4gIFwi0KDQvtCy0L3QvlwiOiB7IGxlZnQ6IDI0MSwgdG9wOiAxMDAgfSxcbiAgXCLQpdC80LXQu9GM0L3QuNGG0LrQuNC5XCI6IHsgbGVmdDogMjU5LCB0b3A6IDIwNiB9LFxuICBcItCW0LjRgtC+0LzQuNGAXCI6IHsgbGVmdDogMzQ3LCB0b3A6IDE1MyB9LFxuICBcItCS0LjQvdC90LjRhtCwXCI6IHsgbGVmdDogMzY1LCB0b3A6IDI3NyB9LFxuICBcItCn0LXRgNC60LDRgdGB0YtcIjogeyBsZWZ0OiA1MjMsIHRvcDogMjQxIH0sXG4gIFwi0JrQuNGA0L7QstC+0LPRgNCw0LRcIjogeyBsZWZ0OiA1NDEsIHRvcDogMzEyIH0sXG4gIFwi0J/QvtC70YLQsNCy0LBcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTg4IH0sXG4gIFwi0KfQtdGA0L3QuNCz0L7QslwiOiB7IGxlZnQ6IDU0MSwgdG9wOiA2NSB9LFxuICBcItCh0YPQvNC80YtcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTAwIH0sXG4gIFwi0KXQsNGA0YzQutC+0LJcIjogeyBsZWZ0OiA3NzAsIHRvcDogMjA1IH0sXG4gIFwi0JvRg9Cz0LDQvdGB0LpcIjogeyBsZWZ0OiA5MTEsIHRvcDogMjU5IH0sXG4gIFwi0JTQvdC10L/RgNC+0L/QtdGC0YDQvtCy0YHQulwiOiB7IGxlZnQ6IDY4MiwgdG9wOiAzMTEgfSxcbiAgXCLQlNC+0L3QtdGG0LpcIjogeyBsZWZ0OiA4NDAsIHRvcDogMzQ3IH0sXG4gIFwi0JfQsNC/0L7RgNC+0LbRjNC1XCI6IHsgbGVmdDogNzUyLCB0b3A6IDQxNyB9LFxuICBcItCl0LXRgNGB0L7QvVwiOiB7IGxlZnQ6IDYyOSwgdG9wOiA0NTIgfSxcbiAgXCLQndC40LrQvtC70LDQtdCyXCI6IHsgbGVmdDogNTIzLCB0b3A6IDM5OSB9LFxuICBcItCe0LTQtdGB0YHQsFwiOiB7IGxlZnQ6IDQ1MywgdG9wOiA0MzUgfSxcbiAgXCLQmtGA0YvQvFwiOiB7IGxlZnQ6IDY2NCwgdG9wOiA1NTggfVxufTtcblxuY29uc3QgY3JlYXRlUG9pbnQgPSAoeyBsZWZ0LCB0b3AgfSkgPT4ge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCdtYXBfX3BvaW50Jyk7XG4gIG5vZGUuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICBub2RlLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXAgZXh0ZW5kcyBCRU0ge1xuICBkYXRhID0gW107XG4gIHRpbWVvdXQgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGRhdGEpIHtcbiAgICBzdXBlcignbWFwJywgbm9kZSk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuJHRvb2x0aXAgPSB0aGlzLmVsZW0oJ3Rvb2x0aXAnKTtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVQb2ludChSRUdJT05fUE9JTlRfTUFQW2l0ZW0ucmVnaW9uX25hbWVdKTtcbiAgICAgIHBvaW50LmRhdGFzZXQuaW5kZXggPSBpbmRleDtcblxuICAgICAgcG9pbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcywgZmFsc2UpO1xuICAgICAgcG9pbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBvaW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcywgZmFsc2UpO1xuICAgIHRoaXMuJHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmVsZW0oJ21haW4nKS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICBoYW5kbGVFdmVudCh7IHRhcmdldCwgdHlwZSB9KSB7XG4gICAgaWYgKHR5cGUgPT09ICdtb3VzZW92ZXInICYmIHRhcmdldC5kYXRhc2V0LmluZGV4KSB7XG4gICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLnRvcCA9IHRhcmdldC5zdHlsZS50b3A7XG4gICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLmxlZnQgPSB0YXJnZXQuc3R5bGUubGVmdDtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICAgICAgdGhpcy5kZWxNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuICAgICAgICAgIHRoaXMuZGVsTW9kKHRoaXMuJGFjdGl2ZSwgJ3BvaW50JywgJ2FjdGl2ZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGFbdGFyZ2V0LmRhdGFzZXQuaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0b29sdGlwRGF0YSA9IHRoaXMuJHRvb2x0aXAucXVlcnlTZWxlY3RvckFsbChgJHtidWlsZENsYXNzKCdtYXAnLCAndG9vbHRpcC1kYXRhJyl9IGR0YCk7XG5cbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUudG9wID0gdGFyZ2V0LnN0eWxlLnRvcDtcbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUubGVmdCA9IHRhcmdldC5zdHlsZS5sZWZ0O1xuXG4gICAgICAgICAgICB0aGlzLiRhY3RpdmUgJiYgdGhpcy5kZWxNb2QodGhpcy4kYWN0aXZlLCAncG9pbnQnLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiR0b29sdGlwLCAndG9vbHRpcCcsICdzaG93Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAucXVlcnlTZWxlY3RvcihidWlsZENsYXNzKCdtYXAnLCAndG9vbHRpcC10aXRsZScpKS50ZXh0Q29udGVudCA9IGRhdGEucmVnaW9uX25hbWU7XG4gICAgICAgICAgICB0aGlzLiRhY3RpdmUgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgICR0b29sdGlwRGF0YVswXS50ZXh0Q29udGVudCA9IGRhdGEubWVkaWNhbF9zeXN0ZW1fcHJvdmlkZXJzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzFdLnRleHRDb250ZW50ID0gZGF0YS5kb2N0b3JzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzJdLnRleHRDb250ZW50ID0gZGF0YS5kZWNsYXJhdGlvbnNfc2lnbmVkO1xuXG4gICAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiRhY3RpdmUsICdwb2ludCcsICdhY3RpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiR0b29sdGlwLCAndG9vbHRpcCcsICdzaG93Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgSE9WRVJfREVCT1VOQ0VfVElNRU9VVCk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBOYXYge1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZS50YXJnZXQuaHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG8gPSBlLnRhcmdldC5ocmVmLnNwbGl0KCcjJylbMV07XG4gICAgICBjb25zdCB7IHRvcCB9ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG8pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB3aW5kb3cuc2Nyb2xsKHsgdG9wOiAodG9wICsgd2luZG93LnNjcm9sbFkpIC0gNTAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9KVxuICB9XG59IiwiaW1wb3J0IHsgQkVNLCBidWlsZENsYXNzLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgY3JlYXRlTWFya2VyID0gKGFjdGl2ZSA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcignc2xpZGVyJywgJ21hcmtlcicpKTtcbiAgYWN0aXZlICYmIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcignc2xpZGVyJywgJ21hcmtlcicsICdhY3RpdmUnKSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBCRU0ge1xuICBjdXJyZW50SW5kZXggPSAwO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignc2xpZGVyJywgbm9kZSk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy5lbGVtcygnc2xpZGUnKTtcblxuICAgIHRoaXMuJG1hcmtlcnMgPSBbXTtcblxuICAgIHRoaXMuJGNvbnRyb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHRoaXMuJGNvbnRyb2wuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsICdtYXJrZXJzJykpO1xuXG4gICAgdGhpcy4kc2xpZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIoaW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuJGNvbnRyb2wuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICAgIHRoaXMuJG1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kY29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICBpZiAoIXRhcmdldC5jbG9zZXN0KGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCAnbWFya2VyJykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9JbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUVsZW0odGFyZ2V0KTtcblxuICAgICAgaWYgKHRvSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWxNb2QodGhpcy5lbGVtKCdtYXJrZXInLCAnYWN0aXZlJyksICdtYXJrZXInLCAnYWN0aXZlJyk7XG4gICAgICB0aGlzLnNldE1vZCh0YXJnZXQsICdtYXJrZXInLCAnYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuc2xpZGUodG9JbmRleCk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuJGNvbnRyb2wpO1xuICB9XG5cbiAgc2xpZGUoaW5kZXgpIHtcbiAgICBjb25zdCBpc05leHQgPSB0aGlzLmN1cnJlbnRJbmRleCA8IGluZGV4O1xuXG4gICAgdGhpcy4kc2xpZGVzW3RoaXMuY3VycmVudEluZGV4XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICctJyA6ICcnfTEwMCUpYCB9XG4gICAgXSwgdGhpcy5jb25zdHJ1Y3Rvci5BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLiRzbGlkZXNbaW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJycgOiAnLSd9MTAwJSlgIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH1cbiAgICBdLCB0aGlzLmNvbnN0cnVjdG9yLkFOSU1BVElPTl9PUFRJT05TKTtcblxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gIH1cblxuICBnZXRJbmRleEJ5RWxlbShlbGVtKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICB0aGlzLiRtYXJrZXJzLnNvbWUoKG5vZGUsIGkpID0+IHtcbiAgICAgIGlmIChub2RlID09PSBlbGVtKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBzdGF0aWMgQU5JTUFUSU9OX09QVElPTlMgPSB7XG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgIGVhc2luZzogJ2Vhc2UtaW4tb3V0J1xuICB9XG59IiwiLy8gaW1wb3J0IHsgQkVNLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcbi8vIGltcG9ydCB7IG51bWJlckZvcm1hdHRpbmcgfSBmcm9tICcuL3V0aWxzJztcbi8vXG4vLyBjb25zdCBDT0xPUlNfTUFQID0gW1xuLy8gICAnIzkwYzhlNicsICcjYjA5N2M2JywgJyNkZmIwZDAnLFxuLy8gICAnI2UzYWFiOCcsICcjYWZkNWU3JywgJyNjN2IyZDUnLFxuLy8gICAnI2U5YzdkZicsICcjZWNjN2NmJywgJyNmMWVlYzknLFxuLy8gICAnI2NlZDhlMicsICcjNWRhODkyJywgJyM1Mjk2Y2QnLFxuLy8gICAnI2EzZDdmMicsICcjZjNmMWEwJywgJyNiY2RhZDUnLFxuLy8gICAnIzcxYjdhOCcsICcjNWNhOWRjJywgJyNkYzkxYTMnLFxuLy8gICAnI2Q4ODE2ZicsICcjZTJhMzk0JywgJyM3NTY2YWEnLFxuLy8gICAnI2NhZGZlYicsICcjZGRkMmRmJywgJyNmNGQ5YjUnLFxuLy8gICAnI2QzODFiMidcbi8vIF07XG4vL1xuLy8gY29uc3QgY3JlYXRlTGlzdEl0ZW1Ob2RlID0gKHRpdGxlLCB2YWx1ZSwgY29sb3IpID0+IHtcbi8vICAgY29uc3QgJGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbi8vICAgY29uc3QgJHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4vLyAgIGNvbnN0ICR2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuLy9cbi8vICAgJGxpLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ2RlY2xhcmF0aW9ucycsICdsaXN0LWl0ZW0nKSk7XG4vLyAgICRsaS50ZXh0Q29udGVudCA9IHRpdGxlO1xuLy9cbi8vICAgJHNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4vL1xuLy8gICAkdmFsdWUuY2xhc3NMaXN0LmFkZChzZWxlY3RvcignZGVjbGFyYXRpb25zJywgJ2xpc3QtaXRlbS12YWx1ZScpKTtcbi8vICAgJHZhbHVlLnRleHRDb250ZW50ID0gbnVtYmVyRm9ybWF0dGluZyh2YWx1ZSk7XG4vL1xuLy8gICAkbGkucHJlcGVuZCgkc3Bhbik7XG4vLyAgICRsaS5hcHBlbmQoJHZhbHVlKTtcbi8vXG4vLyAgIHJldHVybiAkbGk7XG4vLyB9O1xuLy9cbi8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpc3RpYyBleHRlbmRzIEJFTSB7XG4vLyAgIGNvbnN0cnVjdG9yKG5vZGUsIGRhdGEpIHtcbi8vICAgICBzdXBlcignZGVjbGFyYXRpb25zJywgbm9kZSk7XG4vL1xuLy8gICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuLy9cbi8vICAgICB0aGlzLiRjYW52YXMgPSB0aGlzLmVsZW0oJ2dyYXBoLWNhbnZhcycpO1xuLy8gICAgIHRoaXMuY29udGV4dCA9IHRoaXMuJGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuLy9cbi8vICAgICBjb25zdCB0b3RhbCA9IGRhdGEucmVkdWNlKCh0YXJnZXQsIHsgZGVjbGFyYXRpb25zIH0pID0+IHRhcmdldCArIGRlY2xhcmF0aW9ucywgMCk7XG4vL1xuLy8gICAgIGRhdGEuc29ydCgoYSwgYikgPT4gYS5kZWNsYXJhdGlvbnMgPCBiLmRlY2xhcmF0aW9ucyA/IDEgOiAtMSk7XG4vL1xuLy8gICAgIGxldCBbeCwgeSwgciwgc10gPSBbNDkwLCA0OTAsIDQ4MCwgMF07XG4vL1xuLy8gICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbi8vICAgICAgIGNvbnN0ICRpdGVtID0gY3JlYXRlTGlzdEl0ZW1Ob2RlKFxuLy8gICAgICAgICBpdGVtLnJlZ2lvbl9uYW1lLFxuLy8gICAgICAgICBpdGVtLmRlY2xhcmF0aW9ucyxcbi8vICAgICAgICAgQ09MT1JTX01BUFtpbmRleF1cbi8vICAgICAgICk7XG4vL1xuLy8gICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoJGl0ZW0pO1xuLy9cbi8vICAgICAgIGxldCByYWRpYW5zID0gKChpdGVtLmRlY2xhcmF0aW9ucyAvIGRhdGFbMF0uZGVjbGFyYXRpb25zKSAqIDM2MCkgKiAoTWF0aC5QSSAvIDM2MCk7XG4vL1xuLy8gICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuLy8gICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDY7XG4vLyAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBDT0xPUlNfTUFQW2luZGV4XTtcbi8vICAgICAgIHRoaXMuY29udGV4dC5hcmMoeCwgeSwgciAtICgyMCAqIGluZGV4KSwgcywgcmFkaWFucywgZmFsc2UpO1xuLy8gICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuLy8gICAgIH0pO1xuLy9cbi8vICAgICB0aGlzLmVsZW0oJ2xpc3QnKS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4vLyAgICAgdGhpcy5lbGVtKCd0b3RhbC12YWx1ZScpLnRleHRDb250ZW50ID0gbnVtYmVyRm9ybWF0dGluZyh0b3RhbCk7XG4vLyAgIH1cbi8vIH1cblxuIiwiaW1wb3J0IHsgJCwgQkVNLCBidWlsZENsYXNzLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgUEFORUxfQU5JTUFUSU9OX09QVElPTlMgPSB7XG4gIGR1cmF0aW9uOiAzMDAsXG4gIGZpbGw6ICdmb3J3YXJkcycsXG4gIGVhc2luZzogJ2Vhc2UtaW4tb3V0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIHsgYXV0b0hlaWdodCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKCd0YWJzJywgbm9kZSk7XG5cbiAgICB0aGlzLiRjb250cm9scyA9IHRoaXMuZWxlbXMoJ25hdi1pdGVtJyk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy5lbGVtcygnc2xpZGUnKTtcblxuICAgIHRoaXMuJG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuJG1hcmtlci5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKHRoaXMubmFtZSwgJ21hcmtlcicpKTtcbiAgICB0aGlzLmVsZW0oJ2hlYWRlcicpLmFwcGVuZENoaWxkKHRoaXMuJG1hcmtlcik7XG5cbiAgICBpZiAoYXV0b0hlaWdodCkge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy4kc2xpZGVzLnJlZHVjZSgodGFyZ2V0LCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmNsaWVudEhlaWdodCA+IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGl0ZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0sIDApO1xuXG4gICAgICB0aGlzLmVsZW0oJ21haW4nKS5zdHlsZS5oZWlnaHQgPSBgJHttYXhIZWlnaHR9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSh0aGlzLmVsZW0oJ25hdi1pdGVtJywgJ2FjdGl2ZScpKTtcblxuICAgIHRoaXMuZWxlbSgnbmF2JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3QgJGVsZW0gPSBlLnRhcmdldC5jbG9zZXN0KGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCAnbmF2LWl0ZW0nKSk7XG5cbiAgICAgIGlmICghJGVsZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b0luZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSgkZWxlbSk7XG5cbiAgICAgIGlmICh0b0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsTW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdhY3RpdmUnKTtcbiAgICAgIHRoaXMuc2V0TW9kKCRlbGVtLCAnbmF2LWl0ZW0nLCAnYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuYW5pbWF0ZVBhbmVscyh0b0luZGV4KTtcbiAgICAgIHRoaXMuYW5pbWF0ZU1hcmtlcih0b0luZGV4KTtcblxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB0b0luZGV4O1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuc2V0TW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdtYXJrZXInKTtcbiAgfVxuXG4gIGFuaW1hdGVQYW5lbHMoaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgY29uc3QgaXNOZXh0ID0gY3VycmVudCA8IGluZGV4O1xuXG4gICAgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkgJiYgdGhpcy4kc2xpZGVzW2N1cnJlbnRdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJy0nIDogJyd9MTAwJSlgLCBvcGFjaXR5OiAwIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLiRzbGlkZXNbaW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJycgOiAnLSd9MTAwJSlgLCBvcGFjaXR5OiAwIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvcGFjaXR5OiAxIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG4gIH1cblxuICBhbmltYXRlTWFya2VyKGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5vZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5jbGllbnRXaWR0aFxuICAgIH07XG5cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy4kY29udHJvbHNbaW5kZXhdLm9mZnNldExlZnQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLiRjb250cm9sc1tpbmRleF0uY2xpZW50V2lkdGg7XG5cbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLiRtYXJrZXIuYW5pbWF0ZShbXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtjdXJyZW50LmxlZnR9cHgpYCxcbiAgICAgICAgd2lkdGg6IGAke2N1cnJlbnQud2lkdGh9cHhgXG4gICAgICB9LCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KWAsXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGBcbiAgICAgIH1cbiAgICBdLCB7Li4uUEFORUxfQU5JTUFUSU9OX09QVElPTlMgfSk7XG5cbiAgICBwbGF5ZXIub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldE1vZCh0aGlzLiRjb250cm9sc1tpbmRleF0sICduYXYtaXRlbScsICdtYXJrZXInKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBwbGF5ZXIuY2FuY2VsKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLmRlbE1vZCh0aGlzLiRjb250cm9sc1t0aGlzLmN1cnJlbnRJbmRleF0sICduYXYtaXRlbScsICdtYXJrZXInKVxuICB9XG5cbiAgZ2V0SW5kZXhCeUVsZW0oZWxlbSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgdGhpcy4kY29udHJvbHMuc29tZSgobm9kZSwgaSkgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxufSIsImNvbnN0IG9iamVjdFRvUXVlcnkgPSAodGFyZ2V0KSA9PiAoXG4gICc/JyArIE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKChhcnIsIGtleSkgPT4gKFxuICAgIGFyci5wdXNoKGAke2tleX09JHt0YXJnZXRba2V5XX1gKSAmJiBhcnJcbiAgKSwgW10pLmpvaW4oJyYnKVxuKTtcblxuZXhwb3J0IGNvbnN0IG51bWJlckZvcm1hdHRpbmcgPSBudW1iZXIgPT4gKFxuICBudW1iZXIudG9GaXhlZCgyKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pK1xcLikvZywgJyQxICcpLnNwbGl0KCcuJylbMF1cbik7XG5cbmV4cG9ydCBjb25zdCBmZXRjaEpTT04gPSAodXJsLCBvcHRpb25zID0geyBtZXRob2Q6ICdHRVQnIH0pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGlmIChvcHRpb25zLmJvZHkgJiYgb3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgdXJsICs9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5ib2R5KTtcbiAgfVxuXG4gIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlKEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgfTtcblxuICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XG4gIHJlcXVlc3Qub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKTtcbiAgcmVxdWVzdC5zZW5kKG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSkgOiBudWxsKTtcbn0pOyJdfQ==
