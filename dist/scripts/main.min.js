(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],2:[function(require,module,exports){
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      var left = arguments[0].left;
      var top = arguments[0].top;

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          typeof left === 'number' ? left : this.scrollLeft,
          typeof top === 'number' ? top : this.scrollTop
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(
          this,
          arguments[0] === undefined ? true : arguments[0]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var toArray = exports.toArray = function toArray(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return arrayLike;
  }

  if (arrayLike instanceof Node) {
    return [arrayLike];
  }

  return Array.prototype.slice.call(arrayLike);
};

var $ = exports.$ = function $(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll.call(context, selector));
};

var selector = exports.selector = function selector(block, elem, modName, modVal) {
  return block + '__' + elem + (modName ? modVal ? '_' + modName + '_' + modVal : '_' + modName : '');
};

var buildClass = exports.buildClass = function buildClass() {
  return '.' + selector.apply(undefined, arguments);
};

var BEM = exports.BEM = function (_ref) {
  _inherits(BEM, _ref);

  function BEM(name, node) {
    _classCallCheck(this, BEM);

    var _this = _possibleConstructorReturn(this, (BEM.__proto__ || Object.getPrototypeOf(BEM)).call(this));

    _this.node = node;
    _this.name = name;
    return _this;
  }

  _createClass(BEM, [{
    key: 'elem',
    value: function elem(name, modName, modVal) {
      return this.node.querySelector(buildClass(this.name, name, modName, modVal));
    }
  }, {
    key: 'elems',
    value: function elems(name, modName, modVal) {
      return $(buildClass(this.name, name, modName, modVal), this.node);
    }
  }, {
    key: 'setMod',
    value: function setMod(elem, elemName, modName, modValue) {
      var _this2 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.add(selector(_this2.name, elemName, modName, modValue));
      });

      return this;
    }
  }, {
    key: 'delMod',
    value: function delMod(elem, elemName, modName) {
      var _this3 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.remove(selector(_this3.name, elemName, modName));
      });

      return this;
    }
  }]);

  return BEM;
}(null);

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feedback = function (_BEM) {
  _inherits(Feedback, _BEM);

  function Feedback(node) {
    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this, 'feedback', node));

    _this.$name = _this.elem('name');
    _this.$message = _this.elem('message');
    _this.$mailTo = _this.elem('mailto');

    node.onsubmit = function (e) {
      e.preventDefault();

      _this.$mailTo.href = 'mailto:info@nszu.gov.ua?subject=\u0417\u0432\u043E\u0440\u043E\u0442\u043D\u0456\u0439 \u0437\u0432\u2019\u044F\u0437\u043E\u043A \u0432\u0456\u0434 ' + _this.$name.value + '&body=' + _this.$message.value;
      _this.$mailTo.click();
      return false;
    };
    return _this;
  }

  return Feedback;
}(_dom.BEM);

exports.default = Feedback;
module.exports = exports['default'];

},{"./dom":3}],5:[function(require,module,exports){
'use strict';

var _promisePolyfill = require('promise-polyfill');

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _smoothscrollPolyfill = require('smoothscroll-polyfill');

var _smoothscrollPolyfill2 = _interopRequireDefault(_smoothscrollPolyfill);

var _dom = require('./dom');

var _utils = require('./utils');

var _nav = require('./nav');

var _nav2 = _interopRequireDefault(_nav);

var _tabs = require('./tabs');

var _tabs2 = _interopRequireDefault(_tabs);

var _slider = require('./slider');

var _slider2 = _interopRequireDefault(_slider);

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _statistic = require('./statistic');

var _statistic2 = _interopRequireDefault(_statistic);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.Promise) {
  window.Promise = _promisePolyfill2.default;
}

_smoothscrollPolyfill2.default.polyfill();

(0, _dom.$)('.nav').forEach(function (node) {
  return new _nav2.default(node);
});
(0, _dom.$)('.tabs').forEach(function (node) {
  return new _tabs2.default(node);
});
(0, _dom.$)('.slider').forEach(function (node) {
  return new _slider2.default(node);
});
(0, _dom.$)('.feedback').forEach(function (node) {
  return new _feedback2.default(node);
});

(0, _utils.fetchJSON)('data/stats.json').then(function (data) {
  (0, _dom.$)('.declarations').forEach(function (node) {
    return new _statistic2.default(node, data);
  });
});

(0, _utils.fetchJSON)('http://dev.ehealth.world/reports/stats/regions').then(function (data) {
  (0, _dom.$)('.map').forEach(function (node) {
    return new _map2.default(node, data.data);
  });
});

(0, _utils.fetchJSON)('http://dev.ehealth.world/reports/stats/').then(function (data) {
  var joined_items = (0, _dom.$)('.joined__item-count');
  joined_items[0].innerText = data.data.msps;
  joined_items[1].innerText = data.data.doctors;
  joined_items[2].innerText = data.data.declarations;
});

},{"./dom":3,"./feedback":4,"./map":6,"./nav":7,"./slider":8,"./statistic":9,"./tabs":10,"./utils":11,"promise-polyfill":1,"smoothscroll-polyfill":2}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require("./dom");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HOVER_DEBOUNCE_TIMEOUT = 200;

var REGION_POINT_MAP = {
  "М.КИЇВ": { left: 453, top: 175 },
  "КИЇВСЬКА": { left: 453, top: 140 },
  "ВОЛИНСЬКА": { left: 153, top: 100 },
  "ЛЬВІВСЬКА": { left: 83, top: 206 },
  "ЗАКАРПАТСЬКА": { left: 48, top: 312 },
  "ІВАНО-ФРАНКІВСЬКА": { left: 153, top: 312 },
  "ЧЕРНІВЕЦЬКА": { left: 207, top: 329 },
  "ТЕРНОПІЛЬСЬКА": { left: 188, top: 241 },
  "РІВНЕНСЬКА": { left: 241, top: 100 },
  "ХМЕЛЬНИЦЬКА": { left: 259, top: 206 },
  "ЖИТОМИРСЬКА": { left: 347, top: 153 },
  "ВІННИЦЬКА": { left: 365, top: 277 },
  "ЧЕРКАСЬКА": { left: 523, top: 241 },
  "КІРОВОГРАДСЬКА": { left: 541, top: 312 },
  "ПОЛТАВСЬКА": { left: 646, top: 188 },
  "ЧЕРНІГІВСЬКА": { left: 541, top: 65 },
  "СУМСЬКА": { left: 646, top: 100 },
  "ХАРКІВСЬКА": { left: 770, top: 205 },
  "ЛУГАНСЬКА": { left: 911, top: 259 },
  "ДНІПРОПЕТРОВСЬКА": { left: 682, top: 311 },
  "ДОНЕЦЬКА": { left: 840, top: 347 },
  "ЗАПОРІЗЬКА": { left: 752, top: 417 },
  "ХЕРСОНСЬКА": { left: 629, top: 452 },
  "МИКОЛАЇВСЬКА": { left: 523, top: 399 },
  "ОДЕСЬКА": { left: 453, top: 435 },
  "АВТОНОМНА РЕСПУБЛІКА КРИМ": { left: 664, top: 558 },
  "М.СЕВАСТОПОЛЬ": { left: 614, top: 588 }
};

var createPoint = function createPoint(_ref) {
  var left = _ref.left,
      top = _ref.top;

  var node = document.createElement('div');

  node.classList.add('map__point');
  node.style.left = left + "px";
  node.style.top = top + "px";

  return node;
};

var Map = function (_BEM) {
  _inherits(Map, _BEM);

  function Map(node, data) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, 'map', node));

    _this.data = [];
    _this.timeout = null;


    _this.data = data;
    _this.$tooltip = _this.elem('tooltip');

    var fragment = document.createDocumentFragment();

    data.forEach(function (item, index) {
      var point = createPoint(REGION_POINT_MAP[item.region.name]);
      point.dataset.index = index;

      point.addEventListener('mouseover', _this, false);
      point.addEventListener('mouseout', _this, false);

      fragment.appendChild(point);
    });

    _this.$tooltip.addEventListener('mouseover', _this, false);
    _this.$tooltip.addEventListener('mouseout', _this, false);

    _this.elem('main').appendChild(fragment);
    return _this;
  }

  _createClass(Map, [{
    key: "handleEvent",
    value: function handleEvent(_ref2) {
      var _this2 = this;

      var target = _ref2.target,
          type = _ref2.type;

      if (type === 'mouseover' && target.dataset.index) {
        this.$tooltip.style.top = target.style.top;
        this.$tooltip.style.left = target.style.left;
      }

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        switch (type) {
          case 'mouseout':
            _this2.delMod(_this2.$tooltip, 'tooltip', 'show');
            _this2.delMod(_this2.$active, 'point', 'active');
            break;
          case 'mouseover':
            var data = _this2.data[target.dataset.index];

            if (data) {
              var $tooltipData = _this2.$tooltip.querySelectorAll((0, _dom.buildClass)('map', 'tooltip-data') + " dt");

              _this2.$tooltip.style.top = target.style.top;
              _this2.$tooltip.style.left = target.style.left;

              _this2.$active && _this2.delMod(_this2.$active, 'point', 'active');
              _this2.setMod(_this2.$tooltip, 'tooltip', 'show');

              _this2.$tooltip.querySelector((0, _dom.buildClass)('map', 'tooltip-title')).textContent = data.region.name;
              _this2.$active = target;

              $tooltipData[0].textContent = data.stats.msps;
              $tooltipData[1].textContent = data.stats.doctors;
              $tooltipData[2].textContent = data.stats.declarations;

              _this2.setMod(_this2.$active, 'point', 'active');
            }

            _this2.setMod(_this2.$tooltip, 'tooltip', 'show');
            break;
        }
      }, HOVER_DEBOUNCE_TIMEOUT);
    }
  }]);

  return Map;
}(_dom.BEM);

exports.default = Map;
module.exports = exports["default"];

},{"./dom":3}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Nav = function Nav(node) {
  _classCallCheck(this, Nav);

  node.addEventListener('click', function (e) {
    e.preventDefault();

    if (e.target.href === undefined) {
      return;
    }

    var to = e.target.href.split('#')[1];

    var _document$getElementB = document.getElementById(to).getBoundingClientRect(),
        top = _document$getElementB.top;

    window.scroll({ top: top + window.scrollY - 50, left: 0, behavior: 'smooth' });
  });
};

exports.default = Nav;
module.exports = exports['default'];

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createMarker = function createMarker() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var node = document.createElement('li');

  node.classList.add((0, _dom.selector)('slider', 'marker'));
  active && node.classList.add((0, _dom.selector)('slider', 'marker', 'active'));

  return node;
};

var Slider = function (_BEM) {
  _inherits(Slider, _BEM);

  function Slider(node) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', node));

    _this.currentIndex = 0;

    _this.$slides = _this.elems('slide');

    _this.$markers = [];

    _this.$control = document.createElement('ul');
    _this.$control.classList.add((0, _dom.selector)(_this.name, 'markers'));

    _this.$slides.forEach(function (node, index) {
      var marker = createMarker(index === _this.currentIndex);
      _this.$control.appendChild(marker);
      _this.$markers.push(marker);
    });

    _this.$control.addEventListener('click', function (_ref) {
      var target = _ref.target;

      if (!target.closest((0, _dom.buildClass)(_this.name, 'marker'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('marker', 'active'), 'marker', 'active');
      _this.setMod(target, 'marker', 'active');

      _this.slide(toIndex);
    }, false);

    _this.node.appendChild(_this.$control);
    return _this;
  }

  _createClass(Slider, [{
    key: 'slide',
    value: function slide(index) {
      var isNext = this.currentIndex < index;

      this.$slides[this.currentIndex].animate([{ transform: 'translateX(0)' }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)' }], this.constructor.ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)' }, { transform: 'translateX(0)' }], this.constructor.ANIMATION_OPTIONS);

      this.currentIndex = index;
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$markers.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Slider;
}(_dom.BEM);

Slider.ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};
exports.default = Slider;
module.exports = exports['default'];

},{"./dom":3}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORS_MAP = ['#90c8e6', '#b097c6', '#dfb0d0', '#e3aab8', '#afd5e7', '#c7b2d5', '#e9c7df', '#ecc7cf', '#f1eec9', '#ced8e2', '#5da892', '#5296cd', '#a3d7f2', '#f3f1a0', '#bcdad5', '#71b7a8', '#5ca9dc', '#dc91a3', '#d8816f', '#e2a394', '#7566aa', '#cadfeb', '#ddd2df', '#f4d9b5', '#d381b2'];

var createListItemNode = function createListItemNode(title, value, color) {
  var $li = document.createElement('li');
  var $span = document.createElement('span');
  var $value = document.createElement('div');

  $li.classList.add((0, _dom.selector)('declarations', 'list-item'));
  $li.textContent = title;

  $span.style.backgroundColor = color;

  $value.classList.add((0, _dom.selector)('declarations', 'list-item-value'));
  $value.textContent = (0, _utils.numberFormatting)(value);

  $li.prepend($span);
  $li.append($value);

  return $li;
};

var Statistic = function (_BEM) {
  _inherits(Statistic, _BEM);

  function Statistic(node, data) {
    _classCallCheck(this, Statistic);

    var _this = _possibleConstructorReturn(this, (Statistic.__proto__ || Object.getPrototypeOf(Statistic)).call(this, 'declarations', node));

    var fragment = document.createDocumentFragment();

    _this.$canvas = _this.elem('graph-canvas');
    _this.context = _this.$canvas.getContext('2d');

    var total = data.reduce(function (target, _ref) {
      var declarations = _ref.declarations;
      return target + declarations;
    }, 0);

    data.sort(function (a, b) {
      return a.declarations < b.declarations ? 1 : -1;
    });

    var x = 490,
        y = 490,
        r = 480,
        s = 0;


    data.forEach(function (item, index) {
      var $item = createListItemNode(item.region_name, item.declarations, COLORS_MAP[index]);

      fragment.appendChild($item);

      var radians = item.declarations / data[0].declarations * 360 * (Math.PI / 360);

      _this.context.beginPath();
      _this.context.lineWidth = 6;
      _this.context.strokeStyle = COLORS_MAP[index];
      _this.context.arc(x, y, r - 20 * index, s, radians, false);
      _this.context.stroke();
    });

    _this.elem('list').appendChild(fragment);
    _this.elem('total-value').textContent = (0, _utils.numberFormatting)(total);
    return _this;
  }

  return Statistic;
}(_dom.BEM);

exports.default = Statistic;
module.exports = exports['default'];

},{"./dom":3,"./utils":11}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PANEL_ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};

var Tabs = function (_BEM) {
  _inherits(Tabs, _BEM);

  function Tabs(node) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoHeight = _ref.autoHeight,
        autoHeight = _ref$autoHeight === undefined ? false : _ref$autoHeight;

    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, 'tabs', node));

    _this.$controls = _this.elems('nav-item');
    _this.$slides = _this.elems('slide');

    _this.$marker = document.createElement('div');
    _this.$marker.classList.add((0, _dom.selector)(_this.name, 'marker'));
    _this.elem('header').appendChild(_this.$marker);

    if (autoHeight) {
      var maxHeight = _this.$slides.reduce(function (target, item) {
        if (item.clientHeight > target) {
          target = item.clientHeight;
        }

        return target;
      }, 0);

      _this.elem('main').style.height = maxHeight + 'px';
    }

    _this.currentIndex = _this.getIndexByElem(_this.elem('nav-item', 'active'));

    _this.elem('nav').addEventListener('click', function (e) {
      var $elem = e.target.closest((0, _dom.buildClass)(_this.name, 'nav-item'));

      if (!$elem) {
        return;
      }

      var toIndex = _this.getIndexByElem($elem);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('nav-item', 'active'), 'nav-item', 'active');
      _this.setMod($elem, 'nav-item', 'active');

      _this.animatePanels(toIndex);
      _this.animateMarker(toIndex);

      _this.currentIndex = toIndex;
    }, false);

    _this.setMod(_this.elem('nav-item', 'active'), 'nav-item', 'marker');
    return _this;
  }

  _createClass(Tabs, [{
    key: 'animatePanels',
    value: function animatePanels(index) {
      var current = this.currentIndex;
      var isNext = current < index;

      current !== undefined && this.$slides[current].animate([{ transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)', opacity: 0 }], PANEL_ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)', opacity: 0 }, { transform: 'translateX(0)', opacity: 1 }], PANEL_ANIMATION_OPTIONS);
    }
  }, {
    key: 'animateMarker',
    value: function animateMarker(index) {
      var _this2 = this;

      var current = {
        left: this.$controls[this.currentIndex].offsetLeft,
        width: this.$controls[this.currentIndex].clientWidth
      };

      var left = this.$controls[index].offsetLeft;
      var width = this.$controls[index].clientWidth;

      var player = this.$marker.animate([{
        transform: 'translateX(' + current.left + 'px)',
        width: current.width + 'px'
      }, {
        transform: 'translateX(' + left + 'px)',
        width: width + 'px'
      }], _extends({}, PANEL_ANIMATION_OPTIONS));

      player.onfinish = function () {
        _this2.setMod(_this2.$controls[index], 'nav-item', 'marker');
        requestAnimationFrame(function () {
          return player.cancel();
        });
      };

      this.delMod(this.$controls[this.currentIndex], 'nav-item', 'marker');
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$controls.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Tabs;
}(_dom.BEM);

exports.default = Tabs;
module.exports = exports['default'];

},{"./dom":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var objectToQuery = function objectToQuery(target) {
  return '?' + Object.keys(target).reduce(function (arr, key) {
    return arr.push(key + '=' + target[key]) && arr;
  }, []).join('&');
};

var numberFormatting = exports.numberFormatting = function numberFormatting(number) {
  return number.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1 ').split('.')[0];
};

var fetchJSON = exports.fetchJSON = function fetchJSON(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { method: 'GET' };
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();

    if (options.body && options.method === 'GET') {
      url += objectToQuery(options.body);
    }

    request.onreadystatechange = function () {
      if (request.readyState !== 4) {
        return;
      }

      resolve(JSON.parse(request.responseText));
    };

    request.onerror = reject;
    request.open(options.method || 'GET', url);
    request.send(options.body ? JSON.stringify(options.body) : null);
  });
};

},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcyIsInNyYy9zY3JpcHRzL2RvbS5qcyIsInNyYy9zY3JpcHRzL2ZlZWRiYWNrLmpzIiwic3JjL3NjcmlwdHMvbWFpbi5qcyIsInNyYy9zY3JpcHRzL21hcC5qcyIsInNyYy9zY3JpcHRzL25hdi5qcyIsInNyYy9zY3JpcHRzL3NsaWRlci5qcyIsInNyYy9zY3JpcHRzL3N0YXRpc3RpYy5qcyIsInNyYy9zY3JpcHRzL3RhYnMuanMiLCJzcmMvc2NyaXB0cy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QW5CLGdCQUFtQjtBQUFBLFNBQzlCLE9BQU8sT0FBUCxDQUFlLENBQWYsRUFBa0IsT0FBbEIsQ0FBMEIscUJBQTFCLEVBQWlELEtBQWpELEVBQXdELEtBQXhELENBQThELEdBQTlELEVBQW1FLENBQW5FLENBRDhCO0FBQUEsQ0FBekI7O0FBSUEsSUFBTSxnQ0FBWSxTQUFaLFNBQVksQ0FBQyxHQUFEO0FBQUEsTUFBTSxPQUFOLHVFQUFnQixFQUFFLFFBQVEsS0FBVixFQUFoQjtBQUFBLFNBQXNDLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDOUYsUUFBTSxVQUFVLElBQUksY0FBSixFQUFoQjs7QUFFQSxRQUFJLFFBQVEsSUFBUixJQUFnQixRQUFRLE1BQVIsS0FBbUIsS0FBdkMsRUFBOEM7QUFDNUMsYUFBTyxjQUFjLFFBQVEsSUFBdEIsQ0FBUDtBQUNEOztBQUVELFlBQVEsa0JBQVIsR0FBNkIsWUFBTTtBQUNqQyxVQUFJLFFBQVEsVUFBUixLQUF1QixDQUEzQixFQUE4QjtBQUM1QjtBQUNEOztBQUVELGNBQVEsS0FBSyxLQUFMLENBQVcsUUFBUSxZQUFuQixDQUFSO0FBQ0QsS0FORDs7QUFRQSxZQUFRLE9BQVIsR0FBa0IsTUFBbEI7QUFDQSxZQUFRLElBQVIsQ0FBYSxRQUFRLE1BQVIsSUFBa0IsS0FBL0IsRUFBc0MsR0FBdEM7QUFDQSxZQUFRLElBQVIsQ0FBYSxRQUFRLElBQVIsR0FBZSxLQUFLLFNBQUwsQ0FBZSxRQUFRLElBQXZCLENBQWYsR0FBOEMsSUFBM0Q7QUFDRCxHQWxCOEQsQ0FBdEM7QUFBQSxDQUFsQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgXG4gIC8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gICAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gICAgfVxuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAoc2VsZi5fc3RhdGUgPT09IDEgPyByZXNvbHZlIDogcmVqZWN0KShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl92YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChzZWxmLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICBzZWxmLl9zdGF0ZSA9IDI7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fZGVmZXJyZWRzW2ldKTtcbiAgICB9XG4gICAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICAgKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAgICpcbiAgICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICAgKi9cbiAgZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHJlamVjdChzZWxmLCBleCk7XG4gICAgfVxuICB9XG5cbiAgUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBwcm9tID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShub29wKTtcblxuICAgIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbSkpO1xuICAgIHJldHVybiBwcm9tO1xuICB9O1xuXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3QodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9KSB8fFxuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICAgIH07XG5cbiAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1tZWRpYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldEltbWVkaWF0ZUZuID0gZnVuY3Rpb24gX3NldEltbWVkaWF0ZUZuKGZuKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSBmbjtcbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF9zZXRVbmhhbmRsZWRSZWplY3Rpb25Gbihmbikge1xuICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZm47XG4gIH07XG4gIFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4gIH0gZWxzZSBpZiAoIXJvb3QuUHJvbWlzZSkge1xuICAgIHJvb3QuUHJvbWlzZSA9IFByb21pc2U7XG4gIH1cblxufSkodGhpcyk7XG4iLCIvKlxuICogc21vb3Roc2Nyb2xsIHBvbHlmaWxsIC0gdjAuMy41XG4gKiBodHRwczovL2lhbWR1c3Rhbi5naXRodWIuaW8vc21vb3Roc2Nyb2xsXG4gKiAyMDE2IChjKSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24odywgZCwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKlxuICAgKiBhbGlhc2VzXG4gICAqIHc6IHdpbmRvdyBnbG9iYWwgb2JqZWN0XG4gICAqIGQ6IGRvY3VtZW50XG4gICAqIHVuZGVmaW5lZDogdW5kZWZpbmVkXG4gICAqL1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIHJldHVybiB3aGVuIHNjcm9sbEJlaGF2aW9yIGludGVyZmFjZSBpcyBzdXBwb3J0ZWRcbiAgICBpZiAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkLmRvY3VtZW50RWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogZ2xvYmFsc1xuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLypcbiAgICAgKiBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgICAqL1xuICAgIHZhciBub3cgPSB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XG4gICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGVhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHNtb290aCBiZWhhdmlvciBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqIEBtZXRob2Qgc2hvdWxkQmFpbE91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0geFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoeCkge1xuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgfHwgeCA9PT0gbnVsbFxuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSAnYXV0bydcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdpbnN0YW50Jykge1xuICAgICAgICAvLyBmaXJzdCBhcmcgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnXG4gICAgICAgICAgICAmJiB4LmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QgYW5kIGJlaGF2aW9yIGlzIHNtb290aFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yIHdoZW4gYmVoYXZpb3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmVoYXZpb3Igbm90IHZhbGlkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHZhciBpc0JvZHk7XG4gICAgICB2YXIgaGFzU2Nyb2xsYWJsZVNwYWNlO1xuICAgICAgdmFyIGhhc1Zpc2libGVPdmVyZmxvdztcblxuICAgICAgZG8ge1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gc2V0IGNvbmRpdGlvbiB2YXJpYWJsZXNcbiAgICAgICAgaXNCb2R5ID0gZWwgPT09IGQuYm9keTtcbiAgICAgICAgaGFzU2Nyb2xsYWJsZVNwYWNlID1cbiAgICAgICAgICBlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHQgfHxcbiAgICAgICAgICBlbC5jbGllbnRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgICBoYXNWaXNpYmxlT3ZlcmZsb3cgPVxuICAgICAgICAgIHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkub3ZlcmZsb3cgPT09ICd2aXNpYmxlJztcbiAgICAgIH0gd2hpbGUgKCFpc0JvZHkgJiYgIShoYXNTY3JvbGxhYmxlU3BhY2UgJiYgIWhhc1Zpc2libGVPdmVyZmxvdykpO1xuXG4gICAgICBpc0JvZHkgPSBoYXNTY3JvbGxhYmxlU3BhY2UgPSBoYXNWaXNpYmxlT3ZlcmZsb3cgPSBudWxsO1xuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WTtcbiAgICAgIHZhciBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBTQ1JPTExfVElNRTtcblxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXG4gICAgICB2YWx1ZSA9IGVhc2UoZWxhcHNlZCk7XG5cbiAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgICBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcblxuICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgIGlmIChjdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcbiAgICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcC5iaW5kKHcsIGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxzIHdpbmRvdyB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgICAqL1xuXG4gICAgLy8gdy5zY3JvbGwgYW5kIHcuc2Nyb2xsVG9cbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHcuc2Nyb2xsQnlcbiAgICB3LnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgKHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0KSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0udG9wICsgKHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIGFuZCBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCA9IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgfHwgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicgPyBsZWZ0IDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHR5cGVvZiB0b3AgPT09ICdudW1iZXInID8gdG9wIDogdGhpcy5zY3JvbGxUb3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmcwID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKHtcbiAgICAgICAgICBsZWZ0OiBhcmcwLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhcmcwLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiBhcmcwLmJlaGF2aW9yXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoXG4gICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ICsgYXJnMCxcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvcCArIGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcbiAgICAgICAgLy8gcmV2ZWFsIHBhcmVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBjbGllbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gY29tbW9uanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgcG9seWZpbGw6IHBvbHlmaWxsIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2xvYmFsXG4gICAgcG9seWZpbGwoKTtcbiAgfVxufSkod2luZG93LCBkb2N1bWVudCk7XG4iLCJleHBvcnQgY29uc3QgdG9BcnJheSA9IGFycmF5TGlrZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5TGlrZSkpIHtcbiAgICByZXR1cm4gYXJyYXlMaWtlO1xuICB9XG5cbiAgaWYgKGFycmF5TGlrZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gIH1cblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbmV4cG9ydCBjb25zdCAkID0gKHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpID0+IChcbiAgdG9BcnJheShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChjb250ZXh0LCBzZWxlY3RvcikpXG4pO1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IgPSAoYmxvY2ssIGVsZW0sIG1vZE5hbWUsIG1vZFZhbCkgPT4gKFxuICBgJHtibG9ja31fXyR7ZWxlbX0ke21vZE5hbWUgPyAobW9kVmFsID8gYF8ke21vZE5hbWV9XyR7bW9kVmFsfWAgOiBgXyR7bW9kTmFtZX1gKSA6ICcnfWBcbik7XG5cbmV4cG9ydCBjb25zdCBidWlsZENsYXNzID0gKC4uLmFyZ3MpID0+IGAuJHtzZWxlY3RvciguLi5hcmdzKX1gO1xuXG5leHBvcnQgY2xhc3MgQkVNIGV4dGVuZHMgbnVsbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIG5vZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIGVsZW0obmFtZSwgbW9kTmFtZSwgbW9kVmFsKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpKTtcbiAgfVxuXG4gIGVsZW1zKG5hbWUsIG1vZE5hbWUsIG1vZFZhbCkge1xuICAgIHJldHVybiAkKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpLCB0aGlzLm5vZGUpO1xuICB9XG5cbiAgc2V0TW9kKGVsZW0sIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbE1vZChlbGVtLCBlbGVtTmFtZSwgbW9kTmFtZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lKSlcbiAgICApKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59IiwiaW1wb3J0IHsgQkVNIH0gZnJvbSAnLi9kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWVkYmFjayBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignZmVlZGJhY2snLCBub2RlKTtcblxuICAgIHRoaXMuJG5hbWUgPSB0aGlzLmVsZW0oJ25hbWUnKTtcbiAgICB0aGlzLiRtZXNzYWdlID0gdGhpcy5lbGVtKCdtZXNzYWdlJyk7XG4gICAgdGhpcy4kbWFpbFRvID0gdGhpcy5lbGVtKCdtYWlsdG8nKTtcblxuICAgIG5vZGUub25zdWJtaXQgPSAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLiRtYWlsVG8uaHJlZiA9IGBtYWlsdG86aW5mb0Buc3p1Lmdvdi51YT9zdWJqZWN0PdCX0LLQvtGA0L7RgtC90ZbQuSDQt9Cy4oCZ0Y/Qt9C+0Log0LLRltC0ICR7dGhpcy4kbmFtZS52YWx1ZX0mYm9keT0ke3RoaXMuJG1lc3NhZ2UudmFsdWV9YDtcbiAgICAgIHRoaXMuJG1haWxUby5jbGljaygpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCBQcm9taXNlIGZyb20gJ3Byb21pc2UtcG9seWZpbGwnO1xuaW1wb3J0IFNtb290aFNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuXG5pbXBvcnQgeyAkIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCBOYXYgZnJvbSAnLi9uYXYnO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi90YWJzJztcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgU3RhdGlzdGljIGZyb20gJy4vc3RhdGlzdGljJztcbmltcG9ydCBGZWVkYmFjayBmcm9tICcuL2ZlZWRiYWNrJztcblxuaWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuICB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cblNtb290aFNjcm9sbC5wb2x5ZmlsbCgpO1xuXG4kKCcubmF2JykuZm9yRWFjaChub2RlID0+IG5ldyBOYXYobm9kZSkpO1xuJCgnLnRhYnMnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFRhYnMobm9kZSkpO1xuJCgnLnNsaWRlcicpLmZvckVhY2gobm9kZSA9PiBuZXcgU2xpZGVyKG5vZGUpKTtcbiQoJy5mZWVkYmFjaycpLmZvckVhY2gobm9kZSA9PiBuZXcgRmVlZGJhY2sobm9kZSkpO1xuXG5mZXRjaEpTT04oJ2RhdGEvc3RhdHMuanNvbicpLnRoZW4oZGF0YSA9PiB7XG4gICQoJy5kZWNsYXJhdGlvbnMnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFN0YXRpc3RpYyhub2RlLCBkYXRhKSk7XG59KTtcblxuZmV0Y2hKU09OKCdodHRwOi8vZGV2LmVoZWFsdGgud29ybGQvcmVwb3J0cy9zdGF0cy9yZWdpb25zJykudGhlbihkYXRhID0+IHtcbiAgJCgnLm1hcCcpLmZvckVhY2gobm9kZSA9PiBuZXcgTWFwKG5vZGUsIGRhdGEuZGF0YSkpO1xufSk7XG5cbmZldGNoSlNPTignaHR0cDovL2Rldi5laGVhbHRoLndvcmxkL3JlcG9ydHMvc3RhdHMvJykudGhlbihkYXRhID0+IHtcbiAgY29uc3Qgam9pbmVkX2l0ZW1zID0gJCgnLmpvaW5lZF9faXRlbS1jb3VudCcpO1xuICBqb2luZWRfaXRlbXNbMF0uaW5uZXJUZXh0ID0gZGF0YS5kYXRhLm1zcHM7XG4gIGpvaW5lZF9pdGVtc1sxXS5pbm5lclRleHQgPSBkYXRhLmRhdGEuZG9jdG9ycztcbiAgam9pbmVkX2l0ZW1zWzJdLmlubmVyVGV4dCA9IGRhdGEuZGF0YS5kZWNsYXJhdGlvbnM7XG59KTtcbiIsImltcG9ydCB7IEJFTSwgYnVpbGRDbGFzcyB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgSE9WRVJfREVCT1VOQ0VfVElNRU9VVCA9IDIwMDtcblxuY29uc3QgUkVHSU9OX1BPSU5UX01BUCA9IHtcbiAgXCLQnC7QmtCY0IfQklwiOiB7IGxlZnQ6IDQ1MywgdG9wOiAxNzUgfSxcbiAgXCLQmtCY0IfQktCh0KzQmtCQXCI6IHsgbGVmdDogNDUzLCB0b3A6IDE0MCB9LFxuICBcItCS0J7Qm9CY0J3QodCs0JrQkFwiOiB7IGxlZnQ6IDE1MywgdG9wOiAxMDAgfSxcbiAgXCLQm9Cs0JLQhtCS0KHQrNCa0JBcIjogeyBsZWZ0OiA4MywgdG9wOiAyMDYgfSxcbiAgXCLQl9CQ0JrQkNCg0J/QkNCi0KHQrNCa0JBcIjogeyBsZWZ0OiA0OCwgdG9wOiAzMTIgfSxcbiAgXCLQhtCS0JDQndCeLdCk0KDQkNCd0JrQhtCS0KHQrNCa0JBcIjogeyBsZWZ0OiAxNTMsIHRvcDogMzEyIH0sXG4gIFwi0KfQldCg0J3QhtCS0JXQptCs0JrQkFwiOiB7IGxlZnQ6IDIwNywgdG9wOiAzMjkgfSxcbiAgXCLQotCV0KDQndCe0J/QhtCb0KzQodCs0JrQkFwiOiB7IGxlZnQ6IDE4OCwgdG9wOiAyNDEgfSxcbiAgXCLQoNCG0JLQndCV0J3QodCs0JrQkFwiOiB7IGxlZnQ6IDI0MSwgdG9wOiAxMDAgfSxcbiAgXCLQpdCc0JXQm9Cs0J3QmNCm0KzQmtCQXCI6IHsgbGVmdDogMjU5LCB0b3A6IDIwNiB9LFxuICBcItCW0JjQotCe0JzQmNCg0KHQrNCa0JBcIjogeyBsZWZ0OiAzNDcsIHRvcDogMTUzIH0sXG4gIFwi0JLQhtCd0J3QmNCm0KzQmtCQXCI6IHsgbGVmdDogMzY1LCB0b3A6IDI3NyB9LFxuICBcItCn0JXQoNCa0JDQodCs0JrQkFwiOiB7IGxlZnQ6IDUyMywgdG9wOiAyNDEgfSxcbiAgXCLQmtCG0KDQntCS0J7Qk9Cg0JDQlNCh0KzQmtCQXCI6IHsgbGVmdDogNTQxLCB0b3A6IDMxMiB9LFxuICBcItCf0J7Qm9Ci0JDQktCh0KzQmtCQXCI6IHsgbGVmdDogNjQ2LCB0b3A6IDE4OCB9LFxuICBcItCn0JXQoNCd0IbQk9CG0JLQodCs0JrQkFwiOiB7IGxlZnQ6IDU0MSwgdG9wOiA2NSB9LFxuICBcItCh0KPQnNCh0KzQmtCQXCI6IHsgbGVmdDogNjQ2LCB0b3A6IDEwMCB9LFxuICBcItCl0JDQoNCa0IbQktCh0KzQmtCQXCI6IHsgbGVmdDogNzcwLCB0b3A6IDIwNSB9LFxuICBcItCb0KPQk9CQ0J3QodCs0JrQkFwiOiB7IGxlZnQ6IDkxMSwgdG9wOiAyNTkgfSxcbiAgXCLQlNCd0IbQn9Cg0J7Qn9CV0KLQoNCe0JLQodCs0JrQkFwiOiB7IGxlZnQ6IDY4MiwgdG9wOiAzMTEgfSxcbiAgXCLQlNCe0J3QldCm0KzQmtCQXCI6IHsgbGVmdDogODQwLCB0b3A6IDM0NyB9LFxuICBcItCX0JDQn9Ce0KDQhtCX0KzQmtCQXCI6IHsgbGVmdDogNzUyLCB0b3A6IDQxNyB9LFxuICBcItCl0JXQoNCh0J7QndCh0KzQmtCQXCI6IHsgbGVmdDogNjI5LCB0b3A6IDQ1MiB9LFxuICBcItCc0JjQmtCe0JvQkNCH0JLQodCs0JrQkFwiOiB7IGxlZnQ6IDUyMywgdG9wOiAzOTkgfSxcbiAgXCLQntCU0JXQodCs0JrQkFwiOiB7IGxlZnQ6IDQ1MywgdG9wOiA0MzUgfSxcbiAgXCLQkNCS0KLQntCd0J7QnNCd0JAg0KDQldCh0J/Qo9CR0JvQhtCa0JAg0JrQoNCY0JxcIjogeyBsZWZ0OiA2NjQsIHRvcDogNTU4IH0sXG4gIFwi0Jwu0KHQldCS0JDQodCi0J7Qn9Ce0JvQrFwiOiB7IGxlZnQ6IDYxNCwgdG9wOiA1ODggfVxufTtcblxuY29uc3QgY3JlYXRlUG9pbnQgPSAoeyBsZWZ0LCB0b3AgfSkgPT4ge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCdtYXBfX3BvaW50Jyk7XG4gIG5vZGUuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICBub2RlLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXAgZXh0ZW5kcyBCRU0ge1xuICBkYXRhID0gW107XG4gIHRpbWVvdXQgPSBudWxsO1xuXG5cbiAgY29uc3RydWN0b3Iobm9kZSwgZGF0YSkge1xuICAgIHN1cGVyKCdtYXAnLCBub2RlKTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy4kdG9vbHRpcCA9IHRoaXMuZWxlbSgndG9vbHRpcCcpO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludCA9IGNyZWF0ZVBvaW50KFJFR0lPTl9QT0lOVF9NQVBbaXRlbS5yZWdpb24ubmFtZV0pO1xuICAgICAgcG9pbnQuZGF0YXNldC5pbmRleCA9IGluZGV4O1xuXG4gICAgICBwb2ludC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLCBmYWxzZSk7XG4gICAgICBwb2ludC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMsIGZhbHNlKTtcblxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQocG9pbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kdG9vbHRpcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy4kdG9vbHRpcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMsIGZhbHNlKTtcblxuICAgIHRoaXMuZWxlbSgnbWFpbicpLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KHsgdGFyZ2V0LCB0eXBlIH0pIHtcbiAgICBpZiAodHlwZSA9PT0gJ21vdXNlb3ZlcicgJiYgdGFyZ2V0LmRhdGFzZXQuaW5kZXgpIHtcbiAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUudG9wID0gdGFyZ2V0LnN0eWxlLnRvcDtcbiAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUubGVmdCA9IHRhcmdldC5zdHlsZS5sZWZ0O1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgICB0aGlzLmRlbE1vZCh0aGlzLiR0b29sdGlwLCAndG9vbHRpcCcsICdzaG93Jyk7XG4gICAgICAgICAgdGhpcy5kZWxNb2QodGhpcy4kYWN0aXZlLCAncG9pbnQnLCAnYWN0aXZlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVt0YXJnZXQuZGF0YXNldC5pbmRleF07XG5cbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgJHRvb2x0aXBEYXRhID0gdGhpcy4kdG9vbHRpcC5xdWVyeVNlbGVjdG9yQWxsKGAke2J1aWxkQ2xhc3MoJ21hcCcsICd0b29sdGlwLWRhdGEnKX0gZHRgKTtcblxuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS50b3AgPSB0YXJnZXQuc3R5bGUudG9wO1xuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS5sZWZ0ID0gdGFyZ2V0LnN0eWxlLmxlZnQ7XG5cbiAgICAgICAgICAgIHRoaXMuJGFjdGl2ZSAmJiB0aGlzLmRlbE1vZCh0aGlzLiRhY3RpdmUsICdwb2ludCcsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TW9kKHRoaXMuJHRvb2x0aXAsICd0b29sdGlwJywgJ3Nob3cnKTtcblxuICAgICAgICAgICAgdGhpcy4kdG9vbHRpcC5xdWVyeVNlbGVjdG9yKGJ1aWxkQ2xhc3MoJ21hcCcsICd0b29sdGlwLXRpdGxlJykpLnRleHRDb250ZW50ID0gZGF0YS5yZWdpb24ubmFtZTtcbiAgICAgICAgICAgIHRoaXMuJGFjdGl2ZSA9IHRhcmdldDtcblxuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzBdLnRleHRDb250ZW50ID0gZGF0YS5zdGF0cy5tc3BzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzFdLnRleHRDb250ZW50ID0gZGF0YS5zdGF0cy5kb2N0b3JzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzJdLnRleHRDb250ZW50ID0gZGF0YS5zdGF0cy5kZWNsYXJhdGlvbnM7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0TW9kKHRoaXMuJGFjdGl2ZSwgJ3BvaW50JywgJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2V0TW9kKHRoaXMuJHRvb2x0aXAsICd0b29sdGlwJywgJ3Nob3cnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCBIT1ZFUl9ERUJPVU5DRV9USU1FT1VUKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdiB7XG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChlLnRhcmdldC5ocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0byA9IGUudGFyZ2V0LmhyZWYuc3BsaXQoJyMnKVsxXTtcbiAgICAgIGNvbnN0IHsgdG9wIH0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0bykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHdpbmRvdy5zY3JvbGwoeyB0b3A6ICh0b3AgKyB3aW5kb3cuc2Nyb2xsWSkgLSA1MCwgbGVmdDogMCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH0pXG4gIH1cbn0iLCJpbXBvcnQgeyBCRU0sIGJ1aWxkQ2xhc3MsIHNlbGVjdG9yIH0gZnJvbSAnLi9kb20nO1xuXG5jb25zdCBjcmVhdGVNYXJrZXIgPSAoYWN0aXZlID0gZmFsc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgbm9kZS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKCdzbGlkZXInLCAnbWFya2VyJykpO1xuICBhY3RpdmUgJiYgbm9kZS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKCdzbGlkZXInLCAnbWFya2VyJywgJ2FjdGl2ZScpKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlciBleHRlbmRzIEJFTSB7XG4gIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgIHN1cGVyKCdzbGlkZXInLCBub2RlKTtcbiAgICB0aGlzLiRzbGlkZXMgPSB0aGlzLmVsZW1zKCdzbGlkZScpO1xuXG4gICAgdGhpcy4kbWFya2VycyA9IFtdO1xuXG4gICAgdGhpcy4kY29udHJvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgdGhpcy4kY29udHJvbC5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKHRoaXMubmFtZSwgJ21hcmtlcnMnKSk7XG5cbiAgICB0aGlzLiRzbGlkZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG1hcmtlciA9IGNyZWF0ZU1hcmtlcihpbmRleCA9PT0gdGhpcy5jdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy4kY29udHJvbC5hcHBlbmRDaGlsZChtYXJrZXIpO1xuICAgICAgdGhpcy4kbWFya2Vycy5wdXNoKG1hcmtlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRjb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKHsgdGFyZ2V0IH0pID0+IHtcbiAgICAgIGlmICghdGFyZ2V0LmNsb3Nlc3QoYnVpbGRDbGFzcyh0aGlzLm5hbWUsICdtYXJrZXInKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b0luZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSh0YXJnZXQpO1xuXG4gICAgICBpZiAodG9JbmRleCA9PT0gdGhpcy5jdXJyZW50SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlbE1vZCh0aGlzLmVsZW0oJ21hcmtlcicsICdhY3RpdmUnKSwgJ21hcmtlcicsICdhY3RpdmUnKTtcbiAgICAgIHRoaXMuc2V0TW9kKHRhcmdldCwgJ21hcmtlcicsICdhY3RpdmUnKTtcblxuICAgICAgdGhpcy5zbGlkZSh0b0luZGV4KTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy4kY29udHJvbCk7XG4gIH1cblxuICBzbGlkZShpbmRleCkge1xuICAgIGNvbnN0IGlzTmV4dCA9IHRoaXMuY3VycmVudEluZGV4IDwgaW5kZXg7XG5cbiAgICB0aGlzLiRzbGlkZXNbdGhpcy5jdXJyZW50SW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJyB9LFxuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJy0nIDogJyd9MTAwJSlgIH1cbiAgICBdLCB0aGlzLmNvbnN0cnVjdG9yLkFOSU1BVElPTl9PUFRJT05TKTtcblxuICAgIHRoaXMuJHNsaWRlc1tpbmRleF0uYW5pbWF0ZShbXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtpc05leHQgPyAnJyA6ICctJ30xMDAlKWAgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScgfVxuICAgIF0sIHRoaXMuY29uc3RydWN0b3IuQU5JTUFUSU9OX09QVElPTlMpO1xuXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgfVxuXG4gIGdldEluZGV4QnlFbGVtKGVsZW0pIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIHRoaXMuJG1hcmtlcnMuc29tZSgobm9kZSwgaSkgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHN0YXRpYyBBTklNQVRJT05fT1BUSU9OUyA9IHtcbiAgICBkdXJhdGlvbjogMzAwLFxuICAgIGZpbGw6ICdmb3J3YXJkcycsXG4gICAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnXG4gIH1cbn0iLCJpbXBvcnQgeyBCRU0sIHNlbGVjdG9yIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgbnVtYmVyRm9ybWF0dGluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBDT0xPUlNfTUFQID0gW1xuICAnIzkwYzhlNicsICcjYjA5N2M2JywgJyNkZmIwZDAnLFxuICAnI2UzYWFiOCcsICcjYWZkNWU3JywgJyNjN2IyZDUnLFxuICAnI2U5YzdkZicsICcjZWNjN2NmJywgJyNmMWVlYzknLFxuICAnI2NlZDhlMicsICcjNWRhODkyJywgJyM1Mjk2Y2QnLFxuICAnI2EzZDdmMicsICcjZjNmMWEwJywgJyNiY2RhZDUnLFxuICAnIzcxYjdhOCcsICcjNWNhOWRjJywgJyNkYzkxYTMnLFxuICAnI2Q4ODE2ZicsICcjZTJhMzk0JywgJyM3NTY2YWEnLFxuICAnI2NhZGZlYicsICcjZGRkMmRmJywgJyNmNGQ5YjUnLFxuICAnI2QzODFiMidcbl07XG5cbmNvbnN0IGNyZWF0ZUxpc3RJdGVtTm9kZSA9ICh0aXRsZSwgdmFsdWUsIGNvbG9yKSA9PiB7XG4gIGNvbnN0ICRsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGNvbnN0ICRzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBjb25zdCAkdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAkbGkuY2xhc3NMaXN0LmFkZChzZWxlY3RvcignZGVjbGFyYXRpb25zJywgJ2xpc3QtaXRlbScpKTtcbiAgJGxpLnRleHRDb250ZW50ID0gdGl0bGU7XG5cbiAgJHNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG5cbiAgJHZhbHVlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ2RlY2xhcmF0aW9ucycsICdsaXN0LWl0ZW0tdmFsdWUnKSk7XG4gICR2YWx1ZS50ZXh0Q29udGVudCA9IG51bWJlckZvcm1hdHRpbmcodmFsdWUpO1xuXG4gICRsaS5wcmVwZW5kKCRzcGFuKTtcbiAgJGxpLmFwcGVuZCgkdmFsdWUpO1xuXG4gIHJldHVybiAkbGk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aXN0aWMgZXh0ZW5kcyBCRU0ge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBkYXRhKSB7XG4gICAgc3VwZXIoJ2RlY2xhcmF0aW9ucycsIG5vZGUpO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB0aGlzLiRjYW52YXMgPSB0aGlzLmVsZW0oJ2dyYXBoLWNhbnZhcycpO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuJGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY29uc3QgdG90YWwgPSBkYXRhLnJlZHVjZSgodGFyZ2V0LCB7IGRlY2xhcmF0aW9ucyB9KSA9PiB0YXJnZXQgKyBkZWNsYXJhdGlvbnMsIDApO1xuXG4gICAgZGF0YS5zb3J0KChhLCBiKSA9PiBhLmRlY2xhcmF0aW9ucyA8IGIuZGVjbGFyYXRpb25zID8gMSA6IC0xKTtcblxuICAgIGxldCBbeCwgeSwgciwgc10gPSBbNDkwLCA0OTAsIDQ4MCwgMF07XG5cbiAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCAkaXRlbSA9IGNyZWF0ZUxpc3RJdGVtTm9kZShcbiAgICAgICAgaXRlbS5yZWdpb25fbmFtZSxcbiAgICAgICAgaXRlbS5kZWNsYXJhdGlvbnMsXG4gICAgICAgIENPTE9SU19NQVBbaW5kZXhdXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCgkaXRlbSk7XG5cbiAgICAgIGxldCByYWRpYW5zID0gKChpdGVtLmRlY2xhcmF0aW9ucyAvIGRhdGFbMF0uZGVjbGFyYXRpb25zKSAqIDM2MCkgKiAoTWF0aC5QSSAvIDM2MCk7XG5cbiAgICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSA2O1xuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gQ09MT1JTX01BUFtpbmRleF07XG4gICAgICB0aGlzLmNvbnRleHQuYXJjKHgsIHksIHIgLSAoMjAgKiBpbmRleCksIHMsIHJhZGlhbnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY29udGV4dC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZWxlbSgnbGlzdCcpLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB0aGlzLmVsZW0oJ3RvdGFsLXZhbHVlJykudGV4dENvbnRlbnQgPSBudW1iZXJGb3JtYXR0aW5nKHRvdGFsKTtcbiAgfVxufSIsImltcG9ydCB7ICQsIEJFTSwgYnVpbGRDbGFzcywgc2VsZWN0b3IgfSBmcm9tICcuL2RvbSc7XG5cbmNvbnN0IFBBTkVMX0FOSU1BVElPTl9PUFRJT05TID0ge1xuICBkdXJhdGlvbjogMzAwLFxuICBmaWxsOiAnZm9yd2FyZHMnLFxuICBlYXNpbmc6ICdlYXNlLWluLW91dCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYnMgZXh0ZW5kcyBCRU0ge1xuICBjb25zdHJ1Y3Rvcihub2RlLCB7IGF1dG9IZWlnaHQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcigndGFicycsIG5vZGUpO1xuXG4gICAgdGhpcy4kY29udHJvbHMgPSB0aGlzLmVsZW1zKCduYXYtaXRlbScpO1xuICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuZWxlbXMoJ3NsaWRlJyk7XG5cbiAgICB0aGlzLiRtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLiRtYXJrZXIuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsICdtYXJrZXInKSk7XG4gICAgdGhpcy5lbGVtKCdoZWFkZXInKS5hcHBlbmRDaGlsZCh0aGlzLiRtYXJrZXIpO1xuXG4gICAgaWYgKGF1dG9IZWlnaHQpIHtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuJHNsaWRlcy5yZWR1Y2UoKHRhcmdldCwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5jbGllbnRIZWlnaHQgPiB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSBpdGVtLmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9LCAwKTtcblxuICAgICAgdGhpcy5lbGVtKCdtYWluJykuc3R5bGUuaGVpZ2h0ID0gYCR7bWF4SGVpZ2h0fXB4YDtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUVsZW0odGhpcy5lbGVtKCduYXYtaXRlbScsICdhY3RpdmUnKSk7XG5cbiAgICB0aGlzLmVsZW0oJ25hdicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmICghZS50YXJnZXQuY2xvc2VzdChidWlsZENsYXNzKHRoaXMubmFtZSwgJ25hdi1pdGVtJykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9JbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUVsZW0oZS50YXJnZXQpO1xuXG4gICAgICBpZiAodG9JbmRleCA9PT0gdGhpcy5jdXJyZW50SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlbE1vZCh0aGlzLmVsZW0oJ25hdi1pdGVtJywgJ2FjdGl2ZScpLCAnbmF2LWl0ZW0nLCAnYWN0aXZlJyk7XG4gICAgICB0aGlzLnNldE1vZChlLnRhcmdldCwgJ25hdi1pdGVtJywgJ2FjdGl2ZScpO1xuXG4gICAgICB0aGlzLmFuaW1hdGVQYW5lbHModG9JbmRleCk7XG4gICAgICB0aGlzLmFuaW1hdGVNYXJrZXIodG9JbmRleCk7XG5cbiAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gdG9JbmRleDtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLnNldE1vZCh0aGlzLmVsZW0oJ25hdi1pdGVtJywgJ2FjdGl2ZScpLCAnbmF2LWl0ZW0nLCAnbWFya2VyJyk7XG4gIH1cblxuICBhbmltYXRlUGFuZWxzKGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudEluZGV4O1xuICAgIGNvbnN0IGlzTmV4dCA9IGN1cnJlbnQgPCBpbmRleDtcblxuICAgIChjdXJyZW50ICE9PSB1bmRlZmluZWQpICYmIHRoaXMuJHNsaWRlc1tjdXJyZW50XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICctJyA6ICcnfTEwMCUpYCwgb3BhY2l0eTogMCB9XG4gICAgXSwgUEFORUxfQU5JTUFUSU9OX09QVElPTlMpO1xuXG4gICAgdGhpcy4kc2xpZGVzW2luZGV4XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICcnIDogJy0nfTEwMCUpYCwgb3BhY2l0eTogMCB9LFxuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJywgb3BhY2l0eTogMSB9XG4gICAgXSwgUEFORUxfQU5JTUFUSU9OX09QVElPTlMpO1xuICB9XG5cbiAgYW5pbWF0ZU1hcmtlcihpbmRleCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICBsZWZ0OiB0aGlzLiRjb250cm9sc1t0aGlzLmN1cnJlbnRJbmRleF0ub2Zmc2V0TGVmdCxcbiAgICAgIHdpZHRoOiB0aGlzLiRjb250cm9sc1t0aGlzLmN1cnJlbnRJbmRleF0uY2xpZW50V2lkdGhcbiAgICB9O1xuXG4gICAgY29uc3QgbGVmdCA9IHRoaXMuJGNvbnRyb2xzW2luZGV4XS5vZmZzZXRMZWZ0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy4kY29udHJvbHNbaW5kZXhdLmNsaWVudFdpZHRoO1xuXG4gICAgY29uc3QgcGxheWVyID0gdGhpcy4kbWFya2VyLmFuaW1hdGUoW1xuICAgICAge1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7Y3VycmVudC5sZWZ0fXB4KWAsXG4gICAgICAgIHdpZHRoOiBgJHtjdXJyZW50LndpZHRofXB4YFxuICAgICAgfSwge1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bGVmdH1weClgLFxuICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgXG4gICAgICB9XG4gICAgXSwgey4uLlBBTkVMX0FOSU1BVElPTl9PUFRJT05TLCBmaWxsOiAnbm9uZSd9KTtcblxuICAgIHBsYXllci5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0TW9kKHRoaXMuJGNvbnRyb2xzW2luZGV4XSwgJ25hdi1pdGVtJywgJ21hcmtlcicpO1xuICAgIH07XG5cbiAgICB0aGlzLmRlbE1vZCh0aGlzLiRjb250cm9sc1t0aGlzLmN1cnJlbnRJbmRleF0sICduYXYtaXRlbScsICdtYXJrZXInKVxuICB9XG5cbiAgZ2V0SW5kZXhCeUVsZW0oZWxlbSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgdGhpcy4kY29udHJvbHMuc29tZSgobm9kZSwgaSkgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxufSIsImNvbnN0IG9iamVjdFRvUXVlcnkgPSAodGFyZ2V0KSA9PiAoXG4gICc/JyArIE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKChhcnIsIGtleSkgPT4gKFxuICAgIGFyci5wdXNoKGAke2tleX09JHt0YXJnZXRba2V5XX1gKSAmJiBhcnJcbiAgKSwgW10pLmpvaW4oJyYnKVxuKTtcblxuZXhwb3J0IGNvbnN0IG51bWJlckZvcm1hdHRpbmcgPSBudW1iZXIgPT4gKFxuICBudW1iZXIudG9GaXhlZCgyKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pK1xcLikvZywgJyQxICcpLnNwbGl0KCcuJylbMF1cbik7XG5cbmV4cG9ydCBjb25zdCBmZXRjaEpTT04gPSAodXJsLCBvcHRpb25zID0geyBtZXRob2Q6ICdHRVQnIH0pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGlmIChvcHRpb25zLmJvZHkgJiYgb3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgdXJsICs9IG9iamVjdFRvUXVlcnkob3B0aW9ucy5ib2R5KTtcbiAgfVxuXG4gIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlKEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgfTtcblxuICByZXF1ZXN0Lm9uZXJyb3IgPSByZWplY3Q7XG4gIHJlcXVlc3Qub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKTtcbiAgcmVxdWVzdC5zZW5kKG9wdGlvbnMuYm9keSA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSkgOiBudWxsKTtcbn0pOyJdfQ==