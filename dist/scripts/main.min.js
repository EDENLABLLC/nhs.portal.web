(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],2:[function(require,module,exports){
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          arguments[0].left,
          arguments[0].top
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(this, arguments[0] || true);
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var toArray = exports.toArray = function toArray(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return arrayLike;
  }

  if (arrayLike instanceof Node) {
    return [arrayLike];
  }

  return Array.prototype.slice.call(arrayLike);
};

var $ = exports.$ = function $(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll.call(context, selector));
};

var selector = exports.selector = function selector(block, elem, modName, modVal) {
  return block + '__' + elem + (modName ? modVal ? '_' + modName + '_' + modVal : '_' + modName : '');
};

var buildClass = exports.buildClass = function buildClass() {
  return '.' + selector.apply(undefined, arguments);
};

var BEM = exports.BEM = function (_ref) {
  _inherits(BEM, _ref);

  function BEM(name, node) {
    _classCallCheck(this, BEM);

    var _this = _possibleConstructorReturn(this, (BEM.__proto__ || Object.getPrototypeOf(BEM)).call(this));

    _this.node = node;
    _this.name = name;
    return _this;
  }

  _createClass(BEM, [{
    key: 'elem',
    value: function elem(name, modName, modVal) {
      return this.node.querySelector(buildClass(this.name, name, modName, modVal));
    }
  }, {
    key: 'elems',
    value: function elems(name, modName, modVal) {
      return $(buildClass(this.name, name, modName, modVal), this.node);
    }
  }, {
    key: 'setMod',
    value: function setMod(elem, elemName, modName, modValue) {
      var _this2 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.add(selector(_this2.name, elemName, modName, modValue));
      });

      return this;
    }
  }, {
    key: 'delMod',
    value: function delMod(elem, elemName, modName) {
      var _this3 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.remove(selector(_this3.name, elemName, modName));
      });

      return this;
    }
  }]);

  return BEM;
}(null);

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feedback = function (_BEM) {
  _inherits(Feedback, _BEM);

  function Feedback(node) {
    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this, 'feedback', node));

    _this.$name = _this.elem('name');
    _this.$message = _this.elem('message');
    _this.$mailTo = _this.elem('mailto');

    node.onsubmit = function (e) {
      e.preventDefault();

      _this.$mailTo.href = 'mailto:info@nszu.gov.ua?subject=\u0417\u0432\u043E\u0440\u043E\u0442\u043D\u0456\u0439 \u0437\u0432\u2019\u044F\u0437\u043E\u043A \u0432\u0456\u0434 ' + _this.$name.value + '&body=' + _this.$message.value;
      _this.$mailTo.click();
      return false;
    };
    return _this;
  }

  return Feedback;
}(_dom.BEM);

exports.default = Feedback;
module.exports = exports['default'];

},{"./dom":3}],5:[function(require,module,exports){
'use strict';

var _promisePolyfill = require('promise-polyfill');

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _smoothscrollPolyfill = require('smoothscroll-polyfill');

var _smoothscrollPolyfill2 = _interopRequireDefault(_smoothscrollPolyfill);

var _dom = require('./dom');

var _utils = require('./utils');

var _nav = require('./nav');

var _nav2 = _interopRequireDefault(_nav);

var _tabs = require('./tabs');

var _tabs2 = _interopRequireDefault(_tabs);

var _slider = require('./slider');

var _slider2 = _interopRequireDefault(_slider);

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _statistic = require('./statistic');

var _statistic2 = _interopRequireDefault(_statistic);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.Promise) {
  window.Promise = _promisePolyfill2.default;
}

_smoothscrollPolyfill2.default.polyfill();

(0, _dom.$)('.nav').forEach(function (node) {
  return new _nav2.default(node);
});
(0, _dom.$)('.tabs').forEach(function (node) {
  return new _tabs2.default(node);
});
(0, _dom.$)('.slider').forEach(function (node) {
  return new _slider2.default(node);
});
(0, _dom.$)('.feedback').forEach(function (node) {
  return new _feedback2.default(node);
});

(0, _utils.fetchJSON)('data/stats.json').then(function (data) {
  (0, _dom.$)('.map').forEach(function (node) {
    return new _map2.default(node, data.slice());
  });
  (0, _dom.$)('.declarations').forEach(function (node) {
    return new _statistic2.default(node, data);
  });
});

},{"./dom":3,"./feedback":4,"./map":6,"./nav":7,"./slider":8,"./statistic":9,"./tabs":10,"./utils":11,"promise-polyfill":1,"smoothscroll-polyfill":2}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require("./dom");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HOVER_DEBOUNCE_TIMEOUT = 200;

var REGION_POINT_MAP = {
  "Київ": { left: 453, top: 170 },
  "Луцьк": { left: 153, top: 100 },
  "Львов": { left: 83, top: 206 },
  "Ужгород": { left: 48, top: 312 },
  "Ивано-Франковск": { left: 153, top: 312 },
  "Черновцы": { left: 207, top: 329 },
  "Тернополь": { left: 188, top: 241 },
  "Ровно": { left: 241, top: 100 },
  "Хмельницкий": { left: 259, top: 206 },
  "Житомир": { left: 347, top: 153 },
  "Винница": { left: 365, top: 277 },
  "Черкассы": { left: 523, top: 241 },
  "Кировоград": { left: 541, top: 312 },
  "Полтава": { left: 646, top: 188 },
  "Чернигов": { left: 541, top: 65 },
  "Суммы": { left: 646, top: 100 },
  "Харьков": { left: 770, top: 205 },
  "Луганск": { left: 911, top: 259 },
  "Днепропетровск": { left: 682, top: 311 },
  "Донецк": { left: 840, top: 347 },
  "Запорожье": { left: 752, top: 417 },
  "Херсон": { left: 629, top: 452 },
  "Николаев": { left: 523, top: 399 },
  "Одесса": { left: 453, top: 435 },
  "Крым": { left: 664, top: 558 }
};

var createPoint = function createPoint(_ref) {
  var left = _ref.left,
      top = _ref.top;

  var node = document.createElement('div');

  node.classList.add('map__point');
  node.style.left = left + "px";
  node.style.top = top + "px";

  return node;
};

var Map = function (_BEM) {
  _inherits(Map, _BEM);

  function Map(node, data) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, 'map', node));

    _this.data = [];
    _this.timeout = null;


    _this.data = data;
    _this.$tooltip = _this.elem('tooltip');

    var fragment = document.createDocumentFragment();

    data.forEach(function (item, index) {
      var point = createPoint(REGION_POINT_MAP[item.region_name]);
      point.dataset.index = index;

      point.addEventListener('mouseover', _this, false);
      point.addEventListener('mouseout', _this, false);

      fragment.appendChild(point);
    });

    _this.$tooltip.addEventListener('mouseover', _this, false);
    _this.$tooltip.addEventListener('mouseout', _this, false);

    _this.elem('main').appendChild(fragment);
    return _this;
  }

  _createClass(Map, [{
    key: "handleEvent",
    value: function handleEvent(_ref2) {
      var _this2 = this;

      var target = _ref2.target,
          type = _ref2.type;

      if (type === 'mouseover' && target.dataset.index) {
        this.$tooltip.style.top = target.style.top;
        this.$tooltip.style.left = target.style.left;
      }

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        switch (type) {
          case 'mouseout':
            _this2.delMod(_this2.$tooltip, 'tooltip', 'show');
            _this2.delMod(_this2.$active, 'point', 'active');
            break;
          case 'mouseover':
            var data = _this2.data[target.dataset.index];

            if (data) {
              var $tooltipData = _this2.$tooltip.querySelectorAll((0, _dom.buildClass)('map', 'tooltip-data') + " dt");

              _this2.$tooltip.style.top = target.style.top;
              _this2.$tooltip.style.left = target.style.left;

              _this2.$active && _this2.delMod(_this2.$active, 'point', 'active');
              _this2.setMod(_this2.$tooltip, 'tooltip', 'show');

              _this2.$tooltip.querySelector((0, _dom.buildClass)('map', 'tooltip-title')).textContent = data.region_name;
              _this2.$active = target;

              $tooltipData[0].textContent = data.medical_system_providers;
              $tooltipData[1].textContent = data.doctors;
              $tooltipData[2].textContent = data.declarations_signed;

              _this2.setMod(_this2.$active, 'point', 'active');
            }

            _this2.setMod(_this2.$tooltip, 'tooltip', 'show');
            break;
        }
      }, HOVER_DEBOUNCE_TIMEOUT);
    }
  }]);

  return Map;
}(_dom.BEM);

exports.default = Map;
module.exports = exports["default"];

},{"./dom":3}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Nav = function Nav(node) {
  _classCallCheck(this, Nav);

  node.addEventListener('click', function (e) {
    e.preventDefault();

    if (e.target.href === undefined) {
      return;
    }

    var to = e.target.href.split('#')[1];

    var _document$getElementB = document.getElementById(to).getBoundingClientRect(),
        top = _document$getElementB.top;

    window.scroll({ top: top + window.scrollY - 50, left: 0, behavior: 'smooth' });
  });
};

exports.default = Nav;
module.exports = exports['default'];

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createMarker = function createMarker() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var node = document.createElement('li');

  node.classList.add((0, _dom.selector)('slider', 'marker'));
  active && node.classList.add((0, _dom.selector)('slider', 'marker', 'active'));

  return node;
};

var Slider = function (_BEM) {
  _inherits(Slider, _BEM);

  function Slider(node) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', node));

    _this.currentIndex = 0;

    _this.$slides = _this.elems('slide');

    _this.$markers = [];

    _this.$control = document.createElement('ul');
    _this.$control.classList.add((0, _dom.selector)(_this.name, 'markers'));

    _this.$slides.forEach(function (node, index) {
      var marker = createMarker(index === _this.currentIndex);
      _this.$control.appendChild(marker);
      _this.$markers.push(marker);
    });

    _this.$control.addEventListener('click', function (_ref) {
      var target = _ref.target;

      if (!target.closest((0, _dom.buildClass)(_this.name, 'marker'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('marker', 'active'), 'marker', 'active');
      _this.setMod(target, 'marker', 'active');

      _this.slide(toIndex);
    }, false);

    _this.node.appendChild(_this.$control);
    return _this;
  }

  _createClass(Slider, [{
    key: 'slide',
    value: function slide(index) {
      var isNext = this.currentIndex < index;

      this.$slides[this.currentIndex].animate([{ transform: 'translateX(0)' }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)' }], this.constructor.ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)' }, { transform: 'translateX(0)' }], this.constructor.ANIMATION_OPTIONS);

      this.currentIndex = index;
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$markers.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Slider;
}(_dom.BEM);

Slider.ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};
exports.default = Slider;
module.exports = exports['default'];

},{"./dom":3}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORS_MAP = ['#90c8e6', '#b097c6', '#dfb0d0', '#e3aab8', '#afd5e7', '#c7b2d5', '#e9c7df', '#ecc7cf', '#f1eec9', '#ced8e2', '#5da892', '#5296cd', '#a3d7f2', '#f3f1a0', '#bcdad5', '#71b7a8', '#5ca9dc', '#dc91a3', '#d8816f', '#e2a394', '#7566aa', '#cadfeb', '#ddd2df', '#f4d9b5', '#d381b2'];

var createListItemNode = function createListItemNode(title, value, color) {
  var $li = document.createElement('li');
  var $span = document.createElement('span');
  var $value = document.createElement('div');

  $li.classList.add((0, _dom.selector)('declarations', 'list-item'));
  $li.textContent = title;

  $span.style.backgroundColor = color;

  $value.classList.add((0, _dom.selector)('declarations', 'list-item-value'));
  $value.textContent = (0, _utils.numberFormatting)(value);

  $li.prepend($span);
  $li.append($value);

  return $li;
};

var Statistic = function (_BEM) {
  _inherits(Statistic, _BEM);

  function Statistic(node, data) {
    _classCallCheck(this, Statistic);

    var _this = _possibleConstructorReturn(this, (Statistic.__proto__ || Object.getPrototypeOf(Statistic)).call(this, 'declarations', node));

    var fragment = document.createDocumentFragment();

    _this.$canvas = _this.elem('graph-canvas');
    _this.context = _this.$canvas.getContext('2d');

    var total = data.reduce(function (target, _ref) {
      var declarations = _ref.declarations;
      return target + declarations;
    }, 0);

    data.sort(function (a, b) {
      return a.declarations < b.declarations ? 1 : -1;
    });

    var x = 490,
        y = 490,
        r = 480,
        s = 0;


    data.forEach(function (item, index) {
      var $item = createListItemNode(item.region_name, item.declarations, COLORS_MAP[index]);

      fragment.appendChild($item);

      var radians = item.declarations / data[0].declarations * 360 * (Math.PI / 360);

      _this.context.beginPath();
      _this.context.lineWidth = 6;
      _this.context.strokeStyle = COLORS_MAP[index];
      _this.context.arc(x, y, r - 20 * index, s, radians, false);
      _this.context.stroke();
    });

    _this.elem('list').appendChild(fragment);
    _this.elem('total-value').textContent = (0, _utils.numberFormatting)(total);
    return _this;
  }

  return Statistic;
}(_dom.BEM);

exports.default = Statistic;
module.exports = exports['default'];

},{"./dom":3,"./utils":11}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PANEL_ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};

var Tabs = function (_BEM) {
  _inherits(Tabs, _BEM);

  function Tabs(node) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoHeight = _ref.autoHeight,
        autoHeight = _ref$autoHeight === undefined ? false : _ref$autoHeight;

    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, 'tabs', node));

    _this.$controls = _this.elems('nav-item');
    _this.$slides = _this.elems('slide');

    _this.$marker = document.createElement('div');
    _this.$marker.classList.add((0, _dom.selector)(_this.name, 'marker'));
    _this.elem('header').appendChild(_this.$marker);

    if (autoHeight) {
      var maxHeight = _this.$slides.reduce(function (target, item) {
        if (item.clientHeight > target) {
          target = item.clientHeight;
        }

        return target;
      }, 0);

      _this.elem('main').style.height = maxHeight + 'px';
    }

    _this.currentIndex = _this.getIndexByElem(_this.elem('nav-item', 'active'));

    _this.elem('nav').addEventListener('click', function (e) {
      if (!e.target.closest((0, _dom.buildClass)(_this.name, 'nav-item'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(e.target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('nav-item', 'active'), 'nav-item', 'active');
      _this.setMod(e.target, 'nav-item', 'active');

      _this.animatePanels(toIndex);
      _this.animateMarker(toIndex);

      _this.currentIndex = toIndex;
    }, false);

    _this.setMod(_this.elem('nav-item', 'active'), 'nav-item', 'marker');
    return _this;
  }

  _createClass(Tabs, [{
    key: 'animatePanels',
    value: function animatePanels(index) {
      var current = this.currentIndex;
      var isNext = current < index;

      current !== undefined && this.$slides[current].animate([{ transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)', opacity: 0 }], PANEL_ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)', opacity: 0 }, { transform: 'translateX(0)', opacity: 1 }], PANEL_ANIMATION_OPTIONS);
    }
  }, {
    key: 'animateMarker',
    value: function animateMarker(index) {
      var _this2 = this;

      var current = {
        left: this.$controls[this.currentIndex].offsetLeft,
        width: this.$controls[this.currentIndex].clientWidth
      };

      var left = this.$controls[index].offsetLeft;
      var width = this.$controls[index].clientWidth;

      var player = this.$marker.animate([{
        transform: 'translateX(' + current.left + 'px)',
        width: current.width + 'px'
      }, {
        transform: 'translateX(' + left + 'px)',
        width: width + 'px'
      }], _extends({}, PANEL_ANIMATION_OPTIONS, { fill: 'none' }));

      player.onfinish = function () {
        _this2.setMod(_this2.$controls[index], 'nav-item', 'marker');
      };

      this.delMod(this.$controls[this.currentIndex], 'nav-item', 'marker');
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$controls.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Tabs;
}(_dom.BEM);

exports.default = Tabs;
module.exports = exports['default'];

},{"./dom":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var objectToQuery = function objectToQuery(target) {
  return '?' + Object.keys(target).reduce(function (arr, key) {
    return arr.push(key + '=' + target[key]) && arr;
  }, []).join('&');
};

var numberFormatting = exports.numberFormatting = function numberFormatting(number) {
  return number.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1 ').split('.')[0];
};

var fetchJSON = exports.fetchJSON = function fetchJSON(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { method: 'GET' };
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();

    if (options.body && options.method === 'GET') {
      url += objectToQuery(options.body);
    }

    request.onreadystatechange = function () {
      if (request.readyState !== 4) {
        return;
      }

      resolve(JSON.parse(request.responseText));
    };

    request.onerror = reject;
    request.open(options.method || 'GET', url);
    request.send(options.body ? JSON.stringify(options.body) : null);
  });
};

},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcyIsInNyYy9zY3JpcHRzL2RvbS5qcyIsInNyYy9zY3JpcHRzL2ZlZWRiYWNrLmpzIiwic3JjL3NjcmlwdHMvbWFpbi5qcyIsInNyYy9zY3JpcHRzL21hcC5qcyIsInNyYy9zY3JpcHRzL25hdi5qcyIsInNyYy9zY3JpcHRzL3NsaWRlci5qcyIsInNyYy9zY3JpcHRzL3N0YXRpc3RpYy5qcyIsInNyYy9zY3JpcHRzL3RhYnMuanMiLCJzcmMvc2NyaXB0cy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UUFBUSxZQUFuQixDQUFSO0FBQ0QsS0FORDs7QUFRQSxZQUFRLE9BQVIsR0FBa0IsTUFBbEI7QUFDQSxZQUFRLElBQVIsQ0FBYSxRQUFRLE1BQVIsSUFBa0IsS0FBL0IsRUFBc0MsR0FBdEM7QUFDQSxZQUFRLElBQVIsQ0FBYSxRQUFRLElBQVIsR0FBZSxLQUFLLFNBQUwsQ0FBZSxRQUFRLElBQXZCLENBQWYsR0FBOEMsSUFBM0Q7QUFDRCxHQWxCOEQsQ0FBdEM7QUFBQSxDQUFsQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgXG4gIC8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gICAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gICAgfVxuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAoc2VsZi5fc3RhdGUgPT09IDEgPyByZXNvbHZlIDogcmVqZWN0KShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl92YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZXQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgc2VsZi5fc3RhdGUgPSAzO1xuICAgICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLl9zdGF0ZSA9IDE7XG4gICAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChzZWxmLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgICBzZWxmLl9zdGF0ZSA9IDI7XG4gICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICBmaW5hbGUoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBoYW5kbGUoc2VsZiwgc2VsZi5fZGVmZXJyZWRzW2ldKTtcbiAgICB9XG4gICAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICAgKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAgICpcbiAgICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICAgKi9cbiAgZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBzZWxmKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHJlamVjdChzZWxmLCBleCk7XG4gICAgfVxuICB9XG5cbiAgUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBwcm9tID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShub29wKTtcblxuICAgIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbSkpO1xuICAgIHJldHVybiBwcm9tO1xuICB9O1xuXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3QodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uIChmbikgeyBzZXRJbW1lZGlhdGUoZm4pOyB9KSB8fFxuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICAgIH07XG5cbiAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfdW5oYW5kbGVkUmVqZWN0aW9uRm4oZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1tZWRpYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAqIEBwYXJhbSBmbiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldEltbWVkaWF0ZUZuID0gZnVuY3Rpb24gX3NldEltbWVkaWF0ZUZuKGZuKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSBmbjtcbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF9zZXRVbmhhbmRsZWRSZWplY3Rpb25Gbihmbikge1xuICAgIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZm47XG4gIH07XG4gIFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4gIH0gZWxzZSBpZiAoIXJvb3QuUHJvbWlzZSkge1xuICAgIHJvb3QuUHJvbWlzZSA9IFByb21pc2U7XG4gIH1cblxufSkodGhpcyk7XG4iLCIvKlxuICogc21vb3Roc2Nyb2xsIHBvbHlmaWxsIC0gdjAuMy41XG4gKiBodHRwczovL2lhbWR1c3Rhbi5naXRodWIuaW8vc21vb3Roc2Nyb2xsXG4gKiAyMDE2IChjKSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24odywgZCwgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKlxuICAgKiBhbGlhc2VzXG4gICAqIHc6IHdpbmRvdyBnbG9iYWwgb2JqZWN0XG4gICAqIGQ6IGRvY3VtZW50XG4gICAqIHVuZGVmaW5lZDogdW5kZWZpbmVkXG4gICAqL1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIHJldHVybiB3aGVuIHNjcm9sbEJlaGF2aW9yIGludGVyZmFjZSBpcyBzdXBwb3J0ZWRcbiAgICBpZiAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkLmRvY3VtZW50RWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogZ2xvYmFsc1xuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLypcbiAgICAgKiBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgICAqL1xuICAgIHZhciBub3cgPSB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XG4gICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGVhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHNtb290aCBiZWhhdmlvciBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqIEBtZXRob2Qgc2hvdWxkQmFpbE91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0geFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoeCkge1xuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgfHwgeCA9PT0gbnVsbFxuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSAnYXV0bydcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdpbnN0YW50Jykge1xuICAgICAgICAvLyBmaXJzdCBhcmcgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnXG4gICAgICAgICAgICAmJiB4LmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QgYW5kIGJlaGF2aW9yIGlzIHNtb290aFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yIHdoZW4gYmVoYXZpb3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmVoYXZpb3Igbm90IHZhbGlkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHZhciBpc0JvZHk7XG4gICAgICB2YXIgaGFzU2Nyb2xsYWJsZVNwYWNlO1xuICAgICAgdmFyIGhhc1Zpc2libGVPdmVyZmxvdztcblxuICAgICAgZG8ge1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgLy8gc2V0IGNvbmRpdGlvbiB2YXJpYWJsZXNcbiAgICAgICAgaXNCb2R5ID0gZWwgPT09IGQuYm9keTtcbiAgICAgICAgaGFzU2Nyb2xsYWJsZVNwYWNlID1cbiAgICAgICAgICBlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHQgfHxcbiAgICAgICAgICBlbC5jbGllbnRXaWR0aCA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgICBoYXNWaXNpYmxlT3ZlcmZsb3cgPVxuICAgICAgICAgIHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkub3ZlcmZsb3cgPT09ICd2aXNpYmxlJztcbiAgICAgIH0gd2hpbGUgKCFpc0JvZHkgJiYgIShoYXNTY3JvbGxhYmxlU3BhY2UgJiYgIWhhc1Zpc2libGVPdmVyZmxvdykpO1xuXG4gICAgICBpc0JvZHkgPSBoYXNTY3JvbGxhYmxlU3BhY2UgPSBoYXNWaXNpYmxlT3ZlcmZsb3cgPSBudWxsO1xuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WTtcbiAgICAgIHZhciBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBTQ1JPTExfVElNRTtcblxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXG4gICAgICB2YWx1ZSA9IGVhc2UoZWxhcHNlZCk7XG5cbiAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgICBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcblxuICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgIGlmIChjdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcbiAgICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcC5iaW5kKHcsIGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxzIHdpbmRvdyB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgICAqL1xuXG4gICAgLy8gdy5zY3JvbGwgYW5kIHcuc2Nyb2xsVG9cbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHcuc2Nyb2xsQnlcbiAgICB3LnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgKHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0KSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0udG9wICsgKHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIGFuZCBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCA9IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgfHwgYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCB8fCBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZzAgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICAgIGxlZnQ6IGFyZzAubGVmdCArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFyZzAudG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgYmVoYXZpb3I6IGFyZzAuYmVoYXZpb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbChcbiAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgKyBhcmcwLFxuICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wICsgYXJndW1lbnRzWzFdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsSW50b1ZpZXcuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0gfHwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgdmFyIHNjcm9sbGFibGVQYXJlbnQgPSBmaW5kU2Nyb2xsYWJsZVBhcmVudCh0aGlzKTtcbiAgICAgIHZhciBwYXJlbnRSZWN0cyA9IHNjcm9sbGFibGVQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY2xpZW50UmVjdHMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoc2Nyb2xsYWJsZVBhcmVudCAhPT0gZC5ib2R5KSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluc2lkZSBwYXJlbnRcbiAgICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsTGVmdCArIGNsaWVudFJlY3RzLmxlZnQgLSBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wICsgY2xpZW50UmVjdHMudG9wIC0gcGFyZW50UmVjdHMudG9wXG4gICAgICAgICk7XG4gICAgICAgIC8vIHJldmVhbCBwYXJlbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IHBhcmVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogY2xpZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIGNvbW1vbmpzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IHBvbHlmaWxsOiBwb2x5ZmlsbCB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGdsb2JhbFxuICAgIHBvbHlmaWxsKCk7XG4gIH1cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuIiwiZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBhcnJheUxpa2UgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheUxpa2UpKSB7XG4gICAgcmV0dXJuIGFycmF5TGlrZTtcbiAgfVxuXG4gIGlmIChhcnJheUxpa2UgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59O1xuXG5leHBvcnQgY29uc3QgJCA9IChzZWxlY3RvciwgY29udGV4dCA9IGRvY3VtZW50KSA9PiAoXG4gIHRvQXJyYXkoY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoY29udGV4dCwgc2VsZWN0b3IpKVxuKTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdG9yID0gKGJsb2NrLCBlbGVtLCBtb2ROYW1lLCBtb2RWYWwpID0+IChcbiAgYCR7YmxvY2t9X18ke2VsZW19JHttb2ROYW1lID8gKG1vZFZhbCA/IGBfJHttb2ROYW1lfV8ke21vZFZhbH1gIDogYF8ke21vZE5hbWV9YCkgOiAnJ31gXG4pO1xuXG5leHBvcnQgY29uc3QgYnVpbGRDbGFzcyA9ICguLi5hcmdzKSA9PiBgLiR7c2VsZWN0b3IoLi4uYXJncyl9YDtcblxuZXhwb3J0IGNsYXNzIEJFTSBleHRlbmRzIG51bGwge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBub2RlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBlbGVtKG5hbWUsIG1vZE5hbWUsIG1vZFZhbCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihidWlsZENsYXNzKHRoaXMubmFtZSwgbmFtZSwgbW9kTmFtZSwgbW9kVmFsKSk7XG4gIH1cblxuICBlbGVtcyhuYW1lLCBtb2ROYW1lLCBtb2RWYWwpIHtcbiAgICByZXR1cm4gJChidWlsZENsYXNzKHRoaXMubmFtZSwgbmFtZSwgbW9kTmFtZSwgbW9kVmFsKSwgdGhpcy5ub2RlKTtcbiAgfVxuXG4gIHNldE1vZChlbGVtLCBlbGVtTmFtZSwgbW9kTmFtZSwgbW9kVmFsdWUpIHtcbiAgICB0b0FycmF5KGVsZW0pLmZvckVhY2gobm9kZSA9PiAoXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IodGhpcy5uYW1lLCBlbGVtTmFtZSwgbW9kTmFtZSwgbW9kVmFsdWUpKVxuICAgICkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxNb2QoZWxlbSwgZWxlbU5hbWUsIG1vZE5hbWUpIHtcbiAgICB0b0FycmF5KGVsZW0pLmZvckVhY2gobm9kZSA9PiAoXG4gICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoc2VsZWN0b3IodGhpcy5uYW1lLCBlbGVtTmFtZSwgbW9kTmFtZSkpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSIsImltcG9ydCB7IEJFTSB9IGZyb20gJy4vZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmVlZGJhY2sgZXh0ZW5kcyBCRU0ge1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgc3VwZXIoJ2ZlZWRiYWNrJywgbm9kZSk7XG5cbiAgICB0aGlzLiRuYW1lID0gdGhpcy5lbGVtKCduYW1lJyk7XG4gICAgdGhpcy4kbWVzc2FnZSA9IHRoaXMuZWxlbSgnbWVzc2FnZScpO1xuICAgIHRoaXMuJG1haWxUbyA9IHRoaXMuZWxlbSgnbWFpbHRvJyk7XG5cbiAgICBub2RlLm9uc3VibWl0ID0gKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy4kbWFpbFRvLmhyZWYgPSBgbWFpbHRvOmluZm9AbnN6dS5nb3YudWE/c3ViamVjdD3Ql9Cy0L7RgNC+0YLQvdGW0Lkg0LfQsuKAmdGP0LfQvtC6INCy0ZbQtCAke3RoaXMuJG5hbWUudmFsdWV9JmJvZHk9JHt0aGlzLiRtZXNzYWdlLnZhbHVlfWA7XG4gICAgICB0aGlzLiRtYWlsVG8uY2xpY2soKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgUHJvbWlzZSBmcm9tICdwcm9taXNlLXBvbHlmaWxsJztcbmltcG9ydCBTbW9vdGhTY3JvbGwgZnJvbSAnc21vb3Roc2Nyb2xsLXBvbHlmaWxsJztcblxuaW1wb3J0IHsgJCB9IGZyb20gJy4vZG9tJztcbmltcG9ydCB7IGZldGNoSlNPTiB9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQgTmF2IGZyb20gJy4vbmF2JztcbmltcG9ydCBUYWJzIGZyb20gJy4vdGFicyc7XG5pbXBvcnQgU2xpZGVyIGZyb20gJy4vc2xpZGVyJztcbmltcG9ydCBNYXAgZnJvbSAnLi9tYXAnO1xuaW1wb3J0IFN0YXRpc3RpYyBmcm9tICcuL3N0YXRpc3RpYyc7XG5pbXBvcnQgRmVlZGJhY2sgZnJvbSAnLi9mZWVkYmFjayc7XG5cbmlmICghd2luZG93LlByb21pc2UpIHtcbiAgd2luZG93LlByb21pc2UgPSBQcm9taXNlO1xufVxuXG5TbW9vdGhTY3JvbGwucG9seWZpbGwoKTtcblxuJCgnLm5hdicpLmZvckVhY2gobm9kZSA9PiBuZXcgTmF2KG5vZGUpKTtcbiQoJy50YWJzJykuZm9yRWFjaChub2RlID0+IG5ldyBUYWJzKG5vZGUpKTtcbiQoJy5zbGlkZXInKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFNsaWRlcihub2RlKSk7XG4kKCcuZmVlZGJhY2snKS5mb3JFYWNoKG5vZGUgPT4gbmV3IEZlZWRiYWNrKG5vZGUpKTtcblxuZmV0Y2hKU09OKCdkYXRhL3N0YXRzLmpzb24nKS50aGVuKGRhdGEgPT4ge1xuICAkKCcubWFwJykuZm9yRWFjaChub2RlID0+IG5ldyBNYXAobm9kZSwgZGF0YS5zbGljZSgpKSk7XG4gICQoJy5kZWNsYXJhdGlvbnMnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFN0YXRpc3RpYyhub2RlLCBkYXRhKSk7XG59KTtcbiIsImltcG9ydCB7IEJFTSwgYnVpbGRDbGFzcyB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgSE9WRVJfREVCT1VOQ0VfVElNRU9VVCA9IDIwMDtcblxuY29uc3QgUkVHSU9OX1BPSU5UX01BUCA9IHtcbiAgXCLQmtC40ZfQslwiOiB7IGxlZnQ6IDQ1MywgdG9wOiAxNzAgfSxcbiAgXCLQm9GD0YbRjNC6XCI6IHsgbGVmdDogMTUzLCB0b3A6IDEwMCB9LFxuICBcItCb0YzQstC+0LJcIjogeyBsZWZ0OiA4MywgdG9wOiAyMDYgfSxcbiAgXCLQo9C20LPQvtGA0L7QtFwiOiB7IGxlZnQ6IDQ4LCB0b3A6IDMxMiB9LFxuICBcItCY0LLQsNC90L4t0KTRgNCw0L3QutC+0LLRgdC6XCI6IHsgbGVmdDogMTUzLCB0b3A6IDMxMiB9LFxuICBcItCn0LXRgNC90L7QstGG0YtcIjogeyBsZWZ0OiAyMDcsIHRvcDogMzI5IH0sXG4gIFwi0KLQtdGA0L3QvtC/0L7Qu9GMXCI6IHsgbGVmdDogMTg4LCB0b3A6IDI0MSB9LFxuICBcItCg0L7QstC90L5cIjogeyBsZWZ0OiAyNDEsIHRvcDogMTAwIH0sXG4gIFwi0KXQvNC10LvRjNC90LjRhtC60LjQuVwiOiB7IGxlZnQ6IDI1OSwgdG9wOiAyMDYgfSxcbiAgXCLQltC40YLQvtC80LjRgFwiOiB7IGxlZnQ6IDM0NywgdG9wOiAxNTMgfSxcbiAgXCLQktC40L3QvdC40YbQsFwiOiB7IGxlZnQ6IDM2NSwgdG9wOiAyNzcgfSxcbiAgXCLQp9C10YDQutCw0YHRgdGLXCI6IHsgbGVmdDogNTIzLCB0b3A6IDI0MSB9LFxuICBcItCa0LjRgNC+0LLQvtCz0YDQsNC0XCI6IHsgbGVmdDogNTQxLCB0b3A6IDMxMiB9LFxuICBcItCf0L7Qu9GC0LDQstCwXCI6IHsgbGVmdDogNjQ2LCB0b3A6IDE4OCB9LFxuICBcItCn0LXRgNC90LjQs9C+0LJcIjogeyBsZWZ0OiA1NDEsIHRvcDogNjUgfSxcbiAgXCLQodGD0LzQvNGLXCI6IHsgbGVmdDogNjQ2LCB0b3A6IDEwMCB9LFxuICBcItCl0LDRgNGM0LrQvtCyXCI6IHsgbGVmdDogNzcwLCB0b3A6IDIwNSB9LFxuICBcItCb0YPQs9Cw0L3RgdC6XCI6IHsgbGVmdDogOTExLCB0b3A6IDI1OSB9LFxuICBcItCU0L3QtdC/0YDQvtC/0LXRgtGA0L7QstGB0LpcIjogeyBsZWZ0OiA2ODIsIHRvcDogMzExIH0sXG4gIFwi0JTQvtC90LXRhtC6XCI6IHsgbGVmdDogODQwLCB0b3A6IDM0NyB9LFxuICBcItCX0LDQv9C+0YDQvtC20YzQtVwiOiB7IGxlZnQ6IDc1MiwgdG9wOiA0MTcgfSxcbiAgXCLQpdC10YDRgdC+0L1cIjogeyBsZWZ0OiA2MjksIHRvcDogNDUyIH0sXG4gIFwi0J3QuNC60L7Qu9Cw0LXQslwiOiB7IGxlZnQ6IDUyMywgdG9wOiAzOTkgfSxcbiAgXCLQntC00LXRgdGB0LBcIjogeyBsZWZ0OiA0NTMsIHRvcDogNDM1IH0sXG4gIFwi0JrRgNGL0LxcIjogeyBsZWZ0OiA2NjQsIHRvcDogNTU4IH1cbn07XG5cbmNvbnN0IGNyZWF0ZVBvaW50ID0gKHsgbGVmdCwgdG9wIH0pID0+IHtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnbWFwX19wb2ludCcpO1xuICBub2RlLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgbm9kZS5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwIGV4dGVuZHMgQkVNIHtcbiAgZGF0YSA9IFtdO1xuICB0aW1lb3V0ID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihub2RlLCBkYXRhKSB7XG4gICAgc3VwZXIoJ21hcCcsIG5vZGUpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLiR0b29sdGlwID0gdGhpcy5lbGVtKCd0b29sdGlwJyk7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlUG9pbnQoUkVHSU9OX1BPSU5UX01BUFtpdGVtLnJlZ2lvbl9uYW1lXSk7XG4gICAgICBwb2ludC5kYXRhc2V0LmluZGV4ID0gaW5kZXg7XG5cbiAgICAgIHBvaW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMsIGZhbHNlKTtcbiAgICAgIHBvaW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcywgZmFsc2UpO1xuXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChwb2ludCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiR0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLiR0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcywgZmFsc2UpO1xuXG4gICAgdGhpcy5lbGVtKCdtYWluJykuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoeyB0YXJnZXQsIHR5cGUgfSkge1xuICAgIGlmICh0eXBlID09PSAnbW91c2VvdmVyJyAmJiB0YXJnZXQuZGF0YXNldC5pbmRleCkge1xuICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS50b3AgPSB0YXJnZXQuc3R5bGUudG9wO1xuICAgICAgdGhpcy4kdG9vbHRpcC5zdHlsZS5sZWZ0ID0gdGFyZ2V0LnN0eWxlLmxlZnQ7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICAgIHRoaXMuZGVsTW9kKHRoaXMuJHRvb2x0aXAsICd0b29sdGlwJywgJ3Nob3cnKTtcbiAgICAgICAgICB0aGlzLmRlbE1vZCh0aGlzLiRhY3RpdmUsICdwb2ludCcsICdhY3RpdmUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhW3RhcmdldC5kYXRhc2V0LmluZGV4XTtcblxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCAkdG9vbHRpcERhdGEgPSB0aGlzLiR0b29sdGlwLnF1ZXJ5U2VsZWN0b3JBbGwoYCR7YnVpbGRDbGFzcygnbWFwJywgJ3Rvb2x0aXAtZGF0YScpfSBkdGApO1xuXG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLnRvcCA9IHRhcmdldC5zdHlsZS50b3A7XG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLmxlZnQgPSB0YXJnZXQuc3R5bGUubGVmdDtcblxuICAgICAgICAgICAgdGhpcy4kYWN0aXZlICYmIHRoaXMuZGVsTW9kKHRoaXMuJGFjdGl2ZSwgJ3BvaW50JywgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuXG4gICAgICAgICAgICB0aGlzLiR0b29sdGlwLnF1ZXJ5U2VsZWN0b3IoYnVpbGRDbGFzcygnbWFwJywgJ3Rvb2x0aXAtdGl0bGUnKSkudGV4dENvbnRlbnQgPSBkYXRhLnJlZ2lvbl9uYW1lO1xuICAgICAgICAgICAgdGhpcy4kYWN0aXZlID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAkdG9vbHRpcERhdGFbMF0udGV4dENvbnRlbnQgPSBkYXRhLm1lZGljYWxfc3lzdGVtX3Byb3ZpZGVycztcbiAgICAgICAgICAgICR0b29sdGlwRGF0YVsxXS50ZXh0Q29udGVudCA9IGRhdGEuZG9jdG9ycztcbiAgICAgICAgICAgICR0b29sdGlwRGF0YVsyXS50ZXh0Q29udGVudCA9IGRhdGEuZGVjbGFyYXRpb25zX3NpZ25lZDtcblxuICAgICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kYWN0aXZlLCAncG9pbnQnLCAnYWN0aXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXRNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIEhPVkVSX0RFQk9VTkNFX1RJTUVPVVQpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2IHtcbiAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGUudGFyZ2V0LmhyZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvID0gZS50YXJnZXQuaHJlZi5zcGxpdCgnIycpWzFdO1xuICAgICAgY29uc3QgeyB0b3AgfSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRvKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgd2luZG93LnNjcm9sbCh7IHRvcDogKHRvcCArIHdpbmRvdy5zY3JvbGxZKSAtIDUwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfSlcbiAgfVxufSIsImltcG9ydCB7IEJFTSwgYnVpbGRDbGFzcywgc2VsZWN0b3IgfSBmcm9tICcuL2RvbSc7XG5cbmNvbnN0IGNyZWF0ZU1hcmtlciA9IChhY3RpdmUgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ3NsaWRlcicsICdtYXJrZXInKSk7XG4gIGFjdGl2ZSAmJiBub2RlLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ3NsaWRlcicsICdtYXJrZXInLCAnYWN0aXZlJykpO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgQkVNIHtcbiAgY3VycmVudEluZGV4ID0gMDtcblxuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgc3VwZXIoJ3NsaWRlcicsIG5vZGUpO1xuICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuZWxlbXMoJ3NsaWRlJyk7XG5cbiAgICB0aGlzLiRtYXJrZXJzID0gW107XG5cbiAgICB0aGlzLiRjb250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICB0aGlzLiRjb250cm9sLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IodGhpcy5uYW1lLCAnbWFya2VycycpKTtcblxuICAgIHRoaXMuJHNsaWRlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbWFya2VyID0gY3JlYXRlTWFya2VyKGluZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLiRjb250cm9sLmFwcGVuZENoaWxkKG1hcmtlcik7XG4gICAgICB0aGlzLiRtYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJGNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgaWYgKCF0YXJnZXQuY2xvc2VzdChidWlsZENsYXNzKHRoaXMubmFtZSwgJ21hcmtlcicpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvSW5kZXggPSB0aGlzLmdldEluZGV4QnlFbGVtKHRhcmdldCk7XG5cbiAgICAgIGlmICh0b0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsTW9kKHRoaXMuZWxlbSgnbWFya2VyJywgJ2FjdGl2ZScpLCAnbWFya2VyJywgJ2FjdGl2ZScpO1xuICAgICAgdGhpcy5zZXRNb2QodGFyZ2V0LCAnbWFya2VyJywgJ2FjdGl2ZScpO1xuXG4gICAgICB0aGlzLnNsaWRlKHRvSW5kZXgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLiRjb250cm9sKTtcbiAgfVxuXG4gIHNsaWRlKGluZGV4KSB7XG4gICAgY29uc3QgaXNOZXh0ID0gdGhpcy5jdXJyZW50SW5kZXggPCBpbmRleDtcblxuICAgIHRoaXMuJHNsaWRlc1t0aGlzLmN1cnJlbnRJbmRleF0uYW5pbWF0ZShbXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH0sXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtpc05leHQgPyAnLScgOiAnJ30xMDAlKWAgfVxuICAgIF0sIHRoaXMuY29uc3RydWN0b3IuQU5JTUFUSU9OX09QVElPTlMpO1xuXG4gICAgdGhpcy4kc2xpZGVzW2luZGV4XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICcnIDogJy0nfTEwMCUpYCB9LFxuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJyB9XG4gICAgXSwgdGhpcy5jb25zdHJ1Y3Rvci5BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgZ2V0SW5kZXhCeUVsZW0oZWxlbSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgdGhpcy4kbWFya2Vycy5zb21lKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgc3RhdGljIEFOSU1BVElPTl9PUFRJT05TID0ge1xuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgZmlsbDogJ2ZvcndhcmRzJyxcbiAgICBlYXNpbmc6ICdlYXNlLWluLW91dCdcbiAgfVxufSIsImltcG9ydCB7IEJFTSwgc2VsZWN0b3IgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgeyBudW1iZXJGb3JtYXR0aW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IENPTE9SU19NQVAgPSBbXG4gICcjOTBjOGU2JywgJyNiMDk3YzYnLCAnI2RmYjBkMCcsXG4gICcjZTNhYWI4JywgJyNhZmQ1ZTcnLCAnI2M3YjJkNScsXG4gICcjZTljN2RmJywgJyNlY2M3Y2YnLCAnI2YxZWVjOScsXG4gICcjY2VkOGUyJywgJyM1ZGE4OTInLCAnIzUyOTZjZCcsXG4gICcjYTNkN2YyJywgJyNmM2YxYTAnLCAnI2JjZGFkNScsXG4gICcjNzFiN2E4JywgJyM1Y2E5ZGMnLCAnI2RjOTFhMycsXG4gICcjZDg4MTZmJywgJyNlMmEzOTQnLCAnIzc1NjZhYScsXG4gICcjY2FkZmViJywgJyNkZGQyZGYnLCAnI2Y0ZDliNScsXG4gICcjZDM4MWIyJ1xuXTtcblxuY29uc3QgY3JlYXRlTGlzdEl0ZW1Ob2RlID0gKHRpdGxlLCB2YWx1ZSwgY29sb3IpID0+IHtcbiAgY29uc3QgJGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgY29uc3QgJHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGNvbnN0ICR2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICRsaS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKCdkZWNsYXJhdGlvbnMnLCAnbGlzdC1pdGVtJykpO1xuICAkbGkudGV4dENvbnRlbnQgPSB0aXRsZTtcblxuICAkc3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblxuICAkdmFsdWUuY2xhc3NMaXN0LmFkZChzZWxlY3RvcignZGVjbGFyYXRpb25zJywgJ2xpc3QtaXRlbS12YWx1ZScpKTtcbiAgJHZhbHVlLnRleHRDb250ZW50ID0gbnVtYmVyRm9ybWF0dGluZyh2YWx1ZSk7XG5cbiAgJGxpLnByZXBlbmQoJHNwYW4pO1xuICAkbGkuYXBwZW5kKCR2YWx1ZSk7XG5cbiAgcmV0dXJuICRsaTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpc3RpYyBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGRhdGEpIHtcbiAgICBzdXBlcignZGVjbGFyYXRpb25zJywgbm9kZSk7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIHRoaXMuJGNhbnZhcyA9IHRoaXMuZWxlbSgnZ3JhcGgtY2FudmFzJyk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy4kY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBjb25zdCB0b3RhbCA9IGRhdGEucmVkdWNlKCh0YXJnZXQsIHsgZGVjbGFyYXRpb25zIH0pID0+IHRhcmdldCArIGRlY2xhcmF0aW9ucywgMCk7XG5cbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IGEuZGVjbGFyYXRpb25zIDwgYi5kZWNsYXJhdGlvbnMgPyAxIDogLTEpO1xuXG4gICAgbGV0IFt4LCB5LCByLCBzXSA9IFs0OTAsIDQ5MCwgNDgwLCAwXTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0ICRpdGVtID0gY3JlYXRlTGlzdEl0ZW1Ob2RlKFxuICAgICAgICBpdGVtLnJlZ2lvbl9uYW1lLFxuICAgICAgICBpdGVtLmRlY2xhcmF0aW9ucyxcbiAgICAgICAgQ09MT1JTX01BUFtpbmRleF1cbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCRpdGVtKTtcblxuICAgICAgbGV0IHJhZGlhbnMgPSAoKGl0ZW0uZGVjbGFyYXRpb25zIC8gZGF0YVswXS5kZWNsYXJhdGlvbnMpICogMzYwKSAqIChNYXRoLlBJIC8gMzYwKTtcblxuICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDY7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBDT0xPUlNfTUFQW2luZGV4XTtcbiAgICAgIHRoaXMuY29udGV4dC5hcmMoeCwgeSwgciAtICgyMCAqIGluZGV4KSwgcywgcmFkaWFucywgZmFsc2UpO1xuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbGVtKCdsaXN0JykuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIHRoaXMuZWxlbSgndG90YWwtdmFsdWUnKS50ZXh0Q29udGVudCA9IG51bWJlckZvcm1hdHRpbmcodG90YWwpO1xuICB9XG59IiwiaW1wb3J0IHsgJCwgQkVNLCBidWlsZENsYXNzLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgUEFORUxfQU5JTUFUSU9OX09QVElPTlMgPSB7XG4gIGR1cmF0aW9uOiAzMDAsXG4gIGZpbGw6ICdmb3J3YXJkcycsXG4gIGVhc2luZzogJ2Vhc2UtaW4tb3V0J1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIHsgYXV0b0hlaWdodCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKCd0YWJzJywgbm9kZSk7XG5cbiAgICB0aGlzLiRjb250cm9scyA9IHRoaXMuZWxlbXMoJ25hdi1pdGVtJyk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy5lbGVtcygnc2xpZGUnKTtcblxuICAgIHRoaXMuJG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuJG1hcmtlci5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKHRoaXMubmFtZSwgJ21hcmtlcicpKTtcbiAgICB0aGlzLmVsZW0oJ2hlYWRlcicpLmFwcGVuZENoaWxkKHRoaXMuJG1hcmtlcik7XG5cbiAgICBpZiAoYXV0b0hlaWdodCkge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy4kc2xpZGVzLnJlZHVjZSgodGFyZ2V0LCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmNsaWVudEhlaWdodCA+IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGl0ZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0sIDApO1xuXG4gICAgICB0aGlzLmVsZW0oJ21haW4nKS5zdHlsZS5oZWlnaHQgPSBgJHttYXhIZWlnaHR9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbSh0aGlzLmVsZW0oJ25hdi1pdGVtJywgJ2FjdGl2ZScpKTtcblxuICAgIHRoaXMuZWxlbSgnbmF2JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKCFlLnRhcmdldC5jbG9zZXN0KGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCAnbmF2LWl0ZW0nKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b0luZGV4ID0gdGhpcy5nZXRJbmRleEJ5RWxlbShlLnRhcmdldCk7XG5cbiAgICAgIGlmICh0b0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsTW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdhY3RpdmUnKTtcbiAgICAgIHRoaXMuc2V0TW9kKGUudGFyZ2V0LCAnbmF2LWl0ZW0nLCAnYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuYW5pbWF0ZVBhbmVscyh0b0luZGV4KTtcbiAgICAgIHRoaXMuYW5pbWF0ZU1hcmtlcih0b0luZGV4KTtcblxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB0b0luZGV4O1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRoaXMuc2V0TW9kKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJyksICduYXYtaXRlbScsICdtYXJrZXInKTtcbiAgfVxuXG4gIGFuaW1hdGVQYW5lbHMoaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgY29uc3QgaXNOZXh0ID0gY3VycmVudCA8IGluZGV4O1xuXG4gICAgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkgJiYgdGhpcy4kc2xpZGVzW2N1cnJlbnRdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJy0nIDogJyd9MTAwJSlgLCBvcGFjaXR5OiAwIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLiRzbGlkZXNbaW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJycgOiAnLSd9MTAwJSlgLCBvcGFjaXR5OiAwIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvcGFjaXR5OiAxIH1cbiAgICBdLCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyk7XG4gIH1cblxuICBhbmltYXRlTWFya2VyKGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgIGxlZnQ6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5vZmZzZXRMZWZ0LFxuICAgICAgd2lkdGg6IHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XS5jbGllbnRXaWR0aFxuICAgIH07XG5cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy4kY29udHJvbHNbaW5kZXhdLm9mZnNldExlZnQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLiRjb250cm9sc1tpbmRleF0uY2xpZW50V2lkdGg7XG5cbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLiRtYXJrZXIuYW5pbWF0ZShbXG4gICAgICB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtjdXJyZW50LmxlZnR9cHgpYCxcbiAgICAgICAgd2lkdGg6IGAke2N1cnJlbnQud2lkdGh9cHhgXG4gICAgICB9LCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KWAsXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGBcbiAgICAgIH1cbiAgICBdLCB7Li4uUEFORUxfQU5JTUFUSU9OX09QVElPTlMsIGZpbGw6ICdub25lJ30pO1xuXG4gICAgcGxheWVyLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgdGhpcy5zZXRNb2QodGhpcy4kY29udHJvbHNbaW5kZXhdLCAnbmF2LWl0ZW0nLCAnbWFya2VyJyk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVsTW9kKHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XSwgJ25hdi1pdGVtJywgJ21hcmtlcicpXG4gIH1cblxuICBnZXRJbmRleEJ5RWxlbShlbGVtKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICB0aGlzLiRjb250cm9scy5zb21lKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG59IiwiY29uc3Qgb2JqZWN0VG9RdWVyeSA9ICh0YXJnZXQpID0+IChcbiAgJz8nICsgT2JqZWN0LmtleXModGFyZ2V0KS5yZWR1Y2UoKGFyciwga2V5KSA9PiAoXG4gICAgYXJyLnB1c2goYCR7a2V5fT0ke3RhcmdldFtrZXldfWApICYmIGFyclxuICApLCBbXSkuam9pbignJicpXG4pO1xuXG5leHBvcnQgY29uc3QgbnVtYmVyRm9ybWF0dGluZyA9IG51bWJlciA9PiAoXG4gIG51bWJlci50b0ZpeGVkKDIpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrXFwuKS9nLCAnJDEgJykuc3BsaXQoJy4nKVswXVxuKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoSlNPTiA9ICh1cmwsIG9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcgfSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgaWYgKG9wdGlvbnMuYm9keSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB1cmwgKz0gb2JqZWN0VG9RdWVyeShvcHRpb25zLmJvZHkpO1xuICB9XG5cbiAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc29sdmUoSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCkpO1xuICB9O1xuXG4gIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdDtcbiAgcmVxdWVzdC5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCB1cmwpO1xuICByZXF1ZXN0LnNlbmQob3B0aW9ucy5ib2R5ID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSA6IG51bGwpO1xufSk7Il19
