(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],2:[function(require,module,exports){
/*
 * smoothscroll polyfill - v0.3.5
 * https://iamdustan.github.io/smoothscroll
 * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License
 */

(function(w, d, undefined) {
  'use strict';

  /*
   * aliases
   * w: window global object
   * d: document
   * undefined: undefined
   */

  // polyfill
  function polyfill() {
    // return when scrollBehavior interface is supported
    if ('scrollBehavior' in d.documentElement.style) {
      return;
    }

    /*
     * globals
     */
    var Element = w.HTMLElement || w.Element;
    var SCROLL_TIME = 468;

    /*
     * object gathering original scroll methods
     */
    var original = {
      scroll: w.scroll || w.scrollTo,
      scrollBy: w.scrollBy,
      elScroll: Element.prototype.scroll || scrollElement,
      scrollIntoView: Element.prototype.scrollIntoView
    };

    /*
     * define timing method
     */
    var now = w.performance && w.performance.now
      ? w.performance.now.bind(w.performance) : Date.now;

    /**
     * changes scroll position inside an element
     * @method scrollElement
     * @param {Number} x
     * @param {Number} y
     */
    function scrollElement(x, y) {
      this.scrollLeft = x;
      this.scrollTop = y;
    }

    /**
     * returns result of applying ease math function to a number
     * @method ease
     * @param {Number} k
     * @returns {Number}
     */
    function ease(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    }

    /**
     * indicates if a smooth behavior should be applied
     * @method shouldBailOut
     * @param {Number|Object} x
     * @returns {Boolean}
     */
    function shouldBailOut(x) {
      if (typeof x !== 'object'
            || x === null
            || x.behavior === undefined
            || x.behavior === 'auto'
            || x.behavior === 'instant') {
        // first arg not an object/null
        // or behavior is auto, instant or undefined
        return true;
      }

      if (typeof x === 'object'
            && x.behavior === 'smooth') {
        // first argument is an object and behavior is smooth
        return false;
      }

      // throw error when behavior is not supported
      throw new TypeError('behavior not valid');
    }

    /**
     * finds scrollable parent of an element
     * @method findScrollableParent
     * @param {Node} el
     * @returns {Node} el
     */
    function findScrollableParent(el) {
      var isBody;
      var hasScrollableSpace;
      var hasVisibleOverflow;

      do {
        el = el.parentNode;

        // set condition variables
        isBody = el === d.body;
        hasScrollableSpace =
          el.clientHeight < el.scrollHeight ||
          el.clientWidth < el.scrollWidth;
        hasVisibleOverflow =
          w.getComputedStyle(el, null).overflow === 'visible';
      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));

      isBody = hasScrollableSpace = hasVisibleOverflow = null;

      return el;
    }

    /**
     * self invoked function that, given a context, steps through scrolling
     * @method step
     * @param {Object} context
     */
    function step(context) {
      var time = now();
      var value;
      var currentX;
      var currentY;
      var elapsed = (time - context.startTime) / SCROLL_TIME;

      // avoid elapsed times higher than one
      elapsed = elapsed > 1 ? 1 : elapsed;

      // apply easing to elapsed time
      value = ease(elapsed);

      currentX = context.startX + (context.x - context.startX) * value;
      currentY = context.startY + (context.y - context.startY) * value;

      context.method.call(context.scrollable, currentX, currentY);

      // scroll more if we have not reached our destination
      if (currentX !== context.x || currentY !== context.y) {
        w.requestAnimationFrame(step.bind(w, context));
      }
    }

    /**
     * scrolls window with a smooth behavior
     * @method smoothScroll
     * @param {Object|Node} el
     * @param {Number} x
     * @param {Number} y
     */
    function smoothScroll(el, x, y) {
      var scrollable;
      var startX;
      var startY;
      var method;
      var startTime = now();

      // define scroll context
      if (el === d.body) {
        scrollable = w;
        startX = w.scrollX || w.pageXOffset;
        startY = w.scrollY || w.pageYOffset;
        method = original.scroll;
      } else {
        scrollable = el;
        startX = el.scrollLeft;
        startY = el.scrollTop;
        method = scrollElement;
      }

      // scroll looping over a frame
      step({
        scrollable: scrollable,
        method: method,
        startTime: startTime,
        startX: startX,
        startY: startY,
        x: x,
        y: y
      });
    }

    /*
     * ORIGINAL METHODS OVERRIDES
     */

    // w.scroll and w.scrollTo
    w.scroll = w.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scroll.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left,
        ~~arguments[0].top
      );
    };

    // w.scrollBy
    w.scrollBy = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollBy.call(
          w,
          arguments[0].left || arguments[0],
          arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
        w,
        d.body,
        ~~arguments[0].left + (w.scrollX || w.pageXOffset),
        ~~arguments[0].top + (w.scrollY || w.pageYOffset)
      );
    };

    // Element.prototype.scroll and Element.prototype.scrollTo
    Element.prototype.scroll = Element.prototype.scrollTo = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.elScroll.call(
            this,
            arguments[0].left || arguments[0],
            arguments[0].top || arguments[1]
        );
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      smoothScroll.call(
          this,
          this,
          arguments[0].left,
          arguments[0].top
      );
    };

    // Element.prototype.scrollBy
    Element.prototype.scrollBy = function() {
      var arg0 = arguments[0];

      if (typeof arg0 === 'object') {
        this.scroll({
          left: arg0.left + this.scrollLeft,
          top: arg0.top + this.scrollTop,
          behavior: arg0.behavior
        });
      } else {
        this.scroll(
          this.scrollLeft + arg0,
          this.scrollTop + arguments[1]
        );
      }
    };

    // Element.prototype.scrollIntoView
    Element.prototype.scrollIntoView = function() {
      // avoid smooth behavior if not required
      if (shouldBailOut(arguments[0])) {
        original.scrollIntoView.call(this, arguments[0] || true);
        return;
      }

      // LET THE SMOOTHNESS BEGIN!
      var scrollableParent = findScrollableParent(this);
      var parentRects = scrollableParent.getBoundingClientRect();
      var clientRects = this.getBoundingClientRect();

      if (scrollableParent !== d.body) {
        // reveal element inside parent
        smoothScroll.call(
          this,
          scrollableParent,
          scrollableParent.scrollLeft + clientRects.left - parentRects.left,
          scrollableParent.scrollTop + clientRects.top - parentRects.top
        );
        // reveal parent in viewport
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      } else {
        // reveal element in viewport
        w.scrollBy({
          left: clientRects.left,
          top: clientRects.top,
          behavior: 'smooth'
        });
      }
    };
  }

  if (typeof exports === 'object') {
    // commonjs
    module.exports = { polyfill: polyfill };
  } else {
    // global
    polyfill();
  }
})(window, document);

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var toArray = exports.toArray = function toArray(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return arrayLike;
  }

  if (arrayLike instanceof Node) {
    return [arrayLike];
  }

  return Array.prototype.slice.call(arrayLike);
};

var $ = exports.$ = function $(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return toArray(context.querySelectorAll.call(context, selector));
};

var selector = exports.selector = function selector(block, elem, modName, modVal) {
  return block + '__' + elem + (modName ? modVal ? '_' + modName + '_' + modVal : '_' + modName : '');
};

var buildClass = exports.buildClass = function buildClass() {
  return '.' + selector.apply(undefined, arguments);
};

var BEM = exports.BEM = function (_ref) {
  _inherits(BEM, _ref);

  function BEM(name, node) {
    _classCallCheck(this, BEM);

    var _this = _possibleConstructorReturn(this, (BEM.__proto__ || Object.getPrototypeOf(BEM)).call(this));

    _this.node = node;
    _this.name = name;
    return _this;
  }

  _createClass(BEM, [{
    key: 'elem',
    value: function elem(name, modName, modVal) {
      return this.node.querySelector(buildClass(this.name, name, modName, modVal));
    }
  }, {
    key: 'elems',
    value: function elems(name, modName, modVal) {
      return $(buildClass(this.name, name, modName, modVal), this.node);
    }
  }, {
    key: 'setMod',
    value: function setMod(elem, elemName, modName, modValue) {
      var _this2 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.add(selector(_this2.name, elemName, modName, modValue));
      });

      return this;
    }
  }, {
    key: 'delMod',
    value: function delMod(elem, elemName, modName) {
      var _this3 = this;

      toArray(elem).forEach(function (node) {
        return node.classList.remove(selector(_this3.name, elemName, modName));
      });

      return this;
    }
  }]);

  return BEM;
}(null);

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feedback = function (_BEM) {
  _inherits(Feedback, _BEM);

  function Feedback(node) {
    _classCallCheck(this, Feedback);

    var _this = _possibleConstructorReturn(this, (Feedback.__proto__ || Object.getPrototypeOf(Feedback)).call(this, 'feedback', node));

    _this.$name = _this.elem('name');
    _this.$message = _this.elem('message');
    _this.$mailTo = _this.elem('mailto');

    node.onsubmit = function (e) {
      e.preventDefault();

      _this.$mailTo.href = 'mailto:info@nszu.gov.ua?subject=\u0417\u0432\u043E\u0440\u043E\u0442\u043D\u0456\u0439 \u0437\u0432\u2019\u044F\u0437\u043E\u043A \u0432\u0456\u0434 ' + _this.$name.value + '&body=' + _this.$message.value;
      _this.$mailTo.click();
      return false;
    };
    return _this;
  }

  return Feedback;
}(_dom.BEM);

exports.default = Feedback;
module.exports = exports['default'];

},{"./dom":3}],5:[function(require,module,exports){
'use strict';

var _promisePolyfill = require('promise-polyfill');

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _smoothscrollPolyfill = require('smoothscroll-polyfill');

var _smoothscrollPolyfill2 = _interopRequireDefault(_smoothscrollPolyfill);

var _dom = require('./dom');

var _utils = require('./utils');

var _nav = require('./nav');

var _nav2 = _interopRequireDefault(_nav);

var _tabs = require('./tabs');

var _tabs2 = _interopRequireDefault(_tabs);

var _slider = require('./slider');

var _slider2 = _interopRequireDefault(_slider);

var _map = require('./map');

var _map2 = _interopRequireDefault(_map);

var _statistic = require('./statistic');

var _statistic2 = _interopRequireDefault(_statistic);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.Promise) {
  window.Promise = _promisePolyfill2.default;
}

_smoothscrollPolyfill2.default.polyfill();

(0, _dom.$)('.nav').forEach(function (node) {
  return new _nav2.default(node);
});
(0, _dom.$)('.tabs').forEach(function (node) {
  return new _tabs2.default(node);
});
(0, _dom.$)('.slider').forEach(function (node) {
  return new _slider2.default(node);
});
(0, _dom.$)('.feedback').forEach(function (node) {
  return new _feedback2.default(node);
});

(0, _utils.fetchJSON)('data/stats.json').then(function (data) {
  (0, _dom.$)('.map').forEach(function (node) {
    return new _map2.default(node, data.slice());
  });
  (0, _dom.$)('.declarations').forEach(function (node) {
    return new _statistic2.default(node, data);
  });
});

},{"./dom":3,"./feedback":4,"./map":6,"./nav":7,"./slider":8,"./statistic":9,"./tabs":10,"./utils":11,"promise-polyfill":1,"smoothscroll-polyfill":2}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require("./dom");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HOVER_DEBOUNCE_TIMEOUT = 200;

var REGION_POINT_MAP = {
  "Київ": { left: 453, top: 170 },
  "Луцьк": { left: 153, top: 100 },
  "Львов": { left: 83, top: 206 },
  "Ужгород": { left: 48, top: 312 },
  "Ивано-Франковск": { left: 153, top: 312 },
  "Черновцы": { left: 207, top: 329 },
  "Тернополь": { left: 188, top: 241 },
  "Ровно": { left: 241, top: 100 },
  "Хмельницкий": { left: 259, top: 206 },
  "Житомир": { left: 347, top: 153 },
  "Винница": { left: 365, top: 277 },
  "Черкассы": { left: 523, top: 241 },
  "Кировоград": { left: 541, top: 312 },
  "Полтава": { left: 646, top: 188 },
  "Чернигов": { left: 541, top: 65 },
  "Суммы": { left: 646, top: 100 },
  "Харьков": { left: 770, top: 205 },
  "Луганск": { left: 911, top: 259 },
  "Днепропетровск": { left: 682, top: 311 },
  "Донецк": { left: 840, top: 347 },
  "Запорожье": { left: 752, top: 417 },
  "Херсон": { left: 629, top: 452 },
  "Николаев": { left: 523, top: 399 },
  "Одесса": { left: 453, top: 435 },
  "Крым": { left: 664, top: 558 }
};

var createPoint = function createPoint(_ref) {
  var left = _ref.left,
      top = _ref.top;

  var node = document.createElement('div');

  node.classList.add('map__point');
  node.style.left = left + "px";
  node.style.top = top + "px";

  return node;
};

var Map = function (_BEM) {
  _inherits(Map, _BEM);

  function Map(node, data) {
    _classCallCheck(this, Map);

    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, 'map', node));

    _this.data = [];
    _this.timeout = null;


    _this.data = data;
    _this.$tooltip = _this.elem('tooltip');

    var fragment = document.createDocumentFragment();

    data.forEach(function (item, index) {
      var point = createPoint(REGION_POINT_MAP[item.region_name]);
      point.dataset.index = index;

      point.addEventListener('mouseover', _this, false);
      point.addEventListener('mouseout', _this, false);

      fragment.appendChild(point);
    });

    _this.$tooltip.addEventListener('mouseover', _this, false);
    _this.$tooltip.addEventListener('mouseout', _this, false);

    _this.elem('main').appendChild(fragment);
    return _this;
  }

  _createClass(Map, [{
    key: "handleEvent",
    value: function handleEvent(_ref2) {
      var _this2 = this;

      var target = _ref2.target,
          type = _ref2.type;

      if (type === 'mouseover' && target.dataset.index) {
        this.$tooltip.style.top = target.style.top;
        this.$tooltip.style.left = target.style.left;
      }

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        switch (type) {
          case 'mouseout':
            _this2.delMod(_this2.$tooltip, 'tooltip', 'show');
            _this2.delMod(_this2.$active, 'point', 'active');
            break;
          case 'mouseover':
            var data = _this2.data[target.dataset.index];

            if (data) {
              var $tooltipData = _this2.$tooltip.querySelectorAll((0, _dom.buildClass)('map', 'tooltip-data') + " dt");

              _this2.$tooltip.style.top = target.style.top;
              _this2.$tooltip.style.left = target.style.left;

              _this2.$active && _this2.delMod(_this2.$active, 'point', 'active');
              _this2.setMod(_this2.$tooltip, 'tooltip', 'show');

              _this2.$tooltip.querySelector((0, _dom.buildClass)('map', 'tooltip-title')).textContent = data.region_name;
              _this2.$active = target;

              $tooltipData[0].textContent = data.medical_system_providers;
              $tooltipData[1].textContent = data.doctors;
              $tooltipData[2].textContent = data.declarations_signed;

              _this2.setMod(_this2.$active, 'point', 'active');
            }

            _this2.setMod(_this2.$tooltip, 'tooltip', 'show');
            break;
        }
      }, HOVER_DEBOUNCE_TIMEOUT);
    }
  }]);

  return Map;
}(_dom.BEM);

exports.default = Map;
module.exports = exports["default"];

},{"./dom":3}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Nav = function Nav(node) {
  _classCallCheck(this, Nav);

  node.addEventListener('click', function (e) {
    e.preventDefault();

    if (e.target.href === undefined) {
      return;
    }

    var to = e.target.href.split('#')[1];

    var _document$getElementB = document.getElementById(to).getBoundingClientRect(),
        top = _document$getElementB.top;

    window.scroll({ top: top + window.scrollY - 50, left: 0, behavior: 'smooth' });
  });
};

exports.default = Nav;
module.exports = exports['default'];

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createMarker = function createMarker() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var node = document.createElement('li');

  node.classList.add((0, _dom.selector)('slider', 'marker'));
  active && node.classList.add((0, _dom.selector)('slider', 'marker', 'active'));

  return node;
};

var Slider = function (_BEM) {
  _inherits(Slider, _BEM);

  function Slider(node) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, 'slider', node));

    _this.currentIndex = 0;

    _this.$slides = _this.elems('slide');

    _this.$markers = [];

    _this.$control = document.createElement('ul');
    _this.$control.classList.add((0, _dom.selector)(_this.name, 'markers'));

    _this.$slides.forEach(function (node, index) {
      var marker = createMarker(index === _this.currentIndex);
      _this.$control.appendChild(marker);
      _this.$markers.push(marker);
    });

    _this.$control.addEventListener('click', function (_ref) {
      var target = _ref.target;

      if (!target.closest((0, _dom.buildClass)(_this.name, 'marker'))) {
        return;
      }

      var toIndex = _this.getIndexByElem(target);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('marker', 'active'), 'marker', 'active');
      _this.setMod(target, 'marker', 'active');

      _this.slide(toIndex);
    }, false);

    _this.node.appendChild(_this.$control);
    return _this;
  }

  _createClass(Slider, [{
    key: 'slide',
    value: function slide(index) {
      var isNext = this.currentIndex < index;

      this.$slides[this.currentIndex].animate([{ transform: 'translateX(0)' }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)' }], this.constructor.ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)' }, { transform: 'translateX(0)' }], this.constructor.ANIMATION_OPTIONS);

      this.currentIndex = index;
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$markers.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Slider;
}(_dom.BEM);

Slider.ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};
exports.default = Slider;
module.exports = exports['default'];

},{"./dom":3}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COLORS_MAP = ['#90c8e6', '#b097c6', '#dfb0d0', '#e3aab8', '#afd5e7', '#c7b2d5', '#e9c7df', '#ecc7cf', '#f1eec9', '#ced8e2', '#5da892', '#5296cd', '#a3d7f2', '#f3f1a0', '#bcdad5', '#71b7a8', '#5ca9dc', '#dc91a3', '#d8816f', '#e2a394', '#7566aa', '#cadfeb', '#ddd2df', '#f4d9b5', '#d381b2'];

var createListItemNode = function createListItemNode(title, value, color) {
  var $li = document.createElement('li');
  var $span = document.createElement('span');
  var $value = document.createElement('div');

  $li.classList.add((0, _dom.selector)('declarations', 'list-item'));
  $li.textContent = title;

  $span.style.backgroundColor = color;

  $value.classList.add((0, _dom.selector)('declarations', 'list-item-value'));
  $value.textContent = (0, _utils.numberFormatting)(value);

  $li.prepend($span);
  $li.append($value);

  return $li;
};

var Statistic = function (_BEM) {
  _inherits(Statistic, _BEM);

  function Statistic(node, data) {
    _classCallCheck(this, Statistic);

    var _this = _possibleConstructorReturn(this, (Statistic.__proto__ || Object.getPrototypeOf(Statistic)).call(this, 'declarations', node));

    var fragment = document.createDocumentFragment();

    _this.$canvas = _this.elem('graph-canvas');
    _this.context = _this.$canvas.getContext('2d');

    var total = data.reduce(function (target, _ref) {
      var declarations = _ref.declarations;
      return target + declarations;
    }, 0);

    data.sort(function (a, b) {
      return a.declarations < b.declarations ? 1 : -1;
    });

    var x = 490,
        y = 490,
        r = 480,
        s = 0;


    data.forEach(function (item, index) {
      var $item = createListItemNode(item.region_name, item.declarations, COLORS_MAP[index]);

      fragment.appendChild($item);

      var radians = item.declarations / data[0].declarations * 360 * (Math.PI / 360);

      _this.context.beginPath();
      _this.context.lineWidth = 6;
      _this.context.strokeStyle = COLORS_MAP[index];
      _this.context.arc(x, y, r - 20 * index, s, radians, false);
      _this.context.stroke();
    });

    _this.elem('list').appendChild(fragment);
    _this.elem('total-value').textContent = (0, _utils.numberFormatting)(total);
    return _this;
  }

  return Statistic;
}(_dom.BEM);

exports.default = Statistic;
module.exports = exports['default'];

},{"./dom":3,"./utils":11}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = require('./dom');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PANEL_ANIMATION_OPTIONS = {
  duration: 300,
  fill: 'forwards',
  easing: 'ease-in-out'
};

var Tabs = function (_BEM) {
  _inherits(Tabs, _BEM);

  function Tabs(node) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$autoHeight = _ref.autoHeight,
        autoHeight = _ref$autoHeight === undefined ? false : _ref$autoHeight;

    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, 'tabs', node));

    _this.$controls = _this.elems('nav-item');
    _this.$slides = _this.elems('slide');

    _this.$marker = document.createElement('div');
    _this.$marker.classList.add((0, _dom.selector)(_this.name, 'marker'));
    _this.elem('header').appendChild(_this.$marker);

    if (autoHeight) {
      var maxHeight = _this.$slides.reduce(function (target, item) {
        if (item.clientHeight > target) {
          target = item.clientHeight;
        }

        return target;
      }, 0);

      _this.elem('main').style.height = maxHeight + 'px';
    }

    _this.currentIndex = _this.getIndexByElem(_this.elem('nav-item', 'active'));

    _this.elem('nav').addEventListener('click', function (e) {
      var $elem = e.target.closest((0, _dom.buildClass)(_this.name, 'nav-item'));

      if (!$elem) {
        return;
      }

      var toIndex = _this.getIndexByElem($elem);

      if (toIndex === _this.currentIndex) {
        return;
      }

      _this.delMod(_this.elem('nav-item', 'active'), 'nav-item', 'active');
      _this.setMod($elem, 'nav-item', 'active');

      _this.animatePanels(toIndex);
      _this.animateMarker(toIndex);

      _this.currentIndex = toIndex;
    }, false);

    _this.setMod(_this.elem('nav-item', 'active'), 'nav-item', 'marker');
    return _this;
  }

  _createClass(Tabs, [{
    key: 'animatePanels',
    value: function animatePanels(index) {
      var current = this.currentIndex;
      var isNext = current < index;

      current !== undefined && this.$slides[current].animate([{ transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(' + (isNext ? '-' : '') + '100%)', opacity: 0 }], PANEL_ANIMATION_OPTIONS);

      this.$slides[index].animate([{ transform: 'translateX(' + (isNext ? '' : '-') + '100%)', opacity: 0 }, { transform: 'translateX(0)', opacity: 1 }], PANEL_ANIMATION_OPTIONS);
    }
  }, {
    key: 'animateMarker',
    value: function animateMarker(index) {
      var _this2 = this;

      var current = {
        left: this.$controls[this.currentIndex].offsetLeft,
        width: this.$controls[this.currentIndex].clientWidth
      };

      var left = this.$controls[index].offsetLeft;
      var width = this.$controls[index].clientWidth;

      var player = this.$marker.animate([{
        transform: 'translateX(' + current.left + 'px)',
        width: current.width + 'px'
      }, {
        transform: 'translateX(' + left + 'px)',
        width: width + 'px'
      }], _extends({}, PANEL_ANIMATION_OPTIONS));

      player.onfinish = function () {
        _this2.setMod(_this2.$controls[index], 'nav-item', 'marker');
        requestAnimationFrame(function () {
          return player.cancel();
        });
      };

      this.delMod(this.$controls[this.currentIndex], 'nav-item', 'marker');
    }
  }, {
    key: 'getIndexByElem',
    value: function getIndexByElem(elem) {
      var index = -1;

      this.$controls.some(function (node, i) {
        if (node === elem) {
          index = i;
          return true;
        }
      });

      return index;
    }
  }]);

  return Tabs;
}(_dom.BEM);

exports.default = Tabs;
module.exports = exports['default'];

},{"./dom":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var objectToQuery = function objectToQuery(target) {
  return '?' + Object.keys(target).reduce(function (arr, key) {
    return arr.push(key + '=' + target[key]) && arr;
  }, []).join('&');
};

var numberFormatting = exports.numberFormatting = function numberFormatting(number) {
  return number.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1 ').split('.')[0];
};

var fetchJSON = exports.fetchJSON = function fetchJSON(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { method: 'GET' };
  return new Promise(function (resolve, reject) {
    var request = new XMLHttpRequest();

    if (options.body && options.method === 'GET') {
      url += objectToQuery(options.body);
    }

    request.onreadystatechange = function () {
      if (request.readyState !== 4) {
        return;
      }

      resolve(JSON.parse(request.responseText));
    };

    request.onerror = reject;
    request.open(options.method || 'GET', url);
    request.send(options.body ? JSON.stringify(options.body) : null);
  });
};

},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcyIsInNyYy9zY3JpcHRzL2RvbS5qcyIsInNyYy9zY3JpcHRzL2ZlZWRiYWNrLmpzIiwic3JjL3NjcmlwdHMvbWFpbi5qcyIsInNyYy9zY3JpcHRzL21hcC5qcyIsInNyYy9zY3JpcHRzL25hdi5qcyIsInNyYy9zY3JpcHRzL3NsaWRlci5qcyIsInNyYy9zY3JpcHRzL3N0YXRpc3RpYy5qcyIsInNyYy9zY3JpcHRzL3RhYnMuanMiLCJzcmMvc2NyaXB0cy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QThCO0FBQzVCO0FBQ0Q7O0FBRUQsY0FBUSxLQUFLLEtBQUwsQ0FBVyxRQUFRLFlBQW5CLENBQVI7QUFDRCxLQU5EOztBQVFBLFlBQVEsT0FBUixHQUFrQixNQUFsQjtBQUNBLFlBQVEsSUFBUixDQUFhLFFBQVEsTUFBUixJQUFrQixLQUEvQixFQUFzQyxHQUF0QztBQUNBLFlBQVEsSUFBUixDQUFhLFFBQVEsSUFBUixHQUFlLEtBQUssU0FBTCxDQUFlLFFBQVEsSUFBdkIsQ0FBZixHQUE4QyxJQUEzRDtBQUNELEdBbEI4RCxDQUF0QztBQUFBLENBQWxCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocm9vdCkge1xuXG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBcbiAgLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICAgIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHNlbGYsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHNlbGYuX3N0YXRlID0gMjtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgIH1cbiAgICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gICAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICAgKlxuICAgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gICAqL1xuICBmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb20gPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKG5vb3ApO1xuXG4gICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgcmV0dXJuIHByb207XG4gIH07XG5cbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIHBvbHlmaWxsIGZvciBzZXRJbW1lZGlhdGUgZm9yIHBlcmZvcm1hbmNlIGdhaW5zXG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH0pIHx8XG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gICAgfTtcblxuICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBpbW1lZGlhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFja3NcbiAgICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0SW1tZWRpYXRlRm4gPSBmdW5jdGlvbiBfc2V0SW1tZWRpYXRlRm4oZm4pIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9IGZuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuKGZuKSB7XG4gICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmbjtcbiAgfTtcbiAgXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiAgfSBlbHNlIGlmICghcm9vdC5Qcm9taXNlKSB7XG4gICAgcm9vdC5Qcm9taXNlID0gUHJvbWlzZTtcbiAgfVxuXG59KSh0aGlzKTtcbiIsIi8qXG4gKiBzbW9vdGhzY3JvbGwgcG9seWZpbGwgLSB2MC4zLjVcbiAqIGh0dHBzOi8vaWFtZHVzdGFuLmdpdGh1Yi5pby9zbW9vdGhzY3JvbGxcbiAqIDIwMTYgKGMpIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbih3LCBkLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIGFsaWFzZXNcbiAgICogdzogd2luZG93IGdsb2JhbCBvYmplY3RcbiAgICogZDogZG9jdW1lbnRcbiAgICogdW5kZWZpbmVkOiB1bmRlZmluZWRcbiAgICovXG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gcmV0dXJuIHdoZW4gc2Nyb2xsQmVoYXZpb3IgaW50ZXJmYWNlIGlzIHN1cHBvcnRlZFxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBnbG9iYWxzXG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvKlxuICAgICAqIG9iamVjdCBnYXRoZXJpbmcgb3JpZ2luYWwgc2Nyb2xsIG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgb3JpZ2luYWwgPSB7XG4gICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeTogdy5zY3JvbGxCeSxcbiAgICAgIGVsU2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIGRlZmluZSB0aW1pbmcgbWV0aG9kXG4gICAgICovXG4gICAgdmFyIG5vdyA9IHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgID8gdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3LnBlcmZvcm1hbmNlKSA6IERhdGUubm93O1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB4XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dCh4KSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnXG4gICAgICAgICAgICB8fCB4ID09PSBudWxsXG4gICAgICAgICAgICB8fCB4LmJlaGF2aW9yID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgIHx8IHguYmVoYXZpb3IgPT09ICdhdXRvJ1xuICAgICAgICAgICAgfHwgeC5iZWhhdmlvciA9PT0gJ2luc3RhbnQnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZyBub3QgYW4gb2JqZWN0L251bGxcbiAgICAgICAgLy8gb3IgYmVoYXZpb3IgaXMgYXV0bywgaW5zdGFudCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHguYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiZWhhdmlvciBub3QgdmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgdmFyIGlzQm9keTtcbiAgICAgIHZhciBoYXNTY3JvbGxhYmxlU3BhY2U7XG4gICAgICB2YXIgaGFzVmlzaWJsZU92ZXJmbG93O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAvLyBzZXQgY29uZGl0aW9uIHZhcmlhYmxlc1xuICAgICAgICBpc0JvZHkgPSBlbCA9PT0gZC5ib2R5O1xuICAgICAgICBoYXNTY3JvbGxhYmxlU3BhY2UgPVxuICAgICAgICAgIGVsLmNsaWVudEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCB8fFxuICAgICAgICAgIGVsLmNsaWVudFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgIGhhc1Zpc2libGVPdmVyZmxvdyA9XG4gICAgICAgICAgdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5vdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgICAgfSB3aGlsZSAoIWlzQm9keSAmJiAhKGhhc1Njcm9sbGFibGVTcGFjZSAmJiAhaGFzVmlzaWJsZU92ZXJmbG93KSk7XG5cbiAgICAgIGlzQm9keSA9IGhhc1Njcm9sbGFibGVTcGFjZSA9IGhhc1Zpc2libGVPdmVyZmxvdyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IHdpdGggYSBzbW9vdGggYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHNtb290aFNjcm9sbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIE9SSUdJTkFMIE1FVEhPRFMgT1ZFUlJJREVTXG4gICAgICovXG5cbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQsXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0IHx8IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxTY3JvbGwuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCB8fCBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0udG9wIHx8IGFyZ3VtZW50c1sxXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeVxuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLnNjcm9sbCh7XG4gICAgICAgICAgbGVmdDogYXJnMC5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYXJnMC50b3AgKyB0aGlzLnNjcm9sbFRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogYXJnMC5iZWhhdmlvclxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKFxuICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCArIGFyZzAsXG4gICAgICAgICAgdGhpcy5zY3JvbGxUb3AgKyBhcmd1bWVudHNbMV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSB8fCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcbiAgICAgICAgLy8gcmV2ZWFsIHBhcmVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBjbGllbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gY29tbW9uanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgcG9seWZpbGw6IHBvbHlmaWxsIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2xvYmFsXG4gICAgcG9seWZpbGwoKTtcbiAgfVxufSkod2luZG93LCBkb2N1bWVudCk7XG4iLCJleHBvcnQgY29uc3QgdG9BcnJheSA9IGFycmF5TGlrZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5TGlrZSkpIHtcbiAgICByZXR1cm4gYXJyYXlMaWtlO1xuICB9XG5cbiAgaWYgKGFycmF5TGlrZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gIH1cblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn07XG5cbmV4cG9ydCBjb25zdCAkID0gKHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpID0+IChcbiAgdG9BcnJheShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChjb250ZXh0LCBzZWxlY3RvcikpXG4pO1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0b3IgPSAoYmxvY2ssIGVsZW0sIG1vZE5hbWUsIG1vZFZhbCkgPT4gKFxuICBgJHtibG9ja31fXyR7ZWxlbX0ke21vZE5hbWUgPyAobW9kVmFsID8gYF8ke21vZE5hbWV9XyR7bW9kVmFsfWAgOiBgXyR7bW9kTmFtZX1gKSA6ICcnfWBcbik7XG5cbmV4cG9ydCBjb25zdCBidWlsZENsYXNzID0gKC4uLmFyZ3MpID0+IGAuJHtzZWxlY3RvciguLi5hcmdzKX1gO1xuXG5leHBvcnQgY2xhc3MgQkVNIGV4dGVuZHMgbnVsbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIG5vZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIGVsZW0obmFtZSwgbW9kTmFtZSwgbW9kVmFsKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpKTtcbiAgfVxuXG4gIGVsZW1zKG5hbWUsIG1vZE5hbWUsIG1vZFZhbCkge1xuICAgIHJldHVybiAkKGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCBuYW1lLCBtb2ROYW1lLCBtb2RWYWwpLCB0aGlzLm5vZGUpO1xuICB9XG5cbiAgc2V0TW9kKGVsZW0sIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lLCBtb2RWYWx1ZSkpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbE1vZChlbGVtLCBlbGVtTmFtZSwgbW9kTmFtZSkge1xuICAgIHRvQXJyYXkoZWxlbSkuZm9yRWFjaChub2RlID0+IChcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShzZWxlY3Rvcih0aGlzLm5hbWUsIGVsZW1OYW1lLCBtb2ROYW1lKSlcbiAgICApKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59IiwiaW1wb3J0IHsgQkVNIH0gZnJvbSAnLi9kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWVkYmFjayBleHRlbmRzIEJFTSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignZmVlZGJhY2snLCBub2RlKTtcblxuICAgIHRoaXMuJG5hbWUgPSB0aGlzLmVsZW0oJ25hbWUnKTtcbiAgICB0aGlzLiRtZXNzYWdlID0gdGhpcy5lbGVtKCdtZXNzYWdlJyk7XG4gICAgdGhpcy4kbWFpbFRvID0gdGhpcy5lbGVtKCdtYWlsdG8nKTtcblxuICAgIG5vZGUub25zdWJtaXQgPSAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLiRtYWlsVG8uaHJlZiA9IGBtYWlsdG86aW5mb0Buc3p1Lmdvdi51YT9zdWJqZWN0PdCX0LLQvtGA0L7RgtC90ZbQuSDQt9Cy4oCZ0Y/Qt9C+0Log0LLRltC0ICR7dGhpcy4kbmFtZS52YWx1ZX0mYm9keT0ke3RoaXMuJG1lc3NhZ2UudmFsdWV9YDtcbiAgICAgIHRoaXMuJG1haWxUby5jbGljaygpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSIsImltcG9ydCBQcm9taXNlIGZyb20gJ3Byb21pc2UtcG9seWZpbGwnO1xuaW1wb3J0IFNtb290aFNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuXG5pbXBvcnQgeyAkIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCBOYXYgZnJvbSAnLi9uYXYnO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi90YWJzJztcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IE1hcCBmcm9tICcuL21hcCc7XG5pbXBvcnQgU3RhdGlzdGljIGZyb20gJy4vc3RhdGlzdGljJztcbmltcG9ydCBGZWVkYmFjayBmcm9tICcuL2ZlZWRiYWNrJztcblxuaWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuICB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cblNtb290aFNjcm9sbC5wb2x5ZmlsbCgpO1xuXG4kKCcubmF2JykuZm9yRWFjaChub2RlID0+IG5ldyBOYXYobm9kZSkpO1xuJCgnLnRhYnMnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IFRhYnMobm9kZSkpO1xuJCgnLnNsaWRlcicpLmZvckVhY2gobm9kZSA9PiBuZXcgU2xpZGVyKG5vZGUpKTtcbiQoJy5mZWVkYmFjaycpLmZvckVhY2gobm9kZSA9PiBuZXcgRmVlZGJhY2sobm9kZSkpO1xuXG5mZXRjaEpTT04oJ2RhdGEvc3RhdHMuanNvbicpLnRoZW4oZGF0YSA9PiB7XG4gICQoJy5tYXAnKS5mb3JFYWNoKG5vZGUgPT4gbmV3IE1hcChub2RlLCBkYXRhLnNsaWNlKCkpKTtcbiAgJCgnLmRlY2xhcmF0aW9ucycpLmZvckVhY2gobm9kZSA9PiBuZXcgU3RhdGlzdGljKG5vZGUsIGRhdGEpKTtcbn0pO1xuIiwiaW1wb3J0IHsgQkVNLCBidWlsZENsYXNzIH0gZnJvbSAnLi9kb20nO1xuXG5jb25zdCBIT1ZFUl9ERUJPVU5DRV9USU1FT1VUID0gMjAwO1xuXG5jb25zdCBSRUdJT05fUE9JTlRfTUFQID0ge1xuICBcItCa0LjRl9CyXCI6IHsgbGVmdDogNDUzLCB0b3A6IDE3MCB9LFxuICBcItCb0YPRhtGM0LpcIjogeyBsZWZ0OiAxNTMsIHRvcDogMTAwIH0sXG4gIFwi0JvRjNCy0L7QslwiOiB7IGxlZnQ6IDgzLCB0b3A6IDIwNiB9LFxuICBcItCj0LbQs9C+0YDQvtC0XCI6IHsgbGVmdDogNDgsIHRvcDogMzEyIH0sXG4gIFwi0JjQstCw0L3Qvi3QpNGA0LDQvdC60L7QstGB0LpcIjogeyBsZWZ0OiAxNTMsIHRvcDogMzEyIH0sXG4gIFwi0KfQtdGA0L3QvtCy0YbRi1wiOiB7IGxlZnQ6IDIwNywgdG9wOiAzMjkgfSxcbiAgXCLQotC10YDQvdC+0L/QvtC70YxcIjogeyBsZWZ0OiAxODgsIHRvcDogMjQxIH0sXG4gIFwi0KDQvtCy0L3QvlwiOiB7IGxlZnQ6IDI0MSwgdG9wOiAxMDAgfSxcbiAgXCLQpdC80LXQu9GM0L3QuNGG0LrQuNC5XCI6IHsgbGVmdDogMjU5LCB0b3A6IDIwNiB9LFxuICBcItCW0LjRgtC+0LzQuNGAXCI6IHsgbGVmdDogMzQ3LCB0b3A6IDE1MyB9LFxuICBcItCS0LjQvdC90LjRhtCwXCI6IHsgbGVmdDogMzY1LCB0b3A6IDI3NyB9LFxuICBcItCn0LXRgNC60LDRgdGB0YtcIjogeyBsZWZ0OiA1MjMsIHRvcDogMjQxIH0sXG4gIFwi0JrQuNGA0L7QstC+0LPRgNCw0LRcIjogeyBsZWZ0OiA1NDEsIHRvcDogMzEyIH0sXG4gIFwi0J/QvtC70YLQsNCy0LBcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTg4IH0sXG4gIFwi0KfQtdGA0L3QuNCz0L7QslwiOiB7IGxlZnQ6IDU0MSwgdG9wOiA2NSB9LFxuICBcItCh0YPQvNC80YtcIjogeyBsZWZ0OiA2NDYsIHRvcDogMTAwIH0sXG4gIFwi0KXQsNGA0YzQutC+0LJcIjogeyBsZWZ0OiA3NzAsIHRvcDogMjA1IH0sXG4gIFwi0JvRg9Cz0LDQvdGB0LpcIjogeyBsZWZ0OiA5MTEsIHRvcDogMjU5IH0sXG4gIFwi0JTQvdC10L/RgNC+0L/QtdGC0YDQvtCy0YHQulwiOiB7IGxlZnQ6IDY4MiwgdG9wOiAzMTEgfSxcbiAgXCLQlNC+0L3QtdGG0LpcIjogeyBsZWZ0OiA4NDAsIHRvcDogMzQ3IH0sXG4gIFwi0JfQsNC/0L7RgNC+0LbRjNC1XCI6IHsgbGVmdDogNzUyLCB0b3A6IDQxNyB9LFxuICBcItCl0LXRgNGB0L7QvVwiOiB7IGxlZnQ6IDYyOSwgdG9wOiA0NTIgfSxcbiAgXCLQndC40LrQvtC70LDQtdCyXCI6IHsgbGVmdDogNTIzLCB0b3A6IDM5OSB9LFxuICBcItCe0LTQtdGB0YHQsFwiOiB7IGxlZnQ6IDQ1MywgdG9wOiA0MzUgfSxcbiAgXCLQmtGA0YvQvFwiOiB7IGxlZnQ6IDY2NCwgdG9wOiA1NTggfVxufTtcblxuY29uc3QgY3JlYXRlUG9pbnQgPSAoeyBsZWZ0LCB0b3AgfSkgPT4ge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCdtYXBfX3BvaW50Jyk7XG4gIG5vZGUuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICBub2RlLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXAgZXh0ZW5kcyBCRU0ge1xuICBkYXRhID0gW107XG4gIHRpbWVvdXQgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGRhdGEpIHtcbiAgICBzdXBlcignbWFwJywgbm9kZSk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuJHRvb2x0aXAgPSB0aGlzLmVsZW0oJ3Rvb2x0aXAnKTtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVQb2ludChSRUdJT05fUE9JTlRfTUFQW2l0ZW0ucmVnaW9uX25hbWVdKTtcbiAgICAgIHBvaW50LmRhdGFzZXQuaW5kZXggPSBpbmRleDtcblxuICAgICAgcG9pbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcywgZmFsc2UpO1xuICAgICAgcG9pbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBvaW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcywgZmFsc2UpO1xuICAgIHRoaXMuJHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmVsZW0oJ21haW4nKS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICBoYW5kbGVFdmVudCh7IHRhcmdldCwgdHlwZSB9KSB7XG4gICAgaWYgKHR5cGUgPT09ICdtb3VzZW92ZXInICYmIHRhcmdldC5kYXRhc2V0LmluZGV4KSB7XG4gICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLnRvcCA9IHRhcmdldC5zdHlsZS50b3A7XG4gICAgICB0aGlzLiR0b29sdGlwLnN0eWxlLmxlZnQgPSB0YXJnZXQuc3R5bGUubGVmdDtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICAgICAgdGhpcy5kZWxNb2QodGhpcy4kdG9vbHRpcCwgJ3Rvb2x0aXAnLCAnc2hvdycpO1xuICAgICAgICAgIHRoaXMuZGVsTW9kKHRoaXMuJGFjdGl2ZSwgJ3BvaW50JywgJ2FjdGl2ZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGFbdGFyZ2V0LmRhdGFzZXQuaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0b29sdGlwRGF0YSA9IHRoaXMuJHRvb2x0aXAucXVlcnlTZWxlY3RvckFsbChgJHtidWlsZENsYXNzKCdtYXAnLCAndG9vbHRpcC1kYXRhJyl9IGR0YCk7XG5cbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUudG9wID0gdGFyZ2V0LnN0eWxlLnRvcDtcbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAuc3R5bGUubGVmdCA9IHRhcmdldC5zdHlsZS5sZWZ0O1xuXG4gICAgICAgICAgICB0aGlzLiRhY3RpdmUgJiYgdGhpcy5kZWxNb2QodGhpcy4kYWN0aXZlLCAncG9pbnQnLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiR0b29sdGlwLCAndG9vbHRpcCcsICdzaG93Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuJHRvb2x0aXAucXVlcnlTZWxlY3RvcihidWlsZENsYXNzKCdtYXAnLCAndG9vbHRpcC10aXRsZScpKS50ZXh0Q29udGVudCA9IGRhdGEucmVnaW9uX25hbWU7XG4gICAgICAgICAgICB0aGlzLiRhY3RpdmUgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgICR0b29sdGlwRGF0YVswXS50ZXh0Q29udGVudCA9IGRhdGEubWVkaWNhbF9zeXN0ZW1fcHJvdmlkZXJzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzFdLnRleHRDb250ZW50ID0gZGF0YS5kb2N0b3JzO1xuICAgICAgICAgICAgJHRvb2x0aXBEYXRhWzJdLnRleHRDb250ZW50ID0gZGF0YS5kZWNsYXJhdGlvbnNfc2lnbmVkO1xuXG4gICAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiRhY3RpdmUsICdwb2ludCcsICdhY3RpdmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldE1vZCh0aGlzLiR0b29sdGlwLCAndG9vbHRpcCcsICdzaG93Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgSE9WRVJfREVCT1VOQ0VfVElNRU9VVCk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBOYXYge1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZS50YXJnZXQuaHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG8gPSBlLnRhcmdldC5ocmVmLnNwbGl0KCcjJylbMV07XG4gICAgICBjb25zdCB7IHRvcCB9ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG8pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB3aW5kb3cuc2Nyb2xsKHsgdG9wOiAodG9wICsgd2luZG93LnNjcm9sbFkpIC0gNTAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9KVxuICB9XG59IiwiaW1wb3J0IHsgQkVNLCBidWlsZENsYXNzLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcblxuY29uc3QgY3JlYXRlTWFya2VyID0gKGFjdGl2ZSA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcignc2xpZGVyJywgJ21hcmtlcicpKTtcbiAgYWN0aXZlICYmIG5vZGUuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcignc2xpZGVyJywgJ21hcmtlcicsICdhY3RpdmUnKSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBCRU0ge1xuICBjdXJyZW50SW5kZXggPSAwO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignc2xpZGVyJywgbm9kZSk7XG4gICAgdGhpcy4kc2xpZGVzID0gdGhpcy5lbGVtcygnc2xpZGUnKTtcblxuICAgIHRoaXMuJG1hcmtlcnMgPSBbXTtcblxuICAgIHRoaXMuJGNvbnRyb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHRoaXMuJGNvbnRyb2wuY2xhc3NMaXN0LmFkZChzZWxlY3Rvcih0aGlzLm5hbWUsICdtYXJrZXJzJykpO1xuXG4gICAgdGhpcy4kc2xpZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIoaW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuJGNvbnRyb2wuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICAgIHRoaXMuJG1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kY29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICBpZiAoIXRhcmdldC5jbG9zZXN0KGJ1aWxkQ2xhc3ModGhpcy5uYW1lLCAnbWFya2VyJykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9JbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUVsZW0odGFyZ2V0KTtcblxuICAgICAgaWYgKHRvSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWxNb2QodGhpcy5lbGVtKCdtYXJrZXInLCAnYWN0aXZlJyksICdtYXJrZXInLCAnYWN0aXZlJyk7XG4gICAgICB0aGlzLnNldE1vZCh0YXJnZXQsICdtYXJrZXInLCAnYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuc2xpZGUodG9JbmRleCk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuJGNvbnRyb2wpO1xuICB9XG5cbiAgc2xpZGUoaW5kZXgpIHtcbiAgICBjb25zdCBpc05leHQgPSB0aGlzLmN1cnJlbnRJbmRleCA8IGluZGV4O1xuXG4gICAgdGhpcy4kc2xpZGVzW3RoaXMuY3VycmVudEluZGV4XS5hbmltYXRlKFtcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2lzTmV4dCA/ICctJyA6ICcnfTEwMCUpYCB9XG4gICAgXSwgdGhpcy5jb25zdHJ1Y3Rvci5BTklNQVRJT05fT1BUSU9OUyk7XG5cbiAgICB0aGlzLiRzbGlkZXNbaW5kZXhdLmFuaW1hdGUoW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7aXNOZXh0ID8gJycgOiAnLSd9MTAwJSlgIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH1cbiAgICBdLCB0aGlzLmNvbnN0cnVjdG9yLkFOSU1BVElPTl9PUFRJT05TKTtcblxuICAgIHRoaXMuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gIH1cblxuICBnZXRJbmRleEJ5RWxlbShlbGVtKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICB0aGlzLiRtYXJrZXJzLnNvbWUoKG5vZGUsIGkpID0+IHtcbiAgICAgIGlmIChub2RlID09PSBlbGVtKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBzdGF0aWMgQU5JTUFUSU9OX09QVElPTlMgPSB7XG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgIGVhc2luZzogJ2Vhc2UtaW4tb3V0J1xuICB9XG59IiwiaW1wb3J0IHsgQkVNLCBzZWxlY3RvciB9IGZyb20gJy4vZG9tJztcbmltcG9ydCB7IG51bWJlckZvcm1hdHRpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQ09MT1JTX01BUCA9IFtcbiAgJyM5MGM4ZTYnLCAnI2IwOTdjNicsICcjZGZiMGQwJyxcbiAgJyNlM2FhYjgnLCAnI2FmZDVlNycsICcjYzdiMmQ1JyxcbiAgJyNlOWM3ZGYnLCAnI2VjYzdjZicsICcjZjFlZWM5JyxcbiAgJyNjZWQ4ZTInLCAnIzVkYTg5MicsICcjNTI5NmNkJyxcbiAgJyNhM2Q3ZjInLCAnI2YzZjFhMCcsICcjYmNkYWQ1JyxcbiAgJyM3MWI3YTgnLCAnIzVjYTlkYycsICcjZGM5MWEzJyxcbiAgJyNkODgxNmYnLCAnI2UyYTM5NCcsICcjNzU2NmFhJyxcbiAgJyNjYWRmZWInLCAnI2RkZDJkZicsICcjZjRkOWI1JyxcbiAgJyNkMzgxYjInXG5dO1xuXG5jb25zdCBjcmVhdGVMaXN0SXRlbU5vZGUgPSAodGl0bGUsIHZhbHVlLCBjb2xvcikgPT4ge1xuICBjb25zdCAkbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBjb25zdCAkc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgY29uc3QgJHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgJGxpLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IoJ2RlY2xhcmF0aW9ucycsICdsaXN0LWl0ZW0nKSk7XG4gICRsaS50ZXh0Q29udGVudCA9IHRpdGxlO1xuXG4gICRzcGFuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuXG4gICR2YWx1ZS5jbGFzc0xpc3QuYWRkKHNlbGVjdG9yKCdkZWNsYXJhdGlvbnMnLCAnbGlzdC1pdGVtLXZhbHVlJykpO1xuICAkdmFsdWUudGV4dENvbnRlbnQgPSBudW1iZXJGb3JtYXR0aW5nKHZhbHVlKTtcblxuICAkbGkucHJlcGVuZCgkc3Bhbik7XG4gICRsaS5hcHBlbmQoJHZhbHVlKTtcblxuICByZXR1cm4gJGxpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGlzdGljIGV4dGVuZHMgQkVNIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgZGF0YSkge1xuICAgIHN1cGVyKCdkZWNsYXJhdGlvbnMnLCBub2RlKTtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgdGhpcy4kY2FudmFzID0gdGhpcy5lbGVtKCdncmFwaC1jYW52YXMnKTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLiRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGNvbnN0IHRvdGFsID0gZGF0YS5yZWR1Y2UoKHRhcmdldCwgeyBkZWNsYXJhdGlvbnMgfSkgPT4gdGFyZ2V0ICsgZGVjbGFyYXRpb25zLCAwKTtcblxuICAgIGRhdGEuc29ydCgoYSwgYikgPT4gYS5kZWNsYXJhdGlvbnMgPCBiLmRlY2xhcmF0aW9ucyA/IDEgOiAtMSk7XG5cbiAgICBsZXQgW3gsIHksIHIsIHNdID0gWzQ5MCwgNDkwLCA0ODAsIDBdO1xuXG4gICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgJGl0ZW0gPSBjcmVhdGVMaXN0SXRlbU5vZGUoXG4gICAgICAgIGl0ZW0ucmVnaW9uX25hbWUsXG4gICAgICAgIGl0ZW0uZGVjbGFyYXRpb25zLFxuICAgICAgICBDT0xPUlNfTUFQW2luZGV4XVxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoJGl0ZW0pO1xuXG4gICAgICBsZXQgcmFkaWFucyA9ICgoaXRlbS5kZWNsYXJhdGlvbnMgLyBkYXRhWzBdLmRlY2xhcmF0aW9ucykgKiAzNjApICogKE1hdGguUEkgLyAzNjApO1xuXG4gICAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmNvbnRleHQubGluZVdpZHRoID0gNjtcbiAgICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IENPTE9SU19NQVBbaW5kZXhdO1xuICAgICAgdGhpcy5jb250ZXh0LmFyYyh4LCB5LCByIC0gKDIwICogaW5kZXgpLCBzLCByYWRpYW5zLCBmYWxzZSk7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVsZW0oJ2xpc3QnKS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgdGhpcy5lbGVtKCd0b3RhbC12YWx1ZScpLnRleHRDb250ZW50ID0gbnVtYmVyRm9ybWF0dGluZyh0b3RhbCk7XG4gIH1cbn0iLCJpbXBvcnQgeyAkLCBCRU0sIGJ1aWxkQ2xhc3MsIHNlbGVjdG9yIH0gZnJvbSAnLi9kb20nO1xuXG5jb25zdCBQQU5FTF9BTklNQVRJT05fT1BUSU9OUyA9IHtcbiAgZHVyYXRpb246IDMwMCxcbiAgZmlsbDogJ2ZvcndhcmRzJyxcbiAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJzIGV4dGVuZHMgQkVNIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgeyBhdXRvSGVpZ2h0ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgc3VwZXIoJ3RhYnMnLCBub2RlKTtcblxuICAgIHRoaXMuJGNvbnRyb2xzID0gdGhpcy5lbGVtcygnbmF2LWl0ZW0nKTtcbiAgICB0aGlzLiRzbGlkZXMgPSB0aGlzLmVsZW1zKCdzbGlkZScpO1xuXG4gICAgdGhpcy4kbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy4kbWFya2VyLmNsYXNzTGlzdC5hZGQoc2VsZWN0b3IodGhpcy5uYW1lLCAnbWFya2VyJykpO1xuICAgIHRoaXMuZWxlbSgnaGVhZGVyJykuYXBwZW5kQ2hpbGQodGhpcy4kbWFya2VyKTtcblxuICAgIGlmIChhdXRvSGVpZ2h0KSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLiRzbGlkZXMucmVkdWNlKCh0YXJnZXQsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uY2xpZW50SGVpZ2h0ID4gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gaXRlbS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSwgMCk7XG5cbiAgICAgIHRoaXMuZWxlbSgnbWFpbicpLnN0eWxlLmhlaWdodCA9IGAke21heEhlaWdodH1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSB0aGlzLmdldEluZGV4QnlFbGVtKHRoaXMuZWxlbSgnbmF2LWl0ZW0nLCAnYWN0aXZlJykpO1xuXG4gICAgdGhpcy5lbGVtKCduYXYnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBjb25zdCAkZWxlbSA9IGUudGFyZ2V0LmNsb3Nlc3QoYnVpbGRDbGFzcyh0aGlzLm5hbWUsICduYXYtaXRlbScpKTtcblxuICAgICAgaWYgKCEkZWxlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvSW5kZXggPSB0aGlzLmdldEluZGV4QnlFbGVtKCRlbGVtKTtcblxuICAgICAgaWYgKHRvSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWxNb2QodGhpcy5lbGVtKCduYXYtaXRlbScsICdhY3RpdmUnKSwgJ25hdi1pdGVtJywgJ2FjdGl2ZScpO1xuICAgICAgdGhpcy5zZXRNb2QoJGVsZW0sICduYXYtaXRlbScsICdhY3RpdmUnKTtcblxuICAgICAgdGhpcy5hbmltYXRlUGFuZWxzKHRvSW5kZXgpO1xuICAgICAgdGhpcy5hbmltYXRlTWFya2VyKHRvSW5kZXgpO1xuXG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHRvSW5kZXg7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGhpcy5zZXRNb2QodGhpcy5lbGVtKCduYXYtaXRlbScsICdhY3RpdmUnKSwgJ25hdi1pdGVtJywgJ21hcmtlcicpO1xuICB9XG5cbiAgYW5pbWF0ZVBhbmVscyhpbmRleCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRJbmRleDtcbiAgICBjb25zdCBpc05leHQgPSBjdXJyZW50IDwgaW5kZXg7XG5cbiAgICAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSAmJiB0aGlzLiRzbGlkZXNbY3VycmVudF0uYW5pbWF0ZShbXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtpc05leHQgPyAnLScgOiAnJ30xMDAlKWAsIG9wYWNpdHk6IDAgfVxuICAgIF0sIFBBTkVMX0FOSU1BVElPTl9PUFRJT05TKTtcblxuICAgIHRoaXMuJHNsaWRlc1tpbmRleF0uYW5pbWF0ZShbXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtpc05leHQgPyAnJyA6ICctJ30xMDAlKWAsIG9wYWNpdHk6IDAgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScsIG9wYWNpdHk6IDEgfVxuICAgIF0sIFBBTkVMX0FOSU1BVElPTl9PUFRJT05TKTtcbiAgfVxuXG4gIGFuaW1hdGVNYXJrZXIoaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgbGVmdDogdGhpcy4kY29udHJvbHNbdGhpcy5jdXJyZW50SW5kZXhdLm9mZnNldExlZnQsXG4gICAgICB3aWR0aDogdGhpcy4kY29udHJvbHNbdGhpcy5jdXJyZW50SW5kZXhdLmNsaWVudFdpZHRoXG4gICAgfTtcblxuICAgIGNvbnN0IGxlZnQgPSB0aGlzLiRjb250cm9sc1tpbmRleF0ub2Zmc2V0TGVmdDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuJGNvbnRyb2xzW2luZGV4XS5jbGllbnRXaWR0aDtcblxuICAgIGNvbnN0IHBsYXllciA9IHRoaXMuJG1hcmtlci5hbmltYXRlKFtcbiAgICAgIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2N1cnJlbnQubGVmdH1weClgLFxuICAgICAgICB3aWR0aDogYCR7Y3VycmVudC53aWR0aH1weGBcbiAgICAgIH0sIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke2xlZnR9cHgpYCxcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YFxuICAgICAgfVxuICAgIF0sIHsuLi5QQU5FTF9BTklNQVRJT05fT1BUSU9OUyB9KTtcblxuICAgIHBsYXllci5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0TW9kKHRoaXMuJGNvbnRyb2xzW2luZGV4XSwgJ25hdi1pdGVtJywgJ21hcmtlcicpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHBsYXllci5jYW5jZWwoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVsTW9kKHRoaXMuJGNvbnRyb2xzW3RoaXMuY3VycmVudEluZGV4XSwgJ25hdi1pdGVtJywgJ21hcmtlcicpXG4gIH1cblxuICBnZXRJbmRleEJ5RWxlbShlbGVtKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICB0aGlzLiRjb250cm9scy5zb21lKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG59IiwiY29uc3Qgb2JqZWN0VG9RdWVyeSA9ICh0YXJnZXQpID0+IChcbiAgJz8nICsgT2JqZWN0LmtleXModGFyZ2V0KS5yZWR1Y2UoKGFyciwga2V5KSA9PiAoXG4gICAgYXJyLnB1c2goYCR7a2V5fT0ke3RhcmdldFtrZXldfWApICYmIGFyclxuICApLCBbXSkuam9pbignJicpXG4pO1xuXG5leHBvcnQgY29uc3QgbnVtYmVyRm9ybWF0dGluZyA9IG51bWJlciA9PiAoXG4gIG51bWJlci50b0ZpeGVkKDIpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrXFwuKS9nLCAnJDEgJykuc3BsaXQoJy4nKVswXVxuKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoSlNPTiA9ICh1cmwsIG9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcgfSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgaWYgKG9wdGlvbnMuYm9keSAmJiBvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB1cmwgKz0gb2JqZWN0VG9RdWVyeShvcHRpb25zLmJvZHkpO1xuICB9XG5cbiAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc29sdmUoSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCkpO1xuICB9O1xuXG4gIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdDtcbiAgcmVxdWVzdC5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCB1cmwpO1xuICByZXF1ZXN0LnNlbmQob3B0aW9ucy5ib2R5ID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSA6IG51bGwpO1xufSk7Il19
